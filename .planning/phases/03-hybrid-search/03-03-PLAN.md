---
phase: 03-hybrid-search
plan: 03
type: execute
wave: 2
depends_on: [03-01, 03-02]
files_modified:
  - services/hh-search-svc/src/pgvector-client.ts
  - services/hh-search-svc/src/types.ts
  - services/hh-search-svc/src/routes.ts
autonomous: true

must_haves:
  truths:
    - "Hybrid search uses RRF (Reciprocal Rank Fusion) to combine vector and text results"
    - "RRF score is computed as 1/(k+vector_rank) + 1/(k+text_rank)"
    - "Candidates found by EITHER vector OR text search appear in results (union, not intersection)"
    - "Results are ordered by rrf_score DESC"
  artifacts:
    - path: "services/hh-search-svc/src/pgvector-client.ts"
      provides: "RRF fusion SQL implementation"
      contains: "rrf_score"
    - path: "services/hh-search-svc/src/types.ts"
      provides: "rrfScore type definition"
      contains: "rrf_score"
  key_links:
    - from: "hybridSearch function"
      to: "rrf_scored CTE"
      via: "FULL OUTER JOIN + RRF formula"
      pattern: "1.0.*rrfK.*rank"
---

<objective>
Implement Reciprocal Rank Fusion (RRF) to combine vector similarity and text search results.

Purpose: RRF is simpler and more robust than weighted linear combination. It uses rank positions rather than absolute scores, eliminating the need for score normalization between different scales.

Output: Hybrid search returns candidates ranked by RRF score, combining semantic (vector) and exact keyword (text) matches.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-hybrid-search/03-RESEARCH.md

# Key source files - modified by prior plans
@services/hh-search-svc/src/pgvector-client.ts
@services/hh-search-svc/src/config.ts
@services/hh-search-svc/src/types.ts
@services/hh-search-svc/src/routes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement RRF scoring SQL in hybridSearch</name>
  <files>services/hh-search-svc/src/pgvector-client.ts</files>
  <action>
Replace the weighted linear combination with RRF scoring in the hybridSearch SQL query.

The new query structure should be:

```sql
WITH vector_candidates AS (
  SELECT
    ce.entity_id AS candidate_id,
    1 - (ce.embedding <=> $2) AS vector_score,
    ROW_NUMBER() OVER (ORDER BY ce.embedding <=> $2 ASC) AS vector_rank,
    ce.metadata,
    ce.updated_at
  FROM ${this.config.schema}.${this.config.embeddingsTable} AS ce
  WHERE ce.tenant_id = $1
  ORDER BY ce.embedding <=> $2 ASC
  LIMIT $3
),
text_candidates AS (
  SELECT
    cp.candidate_id,
    ts_rank_cd(cp.search_document, plainto_tsquery('${PG_FTS_DICTIONARY}', $4)) AS text_score,
    ROW_NUMBER() OVER (ORDER BY ts_rank_cd(cp.search_document, plainto_tsquery('${PG_FTS_DICTIONARY}', $4)) DESC) AS text_rank
  FROM ${this.config.schema}.${this.config.profilesTable} AS cp
  WHERE cp.tenant_id = $1
    AND $4 IS NOT NULL
    AND $4 != ''
    AND cp.search_document @@ plainto_tsquery('${PG_FTS_DICTIONARY}', $4)
  ORDER BY text_score DESC
  LIMIT $3
),
rrf_scored AS (
  SELECT
    COALESCE(vc.candidate_id, tc.candidate_id) AS candidate_id,
    vc.vector_score,
    vc.vector_rank,
    tc.text_score,
    tc.text_rank,
    COALESCE(1.0 / ($10 + vc.vector_rank), 0) AS rrf_vector,
    COALESCE(1.0 / ($10 + tc.text_rank), 0) AS rrf_text,
    COALESCE(1.0 / ($10 + vc.vector_rank), 0) + COALESCE(1.0 / ($10 + tc.text_rank), 0) AS rrf_score,
    vc.metadata,
    vc.updated_at
  FROM vector_candidates vc
  FULL OUTER JOIN text_candidates tc ON vc.candidate_id = tc.candidate_id
)
SELECT
  rs.candidate_id,
  cp.full_name,
  cp.current_title,
  cp.headline,
  cp.location,
  cp.country,
  cp.industries,
  cp.skills,
  cp.years_experience,
  cp.analysis_confidence,
  cp.profile,
  cp.legal_basis,
  cp.consent_record,
  cp.transfer_mechanism,
  rs.metadata,
  COALESCE(rs.vector_score, 0) AS vector_score,
  COALESCE(rs.text_score, 0) AS text_score,
  rs.rrf_score,
  rs.vector_rank,
  rs.text_rank,
  -- Keep hybrid_score for backward compatibility (will be same as rrf_score)
  rs.rrf_score AS hybrid_score,
  to_char(COALESCE(rs.updated_at, timezone('utc', now())), 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"') AS updated_at
FROM rrf_scored rs
JOIN ${this.config.schema}.${this.config.profilesTable} AS cp
  ON cp.candidate_id = rs.candidate_id AND cp.tenant_id = $1
WHERE COALESCE(rs.vector_score, 0) >= $7 OR COALESCE(rs.text_score, 0) > 0
${filterClause}
ORDER BY rs.rrf_score DESC, rs.candidate_id ASC
LIMIT $8
OFFSET $9;
```

Key changes from current implementation:
1. Added rrf_scored CTE with RRF calculation: 1/(k+rank)
2. FULL OUTER JOIN ensures candidates from either method appear
3. RRF score is sum of individual RRF contributions
4. hybrid_score is now aliased to rrf_score for backward compatibility
5. ORDER BY rrf_score DESC (not weighted sum)

Also add conditional logic to support the enableRrf flag:
```typescript
if (query.enableRrf) {
  // Use RRF SQL (above)
} else {
  // Fall back to existing weighted sum SQL (for A/B testing)
}
```
  </action>
  <verify>
TypeScript compiles: `cd services/hh-search-svc && npm run build`
Grep for RRF SQL: `grep -n "rrf_score\|rrf_scored" services/hh-search-svc/src/pgvector-client.ts | head -20`
  </verify>
  <done>
RRF scoring implemented in hybridSearch SQL. Candidates ranked by rrf_score instead of weighted sum.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update types to include RRF fields</name>
  <files>services/hh-search-svc/src/types.ts</files>
  <action>
Update type definitions to include RRF-related fields.

1. Update PgHybridSearchRow to include new fields (around line 80):
```typescript
export interface PgHybridSearchRow {
  candidate_id: string;
  full_name?: string | null;
  current_title?: string | null;
  headline?: string | null;
  location?: string | null;
  country?: string | null;
  industries?: string[] | null;
  skills?: string[] | null;
  years_experience?: number | null;
  analysis_confidence?: number | null;
  profile?: Record<string, unknown> | null;
  metadata?: Record<string, unknown> | null;
  legal_basis?: string | null;
  consent_record?: string | null;
  transfer_mechanism?: string | null;
  vector_score: number | null;
  text_score: number | null;
  hybrid_score: number | null;
  updated_at?: string | null;
  // RRF additions
  rrf_score?: number | null;
  vector_rank?: number | null;
  text_rank?: number | null;
}
```

2. Update HybridSearchResultItem to expose RRF data (around line 32):
```typescript
export interface HybridSearchResultItem {
  candidateId: string;
  score: number;           // This is now the RRF score
  vectorScore: number;
  textScore: number;
  rrfScore?: number;       // Explicit RRF score
  vectorRank?: number;     // Rank in vector results
  textRank?: number;       // Rank in text results
  confidence: number;
  fullName?: string;
  title?: string;
  location?: string;
  country?: string;
  headline?: string;
  skills?: CandidateSkillMatch[];
  industries?: string[];
  yearsExperience?: number;
  matchReasons: string[];
  metadata?: Record<string, unknown>;
  compliance?: {
    legalBasis?: string | null;
    consentRecord?: string | null;
    transferMechanism?: string | null;
  };
}
```
  </action>
  <verify>
TypeScript compiles: `cd services/hh-search-svc && npm run build`
Grep for new types: `grep -n "rrf_score\|rrfScore\|vector_rank\|vectorRank" services/hh-search-svc/src/types.ts`
  </verify>
  <done>
Types updated to include rrf_score, vector_rank, and text_rank fields.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update result transformation to use RRF</name>
  <files>services/hh-search-svc/src/routes.ts</files>
  <action>
Update the search route handler to pass RRF configuration and transform RRF results.

1. Find where PgHybridSearchQuery is constructed and add RRF config:
```typescript
const pgQuery: PgHybridSearchQuery = {
  tenantId: context.tenant.id,
  embedding: embedding,
  textQuery: request.query || '',
  limit: limit,
  offset: offset,
  minSimilarity: config.search.minSimilarity,
  vectorWeight: config.search.vectorWeight,
  textWeight: config.search.textWeight,
  warmupMultiplier: config.search.warmupMultiplier,
  filters: request.filters,
  // RRF config
  rrfK: config.search.rrfK,
  perMethodLimit: config.search.perMethodLimit,
  enableRrf: config.search.enableRrf
};
```

2. Find the result transformation that maps PgHybridSearchRow to HybridSearchResultItem and update it to include RRF fields:
```typescript
const result: HybridSearchResultItem = {
  candidateId: row.candidate_id,
  score: row.rrf_score ?? row.hybrid_score ?? 0,  // Prefer RRF score
  vectorScore: row.vector_score ?? 0,
  textScore: row.text_score ?? 0,
  rrfScore: row.rrf_score ?? undefined,
  vectorRank: row.vector_rank ?? undefined,
  textRank: row.text_rank ?? undefined,
  confidence: row.analysis_confidence ?? 0,
  // ... rest of mapping
};
```

3. Add debug output when includeDebug is true:
```typescript
if (request.includeDebug) {
  response.debug = {
    ...response.debug,
    rrfConfig: {
      enabled: config.search.enableRrf,
      k: config.search.rrfK,
      perMethodLimit: config.search.perMethodLimit
    },
    scoreBreakdown: results.slice(0, 5).map(r => ({
      candidateId: r.candidateId,
      vectorScore: r.vectorScore,
      textScore: r.textScore,
      rrfScore: r.rrfScore,
      vectorRank: r.vectorRank,
      textRank: r.textRank
    }))
  };
}
```
  </action>
  <verify>
TypeScript compiles: `cd services/hh-search-svc && npm run build`
Grep for RRF usage: `grep -n "rrfK\|rrfScore\|enableRrf" services/hh-search-svc/src/routes.ts`
  </verify>
  <done>
Search route updated to pass RRF config and transform results with RRF fields.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compiles without errors:
   ```bash
   cd services/hh-search-svc && npm run build
   ```

2. RRF SQL is implemented:
   ```bash
   grep -c "rrf_scored" services/hh-search-svc/src/pgvector-client.ts
   # Should return 2+ (CTE definition and usage)
   ```

3. Types include RRF fields:
   ```bash
   grep "rrfScore" services/hh-search-svc/src/types.ts
   # Should return matches for HybridSearchResultItem
   ```

4. Routes use RRF config:
   ```bash
   grep "enableRrf" services/hh-search-svc/src/routes.ts
   # Should return match for query construction
   ```

5. RRF formula is correct:
   ```bash
   grep "1.0 / (\$10 + " services/hh-search-svc/src/pgvector-client.ts
   # Should find RRF calculation
   ```
</verification>

<success_criteria>
- RRF scoring SQL implemented with rrf_scored CTE
- FULL OUTER JOIN combines vector and text candidates (union, not intersection)
- RRF score computed as sum of 1/(k+vector_rank) + 1/(k+text_rank)
- Results ordered by rrf_score DESC
- Types updated with rrfScore, vectorRank, textRank
- Routes pass RRF config and transform results correctly
- Debug output includes RRF breakdown
- TypeScript compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/03-hybrid-search/03-03-SUMMARY.md`
</output>
