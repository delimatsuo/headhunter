---
phase: 09-match-transparency
plan: 05
type: execute
wave: 3
depends_on: ["09-03", "09-04"]
files_modified:
  - services/hh-rerank-svc/src/together-client.ts
  - services/hh-rerank-svc/src/types.ts
  - services/hh-search-svc/src/search-service.ts
  - services/hh-search-svc/src/types.ts
autonomous: true

must_haves:
  truths:
    - "Top 10 candidates have LLM-generated match rationale"
    - "Rationale includes summary and key strength highlights"
    - "Rationale is cached in Redis with 24h TTL"
  artifacts:
    - path: "services/hh-rerank-svc/src/together-client.ts"
      provides: "generateMatchRationale method"
      contains: "generateMatchRationale"
    - path: "services/hh-search-svc/src/search-service.ts"
      provides: "Integration of rationale into search results"
      contains: "matchRationale"
  key_links:
    - from: "services/hh-search-svc/src/search-service.ts"
      to: "services/hh-rerank-svc"
      via: "rerank client"
      pattern: "includeMatchRationale"
---

<objective>
Extend the rerank service to generate LLM match rationales for top candidates and integrate into search results.

Purpose: TRNS-03 requirement: "LLM-generated match rationale for top candidates." Recruiters need human-readable explanations of why a candidate is a good fit.

Output: Top 10 candidates in search results include LLM-generated rationale with summary and key strengths.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase research with rationale design
@.planning/phases/09-match-transparency/09-RESEARCH.md

# Existing rerank service to extend
@services/hh-rerank-svc/src/together-client.ts

# Search service for integration
@services/hh-search-svc/src/search-service.ts
@services/hh-search-svc/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MatchRationale types</name>
  <files>
    services/hh-rerank-svc/src/types.ts
    services/hh-search-svc/src/types.ts
  </files>
  <action>
Add MatchRationale interface to both services:

**In services/hh-rerank-svc/src/types.ts**, add:
```typescript
/**
 * LLM-generated match rationale for top candidates.
 * Explains why a candidate is a good fit for the role.
 */
export interface MatchRationale {
  /** 2-3 sentence summary of why candidate matches */
  summary: string;
  /** Top 2-3 key strengths */
  keyStrengths: string[];
  /** Which signals drove the match */
  signalHighlights: Array<{
    signal: string;
    score: number;
    reason: string;
  }>;
}
```

**In services/hh-search-svc/src/types.ts**, add the same interface:
```typescript
export interface MatchRationale {
  summary: string;
  keyStrengths: string[];
  signalHighlights: Array<{
    signal: string;
    score: number;
    reason: string;
  }>;
}
```

Also extend HybridSearchResultItem:
```typescript
export interface HybridSearchResultItem {
  // ... existing fields

  /**
   * LLM-generated match rationale (only for top candidates).
   * @see TRNS-03
   */
  matchRationale?: MatchRationale;
}
```
  </action>
  <verify>TypeScript compilation passes in both services</verify>
  <done>MatchRationale interface defined in both rerank and search services</done>
</task>

<task type="auto">
  <name>Task 2: Add generateMatchRationale to Together client</name>
  <files>services/hh-rerank-svc/src/together-client.ts</files>
  <action>
Add a method to generate match rationales using Together AI:

```typescript
import { MatchRationale } from './types';

// Add method to TogetherClient class
async generateMatchRationale(
  jobDescription: string,
  candidateSummary: string,
  topSignals: Array<{ name: string; score: number }>
): Promise<MatchRationale> {
  const prompt = this.buildRationalePrompt(jobDescription, candidateSummary, topSignals);

  try {
    const response = await this.chat([
      { role: 'system', content: 'You are a recruitment assistant that explains candidate-job matches concisely.' },
      { role: 'user', content: prompt }
    ], {
      temperature: 0.7,
      max_tokens: 300,
      response_format: { type: 'json_object' }
    });

    return this.parseRationaleResponse(response);
  } catch (error) {
    this.logger.error('Failed to generate match rationale', { error });
    // Return minimal rationale on error
    return {
      summary: 'Match analysis unavailable.',
      keyStrengths: [],
      signalHighlights: []
    };
  }
}

private buildRationalePrompt(
  jobDescription: string,
  candidateSummary: string,
  topSignals: Array<{ name: string; score: number }>
): string {
  const signalsList = topSignals
    .map(s => `- ${s.name}: ${Math.round(s.score * 100)}%`)
    .join('\n');

  return `Given:
Job Description: ${jobDescription.slice(0, 500)}...

Candidate Summary: ${candidateSummary.slice(0, 500)}...

Top Match Signals:
${signalsList}

Generate a brief match explanation in JSON format:
{
  "summary": "2-3 sentence explanation of why this candidate matches",
  "keyStrengths": ["strength 1", "strength 2"],
  "signalHighlights": [
    {"signal": "Skills Match", "score": 0.92, "reason": "why this signal is relevant"}
  ]
}

Focus on concrete qualifications and relevance to the role.`;
}

private parseRationaleResponse(response: string): MatchRationale {
  try {
    const parsed = JSON.parse(response);
    return {
      summary: parsed.summary || 'Match analysis unavailable.',
      keyStrengths: parsed.keyStrengths || [],
      signalHighlights: parsed.signalHighlights || []
    };
  } catch {
    return {
      summary: 'Match analysis unavailable.',
      keyStrengths: [],
      signalHighlights: []
    };
  }
}
```

Key design decisions:
- Temperature 0.7 for creative but coherent output
- Max 300 tokens to keep rationale concise
- JSON response format for reliable parsing
- Graceful fallback on errors
- Truncate inputs to prevent context overflow
  </action>
  <verify>
- TypeScript compiles
- Method is callable (unit test or manual verification)
  </verify>
  <done>generateMatchRationale method added to Together client</done>
</task>

<task type="auto">
  <name>Task 3: Integrate rationale into search service</name>
  <files>services/hh-search-svc/src/search-service.ts</files>
  <action>
Integrate rationale generation into the search pipeline:

1. Add flag to search request (in types.ts if not already):
```typescript
// In HybridSearchRequest
includeMatchRationale?: boolean;
rationaleLimit?: number; // Default: 10
```

2. In search-service.ts, after reranking but before returning results:
```typescript
// Generate rationales for top candidates
if (request.includeMatchRationale) {
  const rationaleLimit = request.rationaleLimit ?? 10;
  const topCandidates = results.slice(0, rationaleLimit);

  // Generate rationales in parallel (batch for efficiency)
  const rationales = await Promise.all(
    topCandidates.map(async (candidate) => {
      // Check cache first
      const cacheKey = `rationale:${candidate.candidateId}:${request.jdHash ?? 'default'}`;
      const cached = await this.redis.get(cacheKey);
      if (cached) {
        return { candidateId: candidate.candidateId, rationale: JSON.parse(cached) };
      }

      // Generate new rationale
      const topSignals = this.getTopSignals(candidate.signalScores, 3);
      const summary = this.buildCandidateSummary(candidate);
      const rationale = await this.rerankClient.generateMatchRationale(
        request.jobDescription ?? request.query ?? '',
        summary,
        topSignals
      );

      // Cache for 24 hours
      await this.redis.set(cacheKey, JSON.stringify(rationale), 'EX', 86400);

      return { candidateId: candidate.candidateId, rationale };
    })
  );

  // Merge rationales into results
  const rationaleMap = new Map(rationales.map(r => [r.candidateId, r.rationale]));
  results = results.map(r => ({
    ...r,
    matchRationale: rationaleMap.get(r.candidateId)
  }));
}
```

3. Add helper methods:
```typescript
private getTopSignals(
  scores: SignalScores | undefined,
  limit: number
): Array<{ name: string; score: number }> {
  if (!scores) return [];

  const signalNames: Record<string, string> = {
    skillsExactMatch: 'Skills Match',
    trajectoryFit: 'Career Trajectory',
    seniorityAlignment: 'Seniority Fit',
    recencyBoost: 'Skill Recency',
    companyRelevance: 'Company Fit',
    vectorSimilarity: 'Semantic Match',
    levelMatch: 'Level Match',
    specialtyMatch: 'Specialty Match',
    techStackMatch: 'Tech Stack',
    functionMatch: 'Function Fit',
    companyPedigree: 'Company Quality'
  };

  return Object.entries(scores)
    .filter(([_, score]) => typeof score === 'number')
    .sort(([, a], [, b]) => (b as number) - (a as number))
    .slice(0, limit)
    .map(([key, score]) => ({
      name: signalNames[key] || key,
      score: score as number
    }));
}

private buildCandidateSummary(candidate: HybridSearchResultItem): string {
  const parts = [
    candidate.fullName,
    candidate.title,
    candidate.yearsExperience ? `${candidate.yearsExperience} years exp` : null,
    candidate.skills?.slice(0, 5).map(s => s.name).join(', ')
  ].filter(Boolean);

  return parts.join(' | ');
}
```
  </action>
  <verify>
- TypeScript compiles
- Search with includeMatchRationale=true returns rationales for top 10
- Second search uses cached rationales (check logs)
- **Redis cache validation:** After second identical search, verify Redis has cached rationale keys:
  ```bash
  # Connect to Redis and check for cached rationale keys
  redis-cli KEYS "rationale:*" | head -10
  # Should show keys like: rationale:{candidateId}:{jdHash}
  ```
- Verify TTL is set correctly (24h = 86400 seconds):
  ```bash
  redis-cli TTL "rationale:{sample-key}"
  # Should return value between 0 and 86400
  ```
  </verify>
  <done>Match rationale integrated into search results with Redis caching (verified)</done>
</task>

</tasks>

<verification>
1. Run `npm run build` in services/hh-rerank-svc and services/hh-search-svc - both compile
2. Unit test generateMatchRationale with mock Together AI response
3. Integration test: Search with includeMatchRationale=true
   - Top 10 results have matchRationale field
   - Rationale has summary, keyStrengths, signalHighlights
4. Cache verification: Same search returns cached rationales (check Redis)
5. Performance: Rationale generation adds <150ms (Together AI single pass)
</verification>

<success_criteria>
1. TRNS-03: LLM-generated match rationale for top candidates
2. Top 10 candidates receive rationales (configurable limit)
3. Rationales cached in Redis with 24h TTL
4. Graceful fallback on LLM errors
5. TypeScript compilation passes in both services
</success_criteria>

<output>
After completion, create `.planning/phases/09-match-transparency/09-05-SUMMARY.md`
</output>
