---
phase: 09-match-transparency
plan: 04
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - headhunter-ui/src/components/Search/SearchResults.tsx
  - headhunter-ui/src/components/Search/SearchResults.css
autonomous: true

must_haves:
  truths:
    - "Recruiters can sort results by overall score, skills, trajectory, or recency"
    - "Filter slider allows filtering by minimum skill score threshold"
    - "Sort/filter preferences persist in localStorage"
  artifacts:
    - path: "headhunter-ui/src/components/Search/SearchResults.tsx"
      provides: "Sort dropdown and filter controls"
      contains: "sortBy"
  key_links:
    - from: "headhunter-ui/src/components/Search/SearchResults.tsx"
      to: "SignalScores"
      via: "sorting logic"
      pattern: "signalScores.*skillsExactMatch"
---

<objective>
Add sort and filter controls to SearchResults component so recruiters can sort by individual signal scores and filter by minimum thresholds.

Purpose: TRNS-02 success criterion #5: "Recruiters can sort/filter by individual signal scores."

Output: SearchResults component with sort dropdown (Best Match, Skills, Trajectory, Recency) and filter slider (minimum skill score), with localStorage persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase research with sort/filter UI patterns
@.planning/phases/09-match-transparency/09-RESEARCH.md

# Plan 01 summary for types
@.planning/phases/09-match-transparency/09-01-SUMMARY.md

# Existing SearchResults to enhance
@headhunter-ui/src/components/Search/SearchResults.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sort and filter state management</name>
  <files>headhunter-ui/src/components/Search/SearchResults.tsx</files>
  <action>
Add state and logic for sorting and filtering search results:

1. Import SignalScores type and add new state variables:
```typescript
import { SignalScores } from '../../types';

// Sort options type
type SortOption = 'overall' | 'skills' | 'trajectory' | 'recency' | 'seniority';

// Inside component, add state
const [sortBy, setSortBy] = useState<SortOption>(() => {
  // Load from localStorage or default to 'overall'
  const saved = localStorage.getItem('hh_search_sortBy');
  return (saved as SortOption) || 'overall';
});

const [minSkillScore, setMinSkillScore] = useState<number>(() => {
  const saved = localStorage.getItem('hh_search_minSkillScore');
  return saved ? parseInt(saved, 10) : 0;
});
```

2. Add useEffect to persist preferences:
```typescript
useEffect(() => {
  localStorage.setItem('hh_search_sortBy', sortBy);
}, [sortBy]);

useEffect(() => {
  localStorage.setItem('hh_search_minSkillScore', minSkillScore.toString());
}, [minSkillScore]);
```

3. Add sorting and filtering logic:
```typescript
const getSortedAndFilteredMatches = () => {
  if (!matches) return [];

  // Filter by minimum skill score
  let filtered = matches.filter(m => {
    const skillScore = m.candidate?.signalScores?.skillsExactMatch ??
                       m.signalScores?.skillsExactMatch ??
                       0.5; // neutral if missing
    return skillScore * 100 >= minSkillScore;
  });

  // Sort based on selection
  return filtered.sort((a, b) => {
    const getSignalScore = (match: CandidateMatch, signal: keyof SignalScores) => {
      return match.candidate?.signalScores?.[signal] ??
             (match as any).signalScores?.[signal] ??
             0.5;
    };

    switch (sortBy) {
      case 'skills':
        return getSignalScore(b, 'skillsExactMatch') - getSignalScore(a, 'skillsExactMatch');
      case 'trajectory':
        return getSignalScore(b, 'trajectoryFit') - getSignalScore(a, 'trajectoryFit');
      case 'recency':
        return getSignalScore(b, 'recencyBoost') - getSignalScore(a, 'recencyBoost');
      case 'seniority':
        return getSignalScore(b, 'seniorityAlignment') - getSignalScore(a, 'seniorityAlignment');
      case 'overall':
      default:
        return (b.score ?? 0) - (a.score ?? 0);
    }
  });
};

// Use in rendering
const displayedMatches = getSortedAndFilteredMatches().slice(0, displayLimit);
```
  </action>
  <verify>
- State variables initialize from localStorage
- Sorting changes result order
- Filtering removes candidates below threshold
  </verify>
  <done>Sort and filter state management implemented with localStorage persistence</done>
</task>

<task type="auto">
  <name>Task 2: Add sort/filter UI controls</name>
  <files>headhunter-ui/src/components/Search/SearchResults.tsx</files>
  <action>
Add UI controls in the results header section (around lines 93-115):

```tsx
{/* Sort and Filter Controls - add after results-summary */}
<div className="results-controls">
  <div className="sort-control">
    <label htmlFor="sort-select">Sort by:</label>
    <select
      id="sort-select"
      value={sortBy}
      onChange={(e) => setSortBy(e.target.value as SortOption)}
      className="sort-select"
    >
      <option value="overall">Best Match</option>
      <option value="skills">Skills Match</option>
      <option value="trajectory">Career Trajectory</option>
      <option value="recency">Skill Recency</option>
      <option value="seniority">Seniority Fit</option>
    </select>
  </div>

  <div className="filter-control">
    <label htmlFor="skill-filter">
      Min Skill Score: {minSkillScore}%
    </label>
    <input
      id="skill-filter"
      type="range"
      min="0"
      max="100"
      step="10"
      value={minSkillScore}
      onChange={(e) => setMinSkillScore(parseInt(e.target.value, 10))}
      className="filter-slider"
    />
  </div>

  {minSkillScore > 0 && (
    <button
      className="clear-filters"
      onClick={() => setMinSkillScore(0)}
    >
      Clear filter
    </button>
  )}
</div>
```

Place this inside the `results-header` div, after the `results-summary` div.
  </action>
  <verify>
- Sort dropdown renders with 5 options
- Slider shows current value (0-100)
- Clear filter button appears when filter active
  </verify>
  <done>Sort dropdown and filter slider UI rendered in results header</done>
</task>

<task type="auto">
  <name>Task 3: Style sort/filter controls</name>
  <files>headhunter-ui/src/components/Search/SearchResults.css</files>
  <action>
Add CSS for the sort and filter controls. If SearchResults.css doesn't exist, add styles to the component or create the file.

```css
/* Sort and Filter Controls */
.results-controls {
  display: flex;
  align-items: center;
  gap: 24px;
  padding: 12px 0;
  margin-bottom: 16px;
  border-bottom: 1px solid #e0e0e0;
  flex-wrap: wrap;
}

.sort-control,
.filter-control {
  display: flex;
  align-items: center;
  gap: 8px;
}

.sort-control label,
.filter-control label {
  font-size: 14px;
  font-weight: 500;
  color: #616161;
  white-space: nowrap;
}

.sort-select {
  padding: 8px 32px 8px 12px;
  font-size: 14px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  background: white;
  cursor: pointer;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 12px center;
}

.sort-select:hover {
  border-color: #bdbdbd;
}

.sort-select:focus {
  outline: none;
  border-color: #1976d2;
  box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
}

.filter-slider {
  width: 120px;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: #e0e0e0;
  border-radius: 2px;
  cursor: pointer;
}

.filter-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  background: #1976d2;
  border-radius: 50%;
  cursor: pointer;
  transition: transform 0.1s ease;
}

.filter-slider::-webkit-slider-thumb:hover {
  transform: scale(1.2);
}

.filter-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: #1976d2;
  border-radius: 50%;
  cursor: pointer;
  border: none;
}

.clear-filters {
  padding: 6px 12px;
  font-size: 12px;
  color: #1976d2;
  background: transparent;
  border: 1px solid #1976d2;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.clear-filters:hover {
  background: #e3f2fd;
}

/* Responsive: stack controls on small screens */
@media (max-width: 600px) {
  .results-controls {
    flex-direction: column;
    align-items: flex-start;
  }
}
```
  </action>
  <verify>
- Controls styled consistently with existing UI
- Dropdown has custom arrow
- Slider thumb is visible and interactive
- Responsive stacking on mobile
  </verify>
  <done>Sort/filter controls styled with consistent design</done>
</task>

</tasks>

<verification>
1. Run `npm run build` in headhunter-ui - should complete without errors
2. Sort dropdown shows 5 options: Best Match, Skills Match, Career Trajectory, Skill Recency, Seniority Fit
3. Changing sort option reorders results (verify with mock data)
4. Slider filters out candidates below threshold
5. Clear filter button resets threshold to 0
6. Reload page - sort/filter settings persist from localStorage
7. Controls display correctly on mobile (stacked layout)
</verification>

<success_criteria>
1. TRNS-02 criterion #5: Recruiters can sort/filter by individual signal scores
2. Sort by 5 options: overall, skills, trajectory, recency, seniority
3. Filter by minimum skill score (0-100%)
4. Preferences persist in localStorage
5. TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/09-match-transparency/09-04-SUMMARY.md`
</output>
