---
phase: 02-search-recall-foundation
plan: 05
type: execute
wave: 3
depends_on:
  - 02-04
files_modified:
  - functions/src/engines/legacy-engine.ts
autonomous: false

must_haves:
  truths:
    - "All _*_score fields contribute to retrieval_score"
    - "Stage logging shows candidate count at each stage"
    - "Search returns 50+ candidates for typical queries"
    - "Missing data candidates appear in results with neutral scores"
  artifacts:
    - path: "functions/src/engines/legacy-engine.ts"
      provides: "Integrated scoring and stage logging"
      contains: "retrieval_score"
  key_links:
    - from: "all _*_score fields"
      to: "retrieval_score"
      via: "score aggregation"
      pattern: "retrieval_score.*_level_score.*_specialty_score"
---

<objective>
Integrate all scoring signals into final retrieval score and add stage logging for validation.

Purpose: The individual scoring conversions (Plans 02-04) added _*_score fields. This plan integrates them into the final retrieval_score calculation and adds logging to validate the full pipeline.

Output: Complete scoring integration with stage-by-stage logging.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-search-recall-foundation/02-RESEARCH.md
@functions/src/engines/legacy-engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Aggregate all scoring signals into retrieval_score</name>
  <files>functions/src/engines/legacy-engine.ts</files>
  <action>
Find the section where `retrieval_score` is calculated (around line 440-452):
```typescript
let candidates = Array.from(candidateScores.values()).map(entry => ({
    ...entry.candidate,
    retrieval_score: entry.functionScore + entry.vectorScore + entry.companyScore + entry.levelScore + entry.specialtyScore,
    ...
}));
```

Update to include all Phase 2 scoring signals:
```typescript
let candidates = Array.from(candidateScores.values()).map(entry => {
    const candidate = entry.candidate;

    // PHASE 2: Aggregate all scoring signals
    // Pre-computed Phase 2 scores (0-1 range) - multiply by appropriate weights
    const phase2LevelScore = candidate._level_score ?? 1.0;
    const phase2SpecialtyScore = candidate._specialty_score ?? 1.0;
    const phase2TechStackScore = candidate._tech_stack_score ?? 0.5; // Neutral if not computed
    const phase2FunctionTitleScore = candidate._function_title_score ?? 1.0;
    const phase2TrajectoryScore = candidate._trajectory_score ?? 1.0;

    // Combine Phase 2 scores as a multiplier (average of all signals)
    // This allows low scores to demote without fully excluding
    const phase2Multiplier = (
        phase2LevelScore +
        phase2SpecialtyScore +
        phase2TechStackScore +
        phase2FunctionTitleScore +
        phase2TrajectoryScore
    ) / 5;

    // Base score from existing calculation
    const baseScore = entry.functionScore + entry.vectorScore + entry.companyScore + entry.levelScore + entry.specialtyScore;

    // Final retrieval score: base score scaled by Phase 2 multiplier
    const retrievalScore = baseScore * Math.max(0.3, phase2Multiplier); // Floor at 0.3 to never fully exclude

    return {
        ...candidate,
        retrieval_score: retrievalScore,
        score_breakdown: {
            ...entry.candidate.score_breakdown,
            function: entry.functionScore,
            vector: entry.vectorScore,
            company: entry.companyScore,
            level: entry.levelScore,
            specialty: entry.specialtyScore,
            // Phase 2 signals
            phase2_level: phase2LevelScore,
            phase2_specialty: phase2SpecialtyScore,
            phase2_tech_stack: phase2TechStackScore,
            phase2_function_title: phase2FunctionTitleScore,
            phase2_trajectory: phase2TrajectoryScore,
            phase2_multiplier: phase2Multiplier
        },
        sources: entry.sources,
        search_mode: searchMode
    };
});
```
  </action>
  <verify>
- `grep -n "phase2_multiplier" functions/src/engines/legacy-engine.ts` shows the multiplier
- `grep -n "phase2Multiplier" functions/src/engines/legacy-engine.ts` shows the calculation
  </verify>
  <done>
All Phase 2 scoring signals now contribute to retrieval_score via multiplier.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add stage logging for pipeline validation</name>
  <files>functions/src/engines/legacy-engine.ts</files>
  <action>
Add comprehensive stage logging at key points in the search method:

1. After vector pool is loaded (before any scoring):
```typescript
console.log(`[LegacyEngine] STAGE 1 - Vector retrieval: ${vectorPool.length} candidates`);
```

2. After function pool is loaded:
```typescript
console.log(`[LegacyEngine] STAGE 1 - Function retrieval: ${functionPool.length} candidates`);
```

3. After scoring is applied (before sorting):
```typescript
console.log(`[LegacyEngine] STAGE 2 - Scoring complete: ${candidates.length} candidates scored`);
// Log score distribution for validation
const scoreDistribution = {
    high: candidates.filter((c: any) => c.retrieval_score > 70).length,
    medium: candidates.filter((c: any) => c.retrieval_score > 40 && c.retrieval_score <= 70).length,
    low: candidates.filter((c: any) => c.retrieval_score <= 40).length
};
console.log(`[LegacyEngine] Score distribution: high=${scoreDistribution.high}, medium=${scoreDistribution.medium}, low=${scoreDistribution.low}`);
```

4. Before sending to Gemini reranking:
```typescript
console.log(`[LegacyEngine] STAGE 3 - Sending to Gemini: ${topCandidates.length} candidates for reranking`);
```

5. After Gemini reranking:
```typescript
console.log(`[LegacyEngine] STAGE 4 - Gemini reranked: ${rankings?.length || 0} candidates`);
```

6. Final results:
```typescript
console.log(`[LegacyEngine] STAGE 5 - Final results: ${matches.length} candidates returned`);
```
  </action>
  <verify>
- `grep -n "STAGE" functions/src/engines/legacy-engine.ts | wc -l` returns 6 (one per stage)
  </verify>
  <done>
Pipeline now logs candidate count at each stage for validation.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2 implementation:
1. Lowered similarity thresholds to 0.25 (Plan 01)
2. Converted level filter to scoring (Plan 02)
3. Converted specialty filter to scoring (Plan 03)
4. Converted remaining filters to scoring (Plan 04)
5. Integrated all scores and added stage logging (Plan 05)
  </what-built>
  <how-to-verify>
1. Deploy the changes to Cloud Run or test locally
2. Run a search query like "Senior Backend Engineer"
3. Check the logs for stage output:
   - STAGE 1 should show 500+ candidates from vector retrieval
   - STAGE 2 should show all candidates scored (no filtering)
   - STAGE 3 should show 100 sent to Gemini
   - STAGE 5 should show 50+ final results
4. Verify the UI shows 50+ results (not ~10)
5. Verify candidates with missing data appear (with neutral scores)

Expected log pattern:
```
[LegacyEngine] STAGE 1 - Vector retrieval: 600+ candidates
[LegacyEngine] STAGE 2 - Scoring complete: 600+ candidates scored
[LegacyEngine] Score distribution: high=X, medium=Y, low=Z
[LegacyEngine] STAGE 3 - Sending to Gemini: 100 candidates
[LegacyEngine] STAGE 4 - Gemini reranked: 100 candidates
[LegacyEngine] STAGE 5 - Final results: 50+ candidates
```
  </how-to-verify>
  <resume-signal>Type "approved" if search returns 50+ candidates, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. All Phase 2 scores (_*_score fields) are used in retrieval_score
3. Stage logging shows candidate count at each step
4. Search returns 50+ candidates for typical queries
5. No hard filters remain (all are scoring signals)
</verification>

<success_criteria>
1. Search for "Senior Backend Engineer" returns 50+ candidates
2. Logs show 500+ candidates at Stage 1, all flowing through to Stage 2
3. Candidates with missing specialty/level data appear in results
4. Score breakdown includes phase2_* fields
5. Phase 2 requirements SRCL-01 through SRCL-04 are met
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-recall-foundation/02-05-SUMMARY.md`
</output>
