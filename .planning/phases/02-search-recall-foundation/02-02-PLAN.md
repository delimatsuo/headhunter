---
phase: 02-search-recall-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - functions/src/engines/legacy-engine.ts
autonomous: true

must_haves:
  truths:
    - "Level filter converts from .filter() to scoring with _level_score field"
    - "Candidates with unknown level get 0.5 score (neutral)"
    - "Candidates outside level range get 0.3 score (low but not excluded)"
    - "Candidates in level range get 1.0 score"
  artifacts:
    - path: "functions/src/engines/legacy-engine.ts"
      provides: "Level scoring instead of filtering"
      contains: "_level_score"
  key_links:
    - from: "functions/src/engines/legacy-engine.ts level scoring"
      to: "retrieval_score calculation"
      via: "_level_score included in score"
      pattern: "_level_score"
---

<objective>
Convert the hard level range filter to soft scoring signal in legacy-engine.ts.

Purpose: The current level filter (lines 167-173) excludes candidates outside the target level range. This is the first major filter causing candidate loss. Converting to scoring allows 40-60% more candidates to reach reranking.

Output: Level range check returns a score (0.3-1.0) instead of filtering out candidates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-search-recall-foundation/02-RESEARCH.md
@functions/src/engines/legacy-engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert level filter to scoring</name>
  <files>functions/src/engines/legacy-engine.ts</files>
  <action>
Find the IC mode level filtering section (around lines 167-173):
```typescript
vectorPool = vectorPool.filter((c: any) => {
    const effectiveLevel = this.getEffectiveLevel(c);
    if (effectiveLevel === 'unknown') return true;
    return levelRange.includes(effectiveLevel);
});
```

Replace with scoring logic that adds `_level_score` to each candidate:
```typescript
// PHASE 2 FIX: Convert level filter to scoring signal
// Instead of excluding candidates, score them:
// - In range: 1.0 (best)
// - Unknown: 0.5 (neutral - let Gemini decide)
// - Out of range: 0.3 (still included, lower priority)
vectorPool = vectorPool.map((c: any) => {
    const effectiveLevel = this.getEffectiveLevel(c);
    let levelScore: number;

    if (effectiveLevel === 'unknown') {
        levelScore = 0.5; // Neutral for unknown
    } else if (levelRange.includes(effectiveLevel)) {
        levelScore = 1.0; // Full score for in-range
    } else {
        levelScore = 0.3; // Low score but not excluded
    }

    return { ...c, _level_score: levelScore };
});
console.log(`[LegacyEngine] Level scoring applied to ${vectorPool.length} candidates (not filtered)`);
```

This preserves all candidates but marks them with a level score for later use.
  </action>
  <verify>
- `grep -n "_level_score" functions/src/engines/legacy-engine.ts` shows the new scoring field
- `grep -n "Level scoring applied" functions/src/engines/legacy-engine.ts` shows the new log line
  </verify>
  <done>
Level range check is now a scoring signal, not a filter. All candidates pass through with _level_score attached.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update function pool level filter to scoring</name>
  <files>functions/src/engines/legacy-engine.ts</files>
  <action>
In the `searchByFunction` method (around line 933-939), there's another level filter:
```typescript
let candidates = legacySnapshot.docs
    .map(doc => ({ id: doc.id, ...doc.data() } as any))
    .filter((c: any) => {
        const effectiveLevel = this.getEffectiveLevel(c);
        return levelRange.includes(effectiveLevel);
    })
```

Replace the filter with map to add scoring:
```typescript
let candidates = legacySnapshot.docs
    .map(doc => ({ id: doc.id, ...doc.data() } as any))
    .map((c: any) => {
        // PHASE 2 FIX: Score instead of filter
        const effectiveLevel = this.getEffectiveLevel(c);
        let levelScore: number;

        if (effectiveLevel === 'unknown') {
            levelScore = 0.5;
        } else if (levelRange.includes(effectiveLevel)) {
            levelScore = 1.0;
        } else {
            levelScore = 0.3;
        }

        return { ...c, _level_score: levelScore };
    })
```

Update the console.log that follows to reflect scoring instead of filtering:
```typescript
console.log(`[LegacyEngine] Function query: ${legacySnapshot.size} total, ${candidates.length} scored (level range: ${levelRange.join(', ')}) for ${targetFunction}`);
```
  </action>
  <verify>
- `grep -n "_level_score" functions/src/engines/legacy-engine.ts` returns multiple occurrences (vector pool and function pool)
  </verify>
  <done>
Both vector pool and function pool use level scoring instead of filtering.
  </done>
</task>

<task type="auto">
  <name>Task 3: Incorporate _level_score into retrieval scoring</name>
  <files>functions/src/engines/legacy-engine.ts</files>
  <action>
In the scoring section where `candidateScores` map is built (around lines 360-436), the `levelScore` calculation already exists but uses `calculateLevelScore`.

Update the vector pool scoring loop to use the pre-computed `_level_score` if available:
```typescript
// In the vector pool scoring loop (around line 424-428):
if (entry.levelScore === 0) {
    // Use pre-computed _level_score from Phase 2 fix if available
    const precomputedLevelScore = candidate._level_score;
    if (precomputedLevelScore !== undefined) {
        entry.levelScore = precomputedLevelScore * weights.level;
    } else {
        const rawLevelScore = this.calculateLevelScore(
            candidate.searchable?.level || candidate.profile?.current_level || 'mid',
            targetClassification.level,
            candidate
        );
        entry.levelScore = (rawLevelScore / 40) * weights.level;
    }
}
```

Do the same for the function pool scoring loop (around line 384-389).
  </action>
  <verify>
- `grep -n "precomputedLevelScore" functions/src/engines/legacy-engine.ts` shows the new variable usage
- TypeScript compiles: `cd /Volumes/Extreme\ Pro/myprojects/headhunter && npm run typecheck --prefix functions`
  </verify>
  <done>
_level_score from Phase 2 filtering is now integrated into the retrieval score calculation.
  </done>
</task>

</tasks>

<verification>
1. Level filter at line ~167 is now a `.map()` not `.filter()`
2. Level filter in searchByFunction is now a `.map()` not `.filter()`
3. _level_score field is used in scoring calculation
4. TypeScript compiles without errors
5. No `.filter()` calls remain that exclude based on level range
</verification>

<success_criteria>
1. All candidates pass through level checks (no exclusion)
2. _level_score is attached to each candidate (0.3-1.0)
3. Level scoring integrated into retrieval_score
4. Log messages updated to reflect scoring not filtering
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-recall-foundation/02-02-SUMMARY.md`
</output>
