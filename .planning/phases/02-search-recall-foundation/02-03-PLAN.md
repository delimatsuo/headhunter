---
phase: 02-search-recall-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - functions/src/engines/legacy-engine.ts
autonomous: true

must_haves:
  truths:
    - "Specialty filter converts from .filter() to scoring with _specialty_score field"
    - "Candidates with no specialty data get 0.5 score (neutral)"
    - "Pure frontend/backend mismatches get 0.2 score (very low but not excluded)"
    - "Fullstack candidates matching backend/frontend get 0.8 score"
  artifacts:
    - path: "functions/src/engines/legacy-engine.ts"
      provides: "Specialty scoring instead of filtering"
      contains: "_specialty_score"
  key_links:
    - from: "functions/src/engines/legacy-engine.ts specialty scoring"
      to: "calculateSpecialtyScore method"
      via: "score calculation"
      pattern: "calculateSpecialtyScore"
---

<objective>
Convert the hard specialty filter to soft scoring signal in legacy-engine.ts.

Purpose: The current specialty filter (lines 184-242) excludes pure frontend from backend searches and vice versa. This removes 30-50% of candidates. Converting to scoring allows Gemini to evaluate edge cases like fullstack developers.

Output: Specialty matching returns a score (0.2-1.0) instead of filtering out candidates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-search-recall-foundation/02-RESEARCH.md
@functions/src/engines/legacy-engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert vector pool specialty filter to scoring</name>
  <files>functions/src/engines/legacy-engine.ts</files>
  <action>
Find the vector pool specialty filtering section (around lines 178-244):
```typescript
if (targetSpecialties.length > 0 && targetClassification.function === 'engineering') {
    const vectorBeforeSpecialty = vectorPool.length;
    const pgSpecialties = await this.loadSpecialtiesFromPg(vectorPool);

    vectorPool = vectorPool.filter((c: any) => {
        // ... specialty matching and exclusion logic
    });
}
```

Replace with scoring logic:
```typescript
if (targetSpecialties.length > 0 && targetClassification.function === 'engineering') {
    const vectorBeforeSpecialty = vectorPool.length;
    const pgSpecialties = await this.loadSpecialtiesFromPg(vectorPool);

    // PHASE 2 FIX: Convert specialty filter to scoring
    // Instead of excluding, assign scores:
    // - Match: 1.0
    // - Fullstack for backend/frontend: 0.8
    // - No data: 0.5 (neutral)
    // - Clear mismatch: 0.2 (very low but Gemini can evaluate)
    vectorPool = vectorPool.map((c: any) => {
        const candidateId = c.candidate_id || c.id || '';
        const candidateSpecialties = this.getCandidateSpecialty(c, pgSpecialties);

        // No specialty data - neutral score
        if (candidateSpecialties.length === 0) {
            return { ...c, _specialty_score: 0.5 };
        }

        // Check for specialty match
        for (const target of targetSpecialties) {
            if (candidateSpecialties.includes(target)) {
                return { ...c, _specialty_score: 1.0 }; // Direct match
            }
            // Fullstack matches both backend and frontend
            if ((target === 'backend' || target === 'frontend') &&
                (candidateSpecialties.includes('fullstack') ||
                 candidateSpecialties.includes('full-stack') ||
                 candidateSpecialties.includes('full stack'))) {
                return { ...c, _specialty_score: 0.8 }; // Good match
            }
        }

        // Mismatch detection (score low but don't exclude)
        let mismatchScore = 0.4; // Default for unclear cases

        if (targetSpecialties.includes('backend')) {
            const isPureFrontend = candidateSpecialties.includes('frontend') &&
                !candidateSpecialties.includes('backend') &&
                !candidateSpecialties.includes('fullstack') &&
                !candidateSpecialties.includes('full-stack');
            if (isPureFrontend) mismatchScore = 0.2;

            const wrongSpecialtiesForBackend = ['mobile', 'qa', 'data', 'devops', 'sre'];
            const hasWrongSpecialty = wrongSpecialtiesForBackend.some(wrong =>
                candidateSpecialties.includes(wrong) &&
                !candidateSpecialties.includes('backend') &&
                !candidateSpecialties.includes('fullstack') &&
                !candidateSpecialties.includes('full-stack')
            );
            if (hasWrongSpecialty) mismatchScore = 0.2;
        }

        if (targetSpecialties.includes('frontend')) {
            const isPureBackend = candidateSpecialties.includes('backend') &&
                !candidateSpecialties.includes('frontend') &&
                !candidateSpecialties.includes('fullstack') &&
                !candidateSpecialties.includes('full-stack');
            if (isPureBackend) mismatchScore = 0.2;

            const wrongSpecialtiesForFrontend = ['mobile', 'qa', 'data', 'devops', 'sre'];
            const hasWrongSpecialtyFE = wrongSpecialtiesForFrontend.some(wrong =>
                candidateSpecialties.includes(wrong) &&
                !candidateSpecialties.includes('frontend') &&
                !candidateSpecialties.includes('fullstack') &&
                !candidateSpecialties.includes('full-stack')
            );
            if (hasWrongSpecialtyFE) mismatchScore = 0.2;
        }

        return { ...c, _specialty_score: mismatchScore };
    });

    console.log(`[LegacyEngine] Specialty scoring applied to ${vectorPool.length} candidates (not filtered)`);
}
```
  </action>
  <verify>
- `grep -n "_specialty_score" functions/src/engines/legacy-engine.ts` shows the new scoring field
- `grep -n "Specialty scoring applied" functions/src/engines/legacy-engine.ts` shows the new log
  </verify>
  <done>
Vector pool specialty filter is now a scoring signal. All candidates pass through with _specialty_score attached.
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert searchByFunction specialty filter to scoring</name>
  <files>functions/src/engines/legacy-engine.ts</files>
  <action>
Find the specialty filtering in `searchByFunction` method (around lines 965-1033):
```typescript
if (targetSpecialties.length > 0 && targetFunction === 'engineering') {
    const beforeFilter = candidates.length;
    const pgSpecialties = await this.loadSpecialtiesFromPg(candidates);

    candidates = candidates.filter((c: any) => {
        // ... specialty matching and exclusion logic
    });
}
```

Replace with the same scoring pattern as Task 1:
```typescript
if (targetSpecialties.length > 0 && targetFunction === 'engineering') {
    const beforeFilter = candidates.length;
    const pgSpecialties = await this.loadSpecialtiesFromPg(candidates);

    // PHASE 2 FIX: Score instead of filter (same logic as vector pool)
    candidates = candidates.map((c: any) => {
        const candidateId = c.id || '';
        const candidateSpecialties = this.getCandidateSpecialty(c, pgSpecialties);

        if (candidateSpecialties.length === 0) {
            return { ...c, _specialty_score: 0.5 };
        }

        for (const target of targetSpecialties) {
            if (candidateSpecialties.includes(target)) {
                return { ...c, _specialty_score: 1.0 };
            }
            if ((target === 'backend' || target === 'frontend') &&
                (candidateSpecialties.includes('fullstack') ||
                 candidateSpecialties.includes('full-stack') ||
                 candidateSpecialties.includes('full stack'))) {
                return { ...c, _specialty_score: 0.8 };
            }
        }

        // Mismatch scoring
        let mismatchScore = 0.4;
        if (targetSpecialties.includes('backend')) {
            const isPureFrontend = candidateSpecialties.includes('frontend') &&
                !candidateSpecialties.includes('backend') &&
                !candidateSpecialties.includes('fullstack') &&
                !candidateSpecialties.includes('full-stack');
            if (isPureFrontend) mismatchScore = 0.2;

            const wrongForBackend = ['mobile', 'qa', 'data', 'devops', 'sre'];
            if (wrongForBackend.some(w => candidateSpecialties.includes(w) &&
                !candidateSpecialties.includes('backend') &&
                !candidateSpecialties.includes('fullstack'))) {
                mismatchScore = 0.2;
            }
        }
        if (targetSpecialties.includes('frontend')) {
            const isPureBackend = candidateSpecialties.includes('backend') &&
                !candidateSpecialties.includes('frontend') &&
                !candidateSpecialties.includes('fullstack') &&
                !candidateSpecialties.includes('full-stack');
            if (isPureBackend) mismatchScore = 0.2;

            const wrongForFrontend = ['mobile', 'qa', 'data', 'devops', 'sre'];
            if (wrongForFrontend.some(w => candidateSpecialties.includes(w) &&
                !candidateSpecialties.includes('frontend') &&
                !candidateSpecialties.includes('fullstack'))) {
                mismatchScore = 0.2;
            }
        }

        return { ...c, _specialty_score: mismatchScore };
    });

    console.log(`[LegacyEngine] Function pool specialty scoring: ${beforeFilter} candidates scored (specialties: ${targetSpecialties.join(', ')})`);
}
```
  </action>
  <verify>
- `grep -c "_specialty_score" functions/src/engines/legacy-engine.ts` returns at least 10+ (multiple usages)
  </verify>
  <done>
Both vector pool and function pool use specialty scoring instead of filtering.
  </done>
</task>

<task type="auto">
  <name>Task 3: Incorporate _specialty_score into retrieval scoring</name>
  <files>functions/src/engines/legacy-engine.ts</files>
  <action>
In the scoring loops where `entry.specialtyScore` is calculated, update to use pre-computed `_specialty_score`:

For function pool scoring loop (around line 392):
```typescript
// Specialty match - using PostgreSQL data
const precomputedSpecialtyScore = candidate._specialty_score;
if (precomputedSpecialtyScore !== undefined) {
    entry.specialtyScore = precomputedSpecialtyScore * weights.specialty;
} else {
    const specialtyScore = this.calculateSpecialtyScore(candidate, targetSpecialties, allPgSpecialties);
    entry.specialtyScore = specialtyScore * weights.specialty;
}
```

For vector pool scoring loop (around line 431):
```typescript
// Specialty score for vector candidates too
if (entry.specialtyScore === 0) {
    const precomputedSpecialtyScore = candidate._specialty_score;
    if (precomputedSpecialtyScore !== undefined) {
        entry.specialtyScore = precomputedSpecialtyScore * weights.specialty;
    } else {
        const specialtyScore = this.calculateSpecialtyScore(candidate, targetSpecialties, allPgSpecialties);
        entry.specialtyScore = specialtyScore * weights.specialty;
    }
}
```
  </action>
  <verify>
- TypeScript compiles: `cd /Volumes/Extreme\ Pro/myprojects/headhunter && npm run typecheck --prefix functions`
  </verify>
  <done>
_specialty_score from Phase 2 is integrated into retrieval score calculation.
  </done>
</task>

</tasks>

<verification>
1. Specialty filter at line ~184 is now a `.map()` not `.filter()`
2. Specialty filter in searchByFunction is now a `.map()` not `.filter()`
3. _specialty_score field is used in scoring calculation
4. TypeScript compiles without errors
5. No `.filter()` calls remain that exclude based on specialty
</verification>

<success_criteria>
1. All candidates pass through specialty checks (no exclusion)
2. _specialty_score is attached to each candidate (0.2-1.0)
3. Fullstack developers get 0.8 score for backend/frontend searches
4. Pure mismatches get 0.2 (very low but still present for Gemini)
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-recall-foundation/02-03-SUMMARY.md`
</output>
