---
phase: 12-natural-language-search
plan: 06
type: execute
wave: 3
depends_on:
  - 12-05
files_modified:
  - services/hh-search-svc/src/index.ts
  - services/hh-search-svc/src/nlp/semantic-synonyms.ts
  - services/hh-search-svc/src/nlp/__tests__/semantic-synonyms.spec.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "QueryParser is initialized at service startup"
    - "Semantic synonyms expand 'Senior' to match 'Lead', 'Principal', 'Staff'"
    - "NLP integration end-to-end test passes with real embedding"
  artifacts:
    - path: "services/hh-search-svc/src/index.ts"
      provides: "QueryParser initialization at startup"
      contains: "queryParser.initialize"
    - path: "services/hh-search-svc/src/nlp/semantic-synonyms.ts"
      provides: "Seniority and role semantic expansion"
      exports: ["expandSemanticSynonyms", "SENIORITY_SYNONYMS"]
  key_links:
    - from: "services/hh-search-svc/src/index.ts"
      to: "services/hh-search-svc/src/nlp/query-parser.ts"
      via: "import QueryParser"
      pattern: "import.*QueryParser"
---

<objective>
Complete the NLP integration by wiring up QueryParser initialization at service startup and adding semantic synonym expansion for seniority levels.

Purpose: Ensure NLP is ready to use on first search request and that semantic queries like "Lead engineer" match "Senior", "Principal", "Staff" candidates.

Output: Service initialization with QueryParser warm-up, and semantic synonym expansion module.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-natural-language-search/12-RESEARCH.md

# Prior plan SUMMARYs
# (12-05 provides SearchService NLP integration)

# Files to modify
@services/hh-search-svc/src/index.ts
@services/hh-search-svc/src/nlp/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create semantic synonyms expansion module</name>
  <files>
    services/hh-search-svc/src/nlp/semantic-synonyms.ts
    services/hh-search-svc/src/nlp/__tests__/semantic-synonyms.spec.ts
  </files>
  <action>
1. Create semantic-synonyms.ts for seniority and role semantic expansion:

```typescript
/**
 * Semantic Synonyms Module
 *
 * Expands seniority levels and roles to include semantically similar terms.
 * This enables "Lead engineer" to match candidates with "Senior", "Principal", "Staff" titles.
 *
 * Based on NLNG-02: Semantic query understanding requirement.
 */

/**
 * Seniority level synonyms - maps canonical seniority to semantically equivalent terms.
 * Higher seniority levels include lower ones in some cases (e.g., "Lead" implies "Senior").
 */
export const SENIORITY_SYNONYMS: Record<string, string[]> = {
  // Entry-level equivalents
  'junior': ['entry', 'entry-level', 'associate', 'trainee', 'graduate', 'júnior'],

  // Mid-level equivalents
  'mid': ['mid-level', 'intermediate', 'experienced', 'pleno'],

  // Senior-level equivalents (common interchangeable titles)
  'senior': ['sr', 'sr.', 'experienced', 'sênior'],

  // Staff-level equivalents (includes senior)
  'staff': ['senior staff', 'staff+'],

  // Principal-level equivalents (includes staff and senior)
  'principal': ['distinguished', 'fellow', 'architect'],

  // Lead-level equivalents (leadership track, overlaps with senior/staff IC)
  'lead': ['tech lead', 'team lead', 'lead engineer', 'lead developer', 'senior', 'staff'],

  // Manager-level equivalents
  'manager': ['engineering manager', 'em', 'mgr', 'gerente'],

  // Director-level equivalents
  'director': ['dir', 'senior director', 'diretor'],

  // VP-level equivalents
  'vp': ['vice president', 'svp', 'evp'],

  // C-level equivalents
  'c-level': ['cto', 'ceo', 'cpo', 'coo', 'chief']
};

/**
 * Role synonyms - maps canonical roles to equivalent titles.
 */
export const ROLE_SYNONYMS: Record<string, string[]> = {
  'developer': ['engineer', 'programmer', 'coder', 'dev', 'desenvolvedor'],
  'engineer': ['developer', 'programmer', 'dev', 'engenheiro'],
  'designer': ['ux designer', 'ui designer', 'product designer', 'visual designer'],
  'manager': ['lead', 'head', 'director'],
  'analyst': ['specialist', 'consultant'],
  'architect': ['principal engineer', 'system architect', 'solutions architect'],
  'devops': ['sre', 'site reliability', 'platform engineer', 'infrastructure'],
  'data scientist': ['ml engineer', 'data engineer', 'ai engineer'],
  'product manager': ['pm', 'product owner', 'po']
};

/**
 * Semantic level groupings for "at least this level" matching.
 * Index indicates hierarchy (higher = more senior).
 */
export const SENIORITY_HIERARCHY = [
  'junior',
  'mid',
  'senior',
  'staff',
  'principal',
  'lead',
  'manager',
  'director',
  'vp',
  'c-level'
];

export interface SemanticExpansionResult {
  original: string;
  synonyms: string[];
  includesHigher: boolean;  // Whether higher seniority levels are included
}

/**
 * Expand a seniority term to include synonyms.
 *
 * @param seniority - Canonical seniority term (e.g., 'senior', 'lead')
 * @param includeHigherLevels - If true, include all seniority levels >= input
 * @returns Expansion result with synonyms
 */
export function expandSenioritySynonyms(
  seniority: string,
  includeHigherLevels = false
): SemanticExpansionResult {
  const normalized = seniority.toLowerCase().trim();

  // Get direct synonyms
  const directSynonyms = SENIORITY_SYNONYMS[normalized] ?? [];

  // Build result
  const synonyms = new Set<string>([normalized, ...directSynonyms]);

  // Optionally include higher levels
  if (includeHigherLevels) {
    const currentIndex = SENIORITY_HIERARCHY.indexOf(normalized);
    if (currentIndex !== -1) {
      for (let i = currentIndex + 1; i < SENIORITY_HIERARCHY.length; i++) {
        const higherLevel = SENIORITY_HIERARCHY[i];
        synonyms.add(higherLevel);
        // Add synonyms of higher levels too
        const higherSynonyms = SENIORITY_SYNONYMS[higherLevel] ?? [];
        for (const syn of higherSynonyms) {
          synonyms.add(syn);
        }
      }
    }
  }

  return {
    original: normalized,
    synonyms: Array.from(synonyms),
    includesHigher: includeHigherLevels
  };
}

/**
 * Expand a role term to include synonyms.
 *
 * @param role - Role term (e.g., 'developer', 'engineer')
 * @returns Expansion result with synonyms
 */
export function expandRoleSynonyms(role: string): SemanticExpansionResult {
  const normalized = role.toLowerCase().trim();

  const directSynonyms = ROLE_SYNONYMS[normalized] ?? [];

  return {
    original: normalized,
    synonyms: [normalized, ...directSynonyms],
    includesHigher: false
  };
}

/**
 * Expand all semantic synonyms in extracted entities.
 * Modifies the entities to include expanded seniority levels and roles.
 *
 * @param entities - Extracted entities from NLP parser
 * @returns Enhanced entities with semantic synonyms
 */
export function expandSemanticSynonyms(entities: {
  role?: string;
  seniority?: string;
  seniorityLevels?: string[];
}): {
  expandedRoles: string[];
  expandedSeniorities: string[];
} {
  const expandedRoles: string[] = [];
  const expandedSeniorities: string[] = [];

  // Expand role
  if (entities.role) {
    const roleExpansion = expandRoleSynonyms(entities.role);
    expandedRoles.push(...roleExpansion.synonyms);
  }

  // Expand seniority
  if (entities.seniority) {
    const seniorityExpansion = expandSenioritySynonyms(entities.seniority, true);
    expandedSeniorities.push(...seniorityExpansion.synonyms);
  }

  // Expand explicit seniority levels array
  if (entities.seniorityLevels) {
    for (const level of entities.seniorityLevels) {
      const expansion = expandSenioritySynonyms(level, false);
      for (const syn of expansion.synonyms) {
        if (!expandedSeniorities.includes(syn)) {
          expandedSeniorities.push(syn);
        }
      }
    }
  }

  return {
    expandedRoles,
    expandedSeniorities
  };
}

/**
 * Check if a candidate's level matches the target level semantically.
 *
 * @param candidateLevel - Candidate's seniority level
 * @param targetLevel - Target seniority level from query
 * @param allowHigher - Allow candidates with higher levels
 * @returns True if semantically matches
 */
export function matchesSeniorityLevel(
  candidateLevel: string,
  targetLevel: string,
  allowHigher = true
): boolean {
  const candidateNormalized = candidateLevel.toLowerCase().trim();
  const targetNormalized = targetLevel.toLowerCase().trim();

  // Direct match
  if (candidateNormalized === targetNormalized) {
    return true;
  }

  // Check synonyms
  const expansion = expandSenioritySynonyms(targetNormalized, allowHigher);
  return expansion.synonyms.some(syn => candidateNormalized.includes(syn));
}
```

2. Create semantic-synonyms.spec.ts tests:

```typescript
import { describe, it, expect } from 'vitest';
import {
  expandSenioritySynonyms,
  expandRoleSynonyms,
  expandSemanticSynonyms,
  matchesSeniorityLevel,
  SENIORITY_SYNONYMS,
  ROLE_SYNONYMS
} from '../semantic-synonyms';

describe('semantic-synonyms', () => {
  describe('expandSenioritySynonyms', () => {
    it('should return direct synonyms for senior', () => {
      const result = expandSenioritySynonyms('senior');

      expect(result.original).toBe('senior');
      expect(result.synonyms).toContain('senior');
      expect(result.synonyms).toContain('sr');
      expect(result.synonyms).toContain('sr.');
    });

    it('should include higher levels when requested', () => {
      const result = expandSenioritySynonyms('senior', true);

      expect(result.includesHigher).toBe(true);
      expect(result.synonyms).toContain('staff');
      expect(result.synonyms).toContain('principal');
      expect(result.synonyms).toContain('lead');
    });

    it('should handle lead level with its synonyms', () => {
      const result = expandSenioritySynonyms('lead');

      expect(result.synonyms).toContain('tech lead');
      expect(result.synonyms).toContain('team lead');
      expect(result.synonyms).toContain('senior');  // Lead implies senior
      expect(result.synonyms).toContain('staff');
    });

    it('should handle Portuguese terms', () => {
      const senior = expandSenioritySynonyms('senior');
      const junior = expandSenioritySynonyms('junior');

      expect(senior.synonyms).toContain('sênior');
      expect(junior.synonyms).toContain('júnior');
    });

    it('should handle unknown levels gracefully', () => {
      const result = expandSenioritySynonyms('unknown-level');

      expect(result.original).toBe('unknown-level');
      expect(result.synonyms).toContain('unknown-level');
    });
  });

  describe('expandRoleSynonyms', () => {
    it('should expand developer to include engineer', () => {
      const result = expandRoleSynonyms('developer');

      expect(result.synonyms).toContain('developer');
      expect(result.synonyms).toContain('engineer');
      expect(result.synonyms).toContain('programmer');
    });

    it('should expand engineer to include developer', () => {
      const result = expandRoleSynonyms('engineer');

      expect(result.synonyms).toContain('engineer');
      expect(result.synonyms).toContain('developer');
    });

    it('should handle Portuguese terms', () => {
      const result = expandRoleSynonyms('developer');

      expect(result.synonyms).toContain('desenvolvedor');
    });
  });

  describe('expandSemanticSynonyms', () => {
    it('should expand both role and seniority', () => {
      const result = expandSemanticSynonyms({
        role: 'developer',
        seniority: 'senior'
      });

      expect(result.expandedRoles).toContain('developer');
      expect(result.expandedRoles).toContain('engineer');
      expect(result.expandedSeniorities).toContain('senior');
      expect(result.expandedSeniorities).toContain('staff');  // Higher level
    });

    it('should handle missing fields', () => {
      const result = expandSemanticSynonyms({});

      expect(result.expandedRoles).toEqual([]);
      expect(result.expandedSeniorities).toEqual([]);
    });

    it('should expand seniorityLevels array', () => {
      const result = expandSemanticSynonyms({
        seniorityLevels: ['senior', 'lead']
      });

      expect(result.expandedSeniorities).toContain('senior');
      expect(result.expandedSeniorities).toContain('sr');
      expect(result.expandedSeniorities).toContain('lead');
      expect(result.expandedSeniorities).toContain('tech lead');
    });
  });

  describe('matchesSeniorityLevel', () => {
    it('should match exact level', () => {
      expect(matchesSeniorityLevel('senior', 'senior')).toBe(true);
    });

    it('should match synonym', () => {
      expect(matchesSeniorityLevel('sr', 'senior')).toBe(true);
      expect(matchesSeniorityLevel('Sr.', 'senior')).toBe(true);
    });

    it('should match higher level when allowed', () => {
      expect(matchesSeniorityLevel('staff', 'senior', true)).toBe(true);
      expect(matchesSeniorityLevel('principal', 'senior', true)).toBe(true);
    });

    it('should not match higher level when disallowed', () => {
      expect(matchesSeniorityLevel('staff', 'senior', false)).toBe(false);
    });

    it('should not match lower level', () => {
      expect(matchesSeniorityLevel('junior', 'senior', true)).toBe(false);
    });
  });
});
```
  </action>
  <verify>
Files compile and tests pass:
```bash
cd services/hh-search-svc && npm run typecheck
npm test -- src/nlp/__tests__/semantic-synonyms.spec.ts
```
  </verify>
  <done>
semantic-synonyms.ts provides seniority and role expansion with hierarchy support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire up QueryParser initialization at service startup</name>
  <files>
    services/hh-search-svc/src/index.ts
  </files>
  <action>
Update index.ts to initialize QueryParser at service startup.

1. Add imports:
```typescript
import { QueryParser } from './nlp';
import type { NLPConfig } from './nlp/types';
```

2. Add QueryParser creation and initialization in the startup sequence.

Find where the SearchService is instantiated and add QueryParser initialization:

```typescript
// Create QueryParser if NLP is enabled
let queryParser: QueryParser | undefined;
if (config.nlp.enabled) {
  const nlpConfig: NLPConfig = {
    enabled: config.nlp.enabled,
    intentConfidenceThreshold: config.nlp.intentConfidenceThreshold,
    extractionTimeoutMs: config.nlp.extractionTimeoutMs,
    cacheExtractionResults: config.nlp.cacheExtractionResults,
    enableQueryExpansion: config.nlp.enableQueryExpansion,
    expansionDepth: config.nlp.expansionDepth,
    expansionConfidenceThreshold: config.nlp.expansionConfidenceThreshold
  };

  queryParser = new QueryParser({
    generateEmbedding: async (text: string) => {
      // Use the same embed client that search uses
      const result = await embedClient.generateEmbedding({
        tenantId: 'system',
        requestId: `nlp-init-${Date.now()}`,
        query: text
      });
      return result.embedding;
    },
    logger,
    config: nlpConfig,
    togetherApiKey: process.env.TOGETHER_API_KEY
  });

  // Initialize in background to not block startup
  // But log if it fails
  queryParser.initialize().catch(error => {
    logger.error({ error }, 'Failed to initialize QueryParser - NLP features may be degraded');
  });
}
```

3. Pass queryParser to SearchService:
```typescript
const searchService = new SearchService({
  config,
  pgClient,
  embedClient,
  redisClient,
  rerankClient,
  performanceTracker,
  queryParser,  // Add this
  logger
});
```

4. Add health check for NLP:

In the /health endpoint response, include NLP status:
```typescript
nlp: {
  enabled: config.nlp.enabled,
  initialized: queryParser?.isInitialized() ?? false
}
```

5. Log NLP initialization status at startup:
```typescript
logger.info({
  nlpEnabled: config.nlp.enabled,
  nlpInitialized: queryParser?.isInitialized() ?? false,
  intentThreshold: config.nlp.intentConfidenceThreshold,
  extractionTimeout: config.nlp.extractionTimeoutMs
}, 'NLP configuration');
```
  </action>
  <verify>
Service starts with NLP initialized:
```bash
cd services/hh-search-svc && npm run typecheck
# If local testing is possible:
# npm run dev &
# curl localhost:7102/health | jq '.nlp'
```
  </verify>
  <done>
QueryParser is initialized at service startup with background initialization and health reporting.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update NLP barrel export and integrate semantic synonyms</name>
  <files>
    services/hh-search-svc/src/nlp/index.ts
    services/hh-search-svc/src/nlp/query-parser.ts
  </files>
  <action>
1. Update index.ts to export semantic synonyms:

Add to exports:
```typescript
// Semantic Synonyms
export {
  expandSenioritySynonyms,
  expandRoleSynonyms,
  expandSemanticSynonyms,
  matchesSeniorityLevel,
  SENIORITY_SYNONYMS,
  ROLE_SYNONYMS,
  SENIORITY_HIERARCHY,
  type SemanticExpansionResult
} from './semantic-synonyms';
```

2. Integrate semantic synonyms into QueryParser:

In query-parser.ts, after entity extraction but before returning, expand seniority levels:

Add import:
```typescript
import { expandSemanticSynonyms } from './semantic-synonyms';
```

In the parse() method, after skill expansion and before returning the result, add:

```typescript
// Step 6: Expand semantic synonyms for seniority
const semanticExpansion = expandSemanticSynonyms({
  role: entities.role,
  seniority: entities.seniority
});

// Include expanded seniorities in the result
// These can be used for filtering candidates by title pattern matching
this.logger.debug(
  {
    originalSeniority: entities.seniority,
    expandedSeniorities: semanticExpansion.expandedSeniorities,
    originalRole: entities.role,
    expandedRoles: semanticExpansion.expandedRoles
  },
  'Semantic synonyms expanded'
);
```

The expanded seniorities can be used by the search service to build more flexible filters or title matching patterns.

3. Update ParsedQuery type to include semantic expansions (in types.ts):

Add to ParsedQuery interface:
```typescript
/** Semantic expansions for role and seniority */
semanticExpansion?: {
  expandedRoles: string[];
  expandedSeniorities: string[];
};
```

And include it in the result:
```typescript
const result: ParsedQuery = {
  originalQuery: trimmedQuery,
  parseMethod: 'nlp',
  confidence: classification.confidence,
  intent: classification.intent,
  entities: {
    ...entities,
    expandedSkills: expansion.allSkills.filter(
      s => !entities.skills.map(sk => sk.toLowerCase()).includes(s.toLowerCase())
    )
  },
  semanticExpansion,  // Add this
  timings
};
```
  </action>
  <verify>
Compile and test:
```bash
cd services/hh-search-svc && npm run typecheck
npm test -- src/nlp/
```
  </verify>
  <done>
Semantic synonyms integrated into NLP pipeline, barrel export updated.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd services/hh-search-svc && npm run typecheck`
2. All NLP tests pass: `npm test -- src/nlp/`
3. Service starts with NLP enabled
4. Health endpoint reports NLP status
5. Semantic synonyms expand "Lead" to include "Senior", "Staff", "Principal"
</verification>

<success_criteria>
- QueryParser initialized at service startup (background, non-blocking)
- Health endpoint includes NLP status
- Semantic synonyms module expands seniority and role terms
- "Lead engineer" search matches "Senior", "Staff", "Principal" candidates
- Portuguese terms supported (senhor -> senior, etc.)
- All NLP tests pass
- Service compiles and starts successfully
</success_criteria>

<output>
After completion, create `.planning/phases/12-natural-language-search/12-06-SUMMARY.md`
</output>
