---
phase: 12-natural-language-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/hh-search-svc/src/nlp/types.ts
  - services/hh-search-svc/src/nlp/vector-utils.ts
  - services/hh-search-svc/src/nlp/intent-router.ts
  - services/hh-search-svc/src/nlp/__tests__/intent-router.spec.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Intent classification returns structured search for recruiting queries"
    - "Intent classification returns keyword_fallback for gibberish queries"
    - "Classification completes in under 20ms (cosine similarity only)"
  artifacts:
    - path: "services/hh-search-svc/src/nlp/types.ts"
      provides: "NLP type definitions for Phase 12"
      exports: ["ParsedQuery", "NLPConfig", "IntentRoute", "ExtractedEntities"]
    - path: "services/hh-search-svc/src/nlp/vector-utils.ts"
      provides: "Cosine similarity and vector utilities"
      exports: ["cosineSimilarity", "averageEmbeddings"]
    - path: "services/hh-search-svc/src/nlp/intent-router.ts"
      provides: "Embedding-based semantic intent router"
      exports: ["IntentRouter", "classifyIntent"]
  key_links:
    - from: "services/hh-search-svc/src/nlp/intent-router.ts"
      to: "services/hh-search-svc/src/nlp/vector-utils.ts"
      via: "import cosineSimilarity"
      pattern: "import.*cosineSimilarity.*vector-utils"
---

<objective>
Build the semantic router lite - an embedding-based intent classification system for natural language queries.

Purpose: Enable fast (5-20ms) classification of search queries into structured_search, similarity_search, or keyword_fallback intents without LLM latency.

Output: IntentRouter class with pre-computed route embeddings and cosine similarity classification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-natural-language-search/12-RESEARCH.md

# Existing code to reference
@services/hh-search-svc/src/types.ts
@services/hh-search-svc/src/embed-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NLP types and vector utilities</name>
  <files>
    services/hh-search-svc/src/nlp/types.ts
    services/hh-search-svc/src/nlp/vector-utils.ts
  </files>
  <action>
Create the nlp/ subdirectory in services/hh-search-svc/src/.

Create types.ts with:
```typescript
export type IntentType = 'structured_search' | 'similarity_search' | 'keyword_fallback';

export interface IntentRoute {
  name: IntentType;
  utterances: string[];
  embedding?: number[];  // Pre-computed average embedding
}

export interface IntentClassification {
  intent: IntentType;
  confidence: number;  // 0-1 cosine similarity
  timingMs: number;
}

export interface ExtractedEntities {
  role?: string;
  skills: string[];
  seniority?: 'junior' | 'mid' | 'senior' | 'staff' | 'principal' | 'lead' | 'manager' | 'director' | 'vp' | 'c-level';
  location?: string;
  remote?: boolean;
  experienceYears?: { min?: number; max?: number };
}

export interface ParsedQuery {
  originalQuery: string;
  parseMethod: 'nlp' | 'keyword_fallback';
  confidence: number;
  intent: IntentType;
  entities: ExtractedEntities & {
    expandedSkills: string[];  // After ontology expansion
  };
  timings: {
    intentMs: number;
    extractionMs: number;
    expansionMs: number;
    totalMs: number;
  };
}

export interface NLPConfig {
  enabled: boolean;
  intentConfidenceThreshold: number;  // Below this, fall back to keyword
  extractionTimeoutMs: number;  // Max time for LLM extraction
  cacheExtractionResults: boolean;
  enableQueryExpansion: boolean;
  expansionDepth: number;  // Graph hops for skill expansion
  expansionConfidenceThreshold: number;  // Min confidence for expanded skills
}
```

Create vector-utils.ts with:
```typescript
/**
 * Calculate cosine similarity between two vectors.
 * Used for intent classification via embedding comparison.
 */
export function cosineSimilarity(a: number[], b: number[]): number {
  if (a.length !== b.length) {
    throw new Error(`Vector length mismatch: ${a.length} vs ${b.length}`);
  }

  let dotProduct = 0;
  let normA = 0;
  let normB = 0;

  for (let i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }

  const denominator = Math.sqrt(normA) * Math.sqrt(normB);
  if (denominator === 0) return 0;

  return dotProduct / denominator;
}

/**
 * Compute average of multiple embeddings.
 * Used to create route embeddings from multiple utterances.
 */
export function averageEmbeddings(embeddings: number[][]): number[] {
  if (embeddings.length === 0) {
    throw new Error('Cannot average empty embeddings array');
  }

  const dimensions = embeddings[0].length;
  const result = new Array(dimensions).fill(0);

  for (const embedding of embeddings) {
    if (embedding.length !== dimensions) {
      throw new Error(`Embedding dimension mismatch: expected ${dimensions}, got ${embedding.length}`);
    }
    for (let i = 0; i < dimensions; i++) {
      result[i] += embedding[i];
    }
  }

  const count = embeddings.length;
  for (let i = 0; i < dimensions; i++) {
    result[i] /= count;
  }

  return result;
}
```
  </action>
  <verify>
Files exist and TypeScript compiles without errors:
```bash
ls services/hh-search-svc/src/nlp/types.ts services/hh-search-svc/src/nlp/vector-utils.ts
cd services/hh-search-svc && npm run typecheck
```
  </verify>
  <done>
types.ts exports all NLP interfaces, vector-utils.ts exports cosineSimilarity and averageEmbeddings functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement IntentRouter with route definitions</name>
  <files>
    services/hh-search-svc/src/nlp/intent-router.ts
  </files>
  <action>
Create intent-router.ts implementing the semantic router lite pattern:

```typescript
import type { Logger } from 'pino';
import type { IntentType, IntentRoute, IntentClassification } from './types';
import { cosineSimilarity, averageEmbeddings } from './vector-utils';

/**
 * Route definitions with sample utterances.
 * Route embeddings are computed lazily on first use.
 */
const INTENT_ROUTES: IntentRoute[] = [
  {
    name: 'structured_search',
    utterances: [
      'senior python developer in NYC',
      'ML engineers with 5 years experience',
      'remote frontend developers',
      'backend engineer in San Francisco',
      'data scientist with tensorflow experience',
      'product manager in fintech',
      'full stack developer javascript react',
      'devops engineer AWS kubernetes',
      'iOS developer swift objective-c',
      'android developer kotlin java',
      'senior software engineer at startups',
      'machine learning engineer remote',
      'staff engineer distributed systems',
      'principal engineer cloud architecture',
      'engineering manager with 10+ years',
      'desenvolvedor python em São Paulo',  // Portuguese support
      'engenheiro de software sênior',
      'desenvolvedor full stack remoto'
    ]
  },
  {
    name: 'similarity_search',
    utterances: [
      'candidates like John Smith',
      'similar profiles to this candidate',
      'more like this person',
      'find similar candidates',
      'profiles similar to candidate-123',
      'more candidates like her',
      'similar background to this engineer',
      'profiles matching this one'
    ]
  },
  {
    name: 'keyword_fallback',
    utterances: [
      'asdfasdf',
      'xyz123',
      'test query',
      '!!!',
      '...',
      'aaa bbb ccc',
      'random text here',
      '12345'
    ]
  }
];

interface IntentRouterDeps {
  generateEmbedding: (text: string) => Promise<number[]>;
  logger: Logger;
}

export class IntentRouter {
  private routeEmbeddings: Map<IntentType, number[]> = new Map();
  private initialized = false;
  private initPromise: Promise<void> | null = null;
  private readonly logger: Logger;
  private readonly generateEmbedding: (text: string) => Promise<number[]>;
  private readonly confidenceThreshold: number;

  constructor(deps: IntentRouterDeps, confidenceThreshold = 0.6) {
    this.logger = deps.logger.child({ module: 'intent-router' });
    this.generateEmbedding = deps.generateEmbedding;
    this.confidenceThreshold = confidenceThreshold;
  }

  /**
   * Initialize route embeddings lazily on first use.
   * Computes average embedding for each route's utterances.
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    if (this.initPromise) {
      return this.initPromise;
    }

    this.initPromise = this.doInitialize();
    await this.initPromise;
  }

  private async doInitialize(): Promise<void> {
    this.logger.info('Initializing intent router embeddings...');
    const start = Date.now();

    for (const route of INTENT_ROUTES) {
      try {
        // Generate embeddings for all utterances in parallel
        const utteranceEmbeddings = await Promise.all(
          route.utterances.map(utterance => this.generateEmbedding(utterance))
        );

        // Compute average embedding for route
        const routeEmbedding = averageEmbeddings(utteranceEmbeddings);
        this.routeEmbeddings.set(route.name, routeEmbedding);

        this.logger.debug(
          { route: route.name, utteranceCount: route.utterances.length },
          'Route embedding computed'
        );
      } catch (error) {
        this.logger.error(
          { error, route: route.name },
          'Failed to compute route embedding'
        );
        throw error;
      }
    }

    this.initialized = true;
    this.logger.info(
      { durationMs: Date.now() - start, routeCount: this.routeEmbeddings.size },
      'Intent router initialization complete'
    );
  }

  /**
   * Classify a query's intent using cosine similarity.
   *
   * @param queryEmbedding - Pre-computed embedding for the query
   * @returns Intent classification with confidence score
   */
  classifyIntent(queryEmbedding: number[]): IntentClassification {
    if (!this.initialized) {
      throw new Error('IntentRouter not initialized. Call initialize() first.');
    }

    const start = Date.now();
    let bestIntent: IntentType = 'keyword_fallback';
    let bestSimilarity = -1;

    for (const [intentName, routeEmbedding] of this.routeEmbeddings) {
      const similarity = cosineSimilarity(queryEmbedding, routeEmbedding);

      this.logger.trace(
        { intent: intentName, similarity: similarity.toFixed(4) },
        'Intent similarity score'
      );

      if (similarity > bestSimilarity) {
        bestSimilarity = similarity;
        bestIntent = intentName;
      }
    }

    // Apply confidence threshold
    if (bestSimilarity < this.confidenceThreshold) {
      this.logger.debug(
        {
          bestIntent,
          bestSimilarity: bestSimilarity.toFixed(4),
          threshold: this.confidenceThreshold
        },
        'Below confidence threshold, falling back to keyword search'
      );
      bestIntent = 'keyword_fallback';
    }

    const timingMs = Date.now() - start;

    return {
      intent: bestIntent,
      confidence: Math.max(0, Math.min(1, bestSimilarity)),
      timingMs
    };
  }

  /**
   * Check if router is initialized.
   */
  isInitialized(): boolean {
    return this.initialized;
  }

  /**
   * Get route embedding for testing/debugging.
   */
  getRouteEmbedding(intent: IntentType): number[] | undefined {
    return this.routeEmbeddings.get(intent);
  }
}

/**
 * Convenience function for stateless intent classification.
 * Requires pre-initialized router instance.
 */
export function classifyIntent(
  router: IntentRouter,
  queryEmbedding: number[]
): IntentClassification {
  return router.classifyIntent(queryEmbedding);
}
```
  </action>
  <verify>
TypeScript compiles and exports are correct:
```bash
cd services/hh-search-svc && npm run typecheck
grep -l "IntentRouter" src/nlp/intent-router.ts
```
  </verify>
  <done>
IntentRouter class exists with initialize(), classifyIntent(), and proper route definitions including Portuguese examples.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for intent router</name>
  <files>
    services/hh-search-svc/src/nlp/__tests__/intent-router.spec.ts
  </files>
  <action>
Create intent-router.spec.ts with comprehensive tests:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { IntentRouter, classifyIntent } from '../intent-router';
import { cosineSimilarity, averageEmbeddings } from '../vector-utils';
import type { Logger } from 'pino';

// Mock logger
const mockLogger = {
  info: vi.fn(),
  debug: vi.fn(),
  trace: vi.fn(),
  warn: vi.fn(),
  error: vi.fn(),
  child: vi.fn().mockReturnThis()
} as unknown as Logger;

// Mock embedding generator - returns deterministic embeddings
function createMockEmbeddingGenerator(dimension = 768) {
  return async (text: string): Promise<number[]> => {
    // Create deterministic embedding based on text hash
    const hash = text.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
    const embedding = new Array(dimension).fill(0);
    for (let i = 0; i < dimension; i++) {
      embedding[i] = Math.sin(hash * (i + 1) * 0.001);
    }
    return embedding;
  };
}

describe('vector-utils', () => {
  describe('cosineSimilarity', () => {
    it('should return 1 for identical vectors', () => {
      const vector = [1, 2, 3, 4, 5];
      expect(cosineSimilarity(vector, vector)).toBeCloseTo(1.0);
    });

    it('should return 0 for orthogonal vectors', () => {
      const a = [1, 0, 0];
      const b = [0, 1, 0];
      expect(cosineSimilarity(a, b)).toBeCloseTo(0.0);
    });

    it('should return -1 for opposite vectors', () => {
      const a = [1, 2, 3];
      const b = [-1, -2, -3];
      expect(cosineSimilarity(a, b)).toBeCloseTo(-1.0);
    });

    it('should throw on mismatched lengths', () => {
      expect(() => cosineSimilarity([1, 2], [1, 2, 3])).toThrow('Vector length mismatch');
    });

    it('should handle zero vectors', () => {
      const zero = [0, 0, 0];
      const other = [1, 2, 3];
      expect(cosineSimilarity(zero, other)).toBe(0);
    });
  });

  describe('averageEmbeddings', () => {
    it('should return same vector for single embedding', () => {
      const embedding = [1, 2, 3];
      const result = averageEmbeddings([embedding]);
      expect(result).toEqual([1, 2, 3]);
    });

    it('should compute average correctly', () => {
      const embeddings = [
        [0, 2, 4],
        [2, 4, 6],
        [4, 6, 8]
      ];
      const result = averageEmbeddings(embeddings);
      expect(result).toEqual([2, 4, 6]);
    });

    it('should throw on empty array', () => {
      expect(() => averageEmbeddings([])).toThrow('Cannot average empty embeddings array');
    });

    it('should throw on mismatched dimensions', () => {
      const embeddings = [
        [1, 2, 3],
        [1, 2]
      ];
      expect(() => averageEmbeddings(embeddings)).toThrow('Embedding dimension mismatch');
    });
  });
});

describe('IntentRouter', () => {
  let router: IntentRouter;
  let mockGenerateEmbedding: ReturnType<typeof createMockEmbeddingGenerator>;

  beforeEach(() => {
    vi.clearAllMocks();
    mockGenerateEmbedding = createMockEmbeddingGenerator();
    router = new IntentRouter(
      { generateEmbedding: mockGenerateEmbedding, logger: mockLogger },
      0.5  // Lower threshold for testing
    );
  });

  describe('initialization', () => {
    it('should initialize route embeddings', async () => {
      await router.initialize();
      expect(router.isInitialized()).toBe(true);
    });

    it('should compute embeddings for all routes', async () => {
      await router.initialize();

      expect(router.getRouteEmbedding('structured_search')).toBeDefined();
      expect(router.getRouteEmbedding('similarity_search')).toBeDefined();
      expect(router.getRouteEmbedding('keyword_fallback')).toBeDefined();
    });

    it('should handle concurrent initialization calls', async () => {
      const promises = [
        router.initialize(),
        router.initialize(),
        router.initialize()
      ];

      await Promise.all(promises);
      expect(router.isInitialized()).toBe(true);
    });

    it('should not re-initialize after success', async () => {
      await router.initialize();
      const firstEmbedding = router.getRouteEmbedding('structured_search');

      await router.initialize();
      const secondEmbedding = router.getRouteEmbedding('structured_search');

      expect(firstEmbedding).toBe(secondEmbedding);
    });
  });

  describe('classifyIntent', () => {
    beforeEach(async () => {
      await router.initialize();
    });

    it('should throw if not initialized', () => {
      const uninitializedRouter = new IntentRouter(
        { generateEmbedding: mockGenerateEmbedding, logger: mockLogger }
      );

      expect(() => uninitializedRouter.classifyIntent([1, 2, 3])).toThrow('not initialized');
    });

    it('should return classification with confidence', async () => {
      const queryEmbedding = await mockGenerateEmbedding('senior python developer');
      const result = router.classifyIntent(queryEmbedding);

      expect(result).toHaveProperty('intent');
      expect(result).toHaveProperty('confidence');
      expect(result).toHaveProperty('timingMs');
      expect(typeof result.confidence).toBe('number');
      expect(result.confidence).toBeGreaterThanOrEqual(0);
      expect(result.confidence).toBeLessThanOrEqual(1);
    });

    it('should classify quickly (under 5ms for similarity calculation)', async () => {
      const queryEmbedding = await mockGenerateEmbedding('test query');
      const result = router.classifyIntent(queryEmbedding);

      // Classification should be very fast (just cosine similarity)
      expect(result.timingMs).toBeLessThan(5);
    });

    it('should fall back to keyword_fallback for low confidence', async () => {
      // Create a query that produces a low-confidence classification
      const router2 = new IntentRouter(
        { generateEmbedding: mockGenerateEmbedding, logger: mockLogger },
        0.99  // Very high threshold
      );
      await router2.initialize();

      const queryEmbedding = await mockGenerateEmbedding('random gibberish xyz');
      const result = router2.classifyIntent(queryEmbedding);

      expect(result.intent).toBe('keyword_fallback');
    });

    it('should clamp confidence to [0, 1]', async () => {
      const queryEmbedding = await mockGenerateEmbedding('test');
      const result = router.classifyIntent(queryEmbedding);

      expect(result.confidence).toBeGreaterThanOrEqual(0);
      expect(result.confidence).toBeLessThanOrEqual(1);
    });
  });

  describe('classifyIntent helper function', () => {
    beforeEach(async () => {
      await router.initialize();
    });

    it('should work with helper function', async () => {
      const queryEmbedding = await mockGenerateEmbedding('python developer');
      const result = classifyIntent(router, queryEmbedding);

      expect(result).toHaveProperty('intent');
      expect(result).toHaveProperty('confidence');
    });
  });
});
```
  </action>
  <verify>
Run the tests:
```bash
cd services/hh-search-svc && npm test -- src/nlp/__tests__/intent-router.spec.ts
```
  </verify>
  <done>
All tests pass, covering initialization, classification, fallback behavior, and edge cases.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `cd services/hh-search-svc && npm run typecheck`
2. All tests pass: `npm test -- src/nlp/`
3. Files exist:
   - services/hh-search-svc/src/nlp/types.ts
   - services/hh-search-svc/src/nlp/vector-utils.ts
   - services/hh-search-svc/src/nlp/intent-router.ts
   - services/hh-search-svc/src/nlp/__tests__/intent-router.spec.ts
</verification>

<success_criteria>
- IntentRouter class initializes route embeddings lazily
- classifyIntent() returns intent type and confidence score
- Classification completes in under 5ms (cosine similarity only)
- Tests cover initialization, classification, and fallback behavior
- Portuguese utterances included in structured_search route
</success_criteria>

<output>
After completion, create `.planning/phases/12-natural-language-search/12-01-SUMMARY.md`
</output>
