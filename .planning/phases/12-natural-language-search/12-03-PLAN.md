---
phase: 12-natural-language-search
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - services/hh-search-svc/src/nlp/query-expander.ts
  - services/hh-search-svc/src/nlp/__tests__/query-expander.spec.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Query expansion uses existing skills-graph.ts for related skills"
    - "Expansion only includes high-confidence direct relations (>=0.8)"
    - "Expanded skills are weighted lower than explicit skills"
    - "Expansion depth is configurable (default 1 hop)"
  artifacts:
    - path: "services/hh-search-svc/src/nlp/query-expander.ts"
      provides: "Skills ontology query expansion"
      exports: ["QueryExpander", "expandQuerySkills"]
  key_links:
    - from: "services/hh-search-svc/src/nlp/query-expander.ts"
      to: "functions/src/shared/skills-graph.ts"
      via: "import getCachedSkillExpansion"
      pattern: "getCachedSkillExpansion|expandSkills"
---

<objective>
Build the query expander using the existing skills ontology to expand queries with related skills.

Purpose: When user searches "Python developer", automatically include Django, Flask, FastAPI as related skills to improve recall while weighting them lower than explicit skills.

Output: QueryExpander class that wraps skills-graph.ts with configurable depth and confidence thresholds.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-natural-language-search/12-RESEARCH.md

# Existing code to reference - the skills graph we'll wrap
@functions/src/shared/skills-graph.ts
@services/hh-search-svc/src/nlp/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement QueryExpander wrapping skills-graph</name>
  <files>
    services/hh-search-svc/src/nlp/query-expander.ts
  </files>
  <action>
Create query-expander.ts that wraps the existing skills ontology:

```typescript
import type { Logger } from 'pino';

// Import from the shared skills graph module
// Note: Need to verify the exact import path works from hh-search-svc
import {
  getCachedSkillExpansion,
  type SkillExpansionResult
} from '../../../../functions/src/shared/skills-graph';

export interface ExpandedSkill {
  name: string;
  isExplicit: boolean;  // true if user mentioned it, false if expanded
  confidence: number;   // 1.0 for explicit, decay for expanded
  source?: string;      // which explicit skill it expanded from
}

export interface QueryExpansionResult {
  explicitSkills: string[];
  expandedSkills: ExpandedSkill[];
  allSkills: string[];  // Union for search queries
  timingMs: number;
}

export interface QueryExpanderConfig {
  enabled: boolean;
  maxDepth: number;           // Graph traversal depth (default: 1)
  confidenceThreshold: number; // Min confidence to include (default: 0.8)
  maxExpansionsPerSkill: number; // Limit expanded skills per input (default: 5)
  expandedSkillWeight: number;   // Weight multiplier for expanded skills (default: 0.6)
}

const DEFAULT_CONFIG: QueryExpanderConfig = {
  enabled: true,
  maxDepth: 1,
  confidenceThreshold: 0.8,
  maxExpansionsPerSkill: 5,
  expandedSkillWeight: 0.6
};

export class QueryExpander {
  private readonly config: QueryExpanderConfig;
  private readonly logger: Logger;

  constructor(logger: Logger, config?: Partial<QueryExpanderConfig>) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.logger = logger.child({ module: 'query-expander' });
  }

  /**
   * Expand a list of skills using the skills ontology.
   *
   * @param skills - Explicit skills from user query
   * @returns Expansion result with explicit and expanded skills
   */
  expandSkills(skills: string[]): QueryExpansionResult {
    const start = Date.now();

    if (!this.config.enabled || skills.length === 0) {
      return {
        explicitSkills: skills,
        expandedSkills: skills.map(s => ({
          name: s,
          isExplicit: true,
          confidence: 1.0
        })),
        allSkills: skills,
        timingMs: Date.now() - start
      };
    }

    // Track all skills to avoid duplicates
    const seenSkills = new Set<string>(skills.map(s => s.toLowerCase()));
    const expandedSkills: ExpandedSkill[] = [];

    // Add explicit skills first
    for (const skill of skills) {
      expandedSkills.push({
        name: skill,
        isExplicit: true,
        confidence: 1.0
      });
    }

    // Expand each explicit skill
    for (const skill of skills) {
      try {
        const expansion = this.expandSingleSkill(skill, seenSkills);

        for (const expanded of expansion) {
          seenSkills.add(expanded.name.toLowerCase());
          expandedSkills.push(expanded);
        }
      } catch (error) {
        this.logger.warn(
          { error: error instanceof Error ? error.message : error, skill },
          'Failed to expand skill'
        );
      }
    }

    // Build allSkills list (for search queries)
    const allSkills = expandedSkills.map(s => s.name);

    const timingMs = Date.now() - start;

    this.logger.debug(
      {
        explicit: skills.length,
        expanded: expandedSkills.length - skills.length,
        total: allSkills.length,
        timingMs
      },
      'Query expansion complete'
    );

    return {
      explicitSkills: skills,
      expandedSkills,
      allSkills,
      timingMs
    };
  }

  /**
   * Expand a single skill using the skills graph.
   */
  private expandSingleSkill(
    skill: string,
    seenSkills: Set<string>
  ): ExpandedSkill[] {
    const result: ExpandedSkill[] = [];

    // Use cached skill expansion from skills-graph.ts
    let expansion: SkillExpansionResult;
    try {
      expansion = getCachedSkillExpansion(skill, this.config.maxDepth);
    } catch (error) {
      // Skill not found in ontology - that's OK, just don't expand
      this.logger.trace({ skill }, 'Skill not found in ontology');
      return result;
    }

    // If no related skills, return empty
    if (!expansion.relatedSkills || expansion.relatedSkills.length === 0) {
      return result;
    }

    // Filter and limit expansions
    let count = 0;
    for (const related of expansion.relatedSkills) {
      // Skip if already seen
      if (seenSkills.has(related.skillName.toLowerCase())) {
        continue;
      }

      // Skip if below confidence threshold
      if (related.confidence < this.config.confidenceThreshold) {
        continue;
      }

      // Only include direct relations for now (depth=1)
      if (related.relationshipType !== 'direct') {
        continue;
      }

      // Apply expansion limit
      if (count >= this.config.maxExpansionsPerSkill) {
        break;
      }

      result.push({
        name: related.skillName,
        isExplicit: false,
        confidence: related.confidence * this.config.expandedSkillWeight,
        source: skill
      });

      count++;
    }

    return result;
  }

  /**
   * Get expanded skills as a simple array for search queries.
   * Explicit skills appear first, then expanded skills.
   */
  getSearchSkills(skills: string[]): string[] {
    const result = this.expandSkills(skills);
    return result.allSkills;
  }

  /**
   * Get expanded skills with weights for scoring.
   * Returns map of skill name -> weight (1.0 for explicit, lower for expanded).
   */
  getSkillWeights(skills: string[]): Map<string, number> {
    const result = this.expandSkills(skills);
    const weights = new Map<string, number>();

    for (const expanded of result.expandedSkills) {
      weights.set(expanded.name.toLowerCase(), expanded.confidence);
    }

    return weights;
  }

  /**
   * Update configuration at runtime.
   */
  updateConfig(config: Partial<QueryExpanderConfig>): void {
    Object.assign(this.config, config);
    this.logger.info({ config: this.config }, 'Query expander config updated');
  }

  /**
   * Get current configuration.
   */
  getConfig(): QueryExpanderConfig {
    return { ...this.config };
  }
}

/**
 * Convenience function for one-off expansion.
 */
export function expandQuerySkills(
  skills: string[],
  logger: Logger,
  config?: Partial<QueryExpanderConfig>
): QueryExpansionResult {
  const expander = new QueryExpander(logger, config);
  return expander.expandSkills(skills);
}
```

Note: The import path from functions/src/shared/ may need adjustment. If it doesn't work, we'll need to either:
1. Copy the skills-graph.ts to services/hh-search-svc/src/shared/
2. Set up a proper workspace dependency
3. Use an HTTP call to a skills service

For now, assume the import works and we'll verify during testing.
  </action>
  <verify>
TypeScript compiles (may need import path adjustment):
```bash
cd services/hh-search-svc && npm run typecheck
# If import path fails, will need to adjust
```
  </verify>
  <done>
QueryExpander class exists wrapping skills-graph.ts with configurable depth, confidence threshold, and expansion limits.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for query expander</name>
  <files>
    services/hh-search-svc/src/nlp/__tests__/query-expander.spec.ts
  </files>
  <action>
Create query-expander.spec.ts with tests:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { QueryExpander, expandQuerySkills } from '../query-expander';
import type { Logger } from 'pino';

// Mock the skills-graph module
vi.mock('../../../../../functions/src/shared/skills-graph', () => ({
  getCachedSkillExpansion: vi.fn()
}));

import { getCachedSkillExpansion } from '../../../../../functions/src/shared/skills-graph';
const mockedGetCachedSkillExpansion = vi.mocked(getCachedSkillExpansion);

// Mock logger
const mockLogger = {
  info: vi.fn(),
  debug: vi.fn(),
  trace: vi.fn(),
  warn: vi.fn(),
  error: vi.fn(),
  child: vi.fn().mockReturnThis()
} as unknown as Logger;

describe('QueryExpander', () => {
  let expander: QueryExpander;

  beforeEach(() => {
    vi.clearAllMocks();

    expander = new QueryExpander(mockLogger, {
      enabled: true,
      maxDepth: 1,
      confidenceThreshold: 0.8,
      maxExpansionsPerSkill: 5,
      expandedSkillWeight: 0.6
    });
  });

  describe('expandSkills', () => {
    it('should return explicit skills when expansion is disabled', () => {
      const disabledExpander = new QueryExpander(mockLogger, { enabled: false });

      const result = disabledExpander.expandSkills(['Python', 'JavaScript']);

      expect(result.explicitSkills).toEqual(['Python', 'JavaScript']);
      expect(result.allSkills).toEqual(['Python', 'JavaScript']);
      expect(mockedGetCachedSkillExpansion).not.toHaveBeenCalled();
    });

    it('should expand Python to include Django and Flask', () => {
      mockedGetCachedSkillExpansion.mockReturnValue({
        originalSkill: 'Python',
        originalSkillId: 'python',
        relatedSkills: [
          { skillId: 'django', skillName: 'Django', relationshipType: 'direct', distance: 1, confidence: 0.9 },
          { skillId: 'flask', skillName: 'Flask', relationshipType: 'direct', distance: 1, confidence: 0.85 },
          { skillId: 'fastapi', skillName: 'FastAPI', relationshipType: 'direct', distance: 1, confidence: 0.82 }
        ]
      });

      const result = expander.expandSkills(['Python']);

      expect(result.explicitSkills).toEqual(['Python']);
      expect(result.allSkills).toContain('Python');
      expect(result.allSkills).toContain('Django');
      expect(result.allSkills).toContain('Flask');
      expect(result.allSkills).toContain('FastAPI');
    });

    it('should filter out low-confidence expansions', () => {
      mockedGetCachedSkillExpansion.mockReturnValue({
        originalSkill: 'Python',
        originalSkillId: 'python',
        relatedSkills: [
          { skillId: 'django', skillName: 'Django', relationshipType: 'direct', distance: 1, confidence: 0.9 },
          { skillId: 'ruby', skillName: 'Ruby', relationshipType: 'direct', distance: 1, confidence: 0.5 }  // Below threshold
        ]
      });

      const result = expander.expandSkills(['Python']);

      expect(result.allSkills).toContain('Django');
      expect(result.allSkills).not.toContain('Ruby');
    });

    it('should only include direct relations', () => {
      mockedGetCachedSkillExpansion.mockReturnValue({
        originalSkill: 'Python',
        originalSkillId: 'python',
        relatedSkills: [
          { skillId: 'django', skillName: 'Django', relationshipType: 'direct', distance: 1, confidence: 0.9 },
          { skillId: 'react', skillName: 'React', relationshipType: 'indirect', distance: 2, confidence: 0.85 }
        ]
      });

      const result = expander.expandSkills(['Python']);

      expect(result.allSkills).toContain('Django');
      expect(result.allSkills).not.toContain('React');
    });

    it('should respect maxExpansionsPerSkill limit', () => {
      mockedGetCachedSkillExpansion.mockReturnValue({
        originalSkill: 'Python',
        originalSkillId: 'python',
        relatedSkills: [
          { skillId: 's1', skillName: 'Skill1', relationshipType: 'direct', distance: 1, confidence: 0.95 },
          { skillId: 's2', skillName: 'Skill2', relationshipType: 'direct', distance: 1, confidence: 0.94 },
          { skillId: 's3', skillName: 'Skill3', relationshipType: 'direct', distance: 1, confidence: 0.93 },
          { skillId: 's4', skillName: 'Skill4', relationshipType: 'direct', distance: 1, confidence: 0.92 },
          { skillId: 's5', skillName: 'Skill5', relationshipType: 'direct', distance: 1, confidence: 0.91 },
          { skillId: 's6', skillName: 'Skill6', relationshipType: 'direct', distance: 1, confidence: 0.90 },
          { skillId: 's7', skillName: 'Skill7', relationshipType: 'direct', distance: 1, confidence: 0.89 }
        ]
      });

      const limitedExpander = new QueryExpander(mockLogger, {
        maxExpansionsPerSkill: 3
      });

      const result = limitedExpander.expandSkills(['Python']);

      // Should have Python + 3 expanded = 4 total
      expect(result.allSkills.length).toBe(4);
    });

    it('should not duplicate skills across expansions', () => {
      mockedGetCachedSkillExpansion.mockImplementation((skill: string) => {
        if (skill.toLowerCase() === 'python') {
          return {
            originalSkill: 'Python',
            originalSkillId: 'python',
            relatedSkills: [
              { skillId: 'django', skillName: 'Django', relationshipType: 'direct', distance: 1, confidence: 0.9 }
            ]
          };
        }
        if (skill.toLowerCase() === 'django') {
          return {
            originalSkill: 'Django',
            originalSkillId: 'django',
            relatedSkills: [
              { skillId: 'python', skillName: 'Python', relationshipType: 'direct', distance: 1, confidence: 0.9 }
            ]
          };
        }
        return { originalSkill: skill, originalSkillId: null, relatedSkills: [] };
      });

      const result = expander.expandSkills(['Python', 'Django']);

      // Python and Django explicit, no duplicates
      const uniqueSkills = new Set(result.allSkills.map(s => s.toLowerCase()));
      expect(uniqueSkills.size).toBe(result.allSkills.length);
    });

    it('should mark explicit skills with confidence 1.0', () => {
      mockedGetCachedSkillExpansion.mockReturnValue({
        originalSkill: 'Python',
        originalSkillId: 'python',
        relatedSkills: []
      });

      const result = expander.expandSkills(['Python']);

      const pythonEntry = result.expandedSkills.find(s => s.name === 'Python');
      expect(pythonEntry?.isExplicit).toBe(true);
      expect(pythonEntry?.confidence).toBe(1.0);
    });

    it('should mark expanded skills with reduced confidence', () => {
      mockedGetCachedSkillExpansion.mockReturnValue({
        originalSkill: 'Python',
        originalSkillId: 'python',
        relatedSkills: [
          { skillId: 'django', skillName: 'Django', relationshipType: 'direct', distance: 1, confidence: 0.9 }
        ]
      });

      const result = expander.expandSkills(['Python']);

      const djangoEntry = result.expandedSkills.find(s => s.name === 'Django');
      expect(djangoEntry?.isExplicit).toBe(false);
      expect(djangoEntry?.confidence).toBe(0.9 * 0.6);  // 0.54
      expect(djangoEntry?.source).toBe('Python');
    });

    it('should handle skill not found in ontology gracefully', () => {
      mockedGetCachedSkillExpansion.mockImplementation(() => {
        throw new Error('Skill not found');
      });

      const result = expander.expandSkills(['UnknownSkill']);

      expect(result.explicitSkills).toEqual(['UnknownSkill']);
      expect(result.allSkills).toEqual(['UnknownSkill']);
    });

    it('should report timing', () => {
      mockedGetCachedSkillExpansion.mockReturnValue({
        originalSkill: 'Python',
        originalSkillId: 'python',
        relatedSkills: []
      });

      const result = expander.expandSkills(['Python']);

      expect(result.timingMs).toBeGreaterThanOrEqual(0);
    });
  });

  describe('getSkillWeights', () => {
    it('should return weight map with normalized skill names', () => {
      mockedGetCachedSkillExpansion.mockReturnValue({
        originalSkill: 'Python',
        originalSkillId: 'python',
        relatedSkills: [
          { skillId: 'django', skillName: 'Django', relationshipType: 'direct', distance: 1, confidence: 0.9 }
        ]
      });

      const weights = expander.getSkillWeights(['Python']);

      expect(weights.get('python')).toBe(1.0);
      expect(weights.get('django')).toBe(0.9 * 0.6);
    });
  });

  describe('getSearchSkills', () => {
    it('should return flat array for search queries', () => {
      mockedGetCachedSkillExpansion.mockReturnValue({
        originalSkill: 'Python',
        originalSkillId: 'python',
        relatedSkills: [
          { skillId: 'django', skillName: 'Django', relationshipType: 'direct', distance: 1, confidence: 0.9 }
        ]
      });

      const skills = expander.getSearchSkills(['Python']);

      expect(skills).toEqual(['Python', 'Django']);
    });
  });

  describe('expandQuerySkills helper', () => {
    it('should work as convenience function', () => {
      mockedGetCachedSkillExpansion.mockReturnValue({
        originalSkill: 'Python',
        originalSkillId: 'python',
        relatedSkills: []
      });

      const result = expandQuerySkills(['Python'], mockLogger);

      expect(result.explicitSkills).toEqual(['Python']);
    });
  });
});
```
  </action>
  <verify>
Run the tests:
```bash
cd services/hh-search-svc && npm test -- src/nlp/__tests__/query-expander.spec.ts
```
  </verify>
  <done>
All tests pass, covering skill expansion, confidence filtering, deduplication, weighting, and edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify skills-graph import or create local wrapper</name>
  <files>
    services/hh-search-svc/src/nlp/query-expander.ts
  </files>
  <action>
Test if the skills-graph import works. If not, create a local wrapper that either:

1. Imports from the correct path
2. Copies the necessary types and functions locally
3. Creates a stub that can be replaced with HTTP calls later

First, verify the import path by running typecheck. If it fails, update the import path.

The skills-graph.ts is at: `/Volumes/Extreme Pro/myprojects/headhunter/functions/src/shared/skills-graph.ts`

Possible import solutions:
- Relative: `../../../../functions/src/shared/skills-graph` (may fail due to workspace boundaries)
- Create symlink in services/hh-search-svc/src/shared/
- Copy the skills-graph.ts and skills-master.ts to services/hh-search-svc/src/shared/
- Use dynamic import with path resolution

If the import fails, create a local interface-only version with a TODO to wire up the actual implementation:

```typescript
// If import fails, use this interface and stub
export interface SkillExpansionResult {
  originalSkill: string;
  originalSkillId: string | null;
  relatedSkills: Array<{
    skillId: string;
    skillName: string;
    relationshipType: 'direct' | 'indirect';
    distance: number;
    confidence: number;
  }>;
}

// Stub that returns empty results until wired up
export function getCachedSkillExpansion(
  skillName: string,
  maxDepth: number = 2
): SkillExpansionResult {
  // TODO: Wire up to actual skills-graph.ts
  return {
    originalSkill: skillName,
    originalSkillId: null,
    relatedSkills: []
  };
}
```
  </action>
  <verify>
TypeScript compiles successfully:
```bash
cd services/hh-search-svc && npm run typecheck
```
  </verify>
  <done>
skills-graph integration works (either direct import or local wrapper with TODO).
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd services/hh-search-svc && npm run typecheck`
2. Tests pass: `npm test -- src/nlp/__tests__/query-expander.spec.ts`
3. QueryExpander:
   - Expands "Python" to include Django, Flask (from ontology)
   - Respects confidence threshold (>=0.8)
   - Weights expanded skills lower than explicit (0.6x)
   - Deduplicates across multiple input skills
</verification>

<success_criteria>
- QueryExpander class wrapping skills-graph.ts
- Configurable: depth, confidence threshold, max expansions per skill
- Explicit skills get confidence 1.0
- Expanded skills get reduced confidence (0.6x by default)
- Expansion completes in under 5ms (in-memory graph lookup)
- Graceful fallback if skill not in ontology
</success_criteria>

<output>
After completion, create `.planning/phases/12-natural-language-search/12-03-SUMMARY.md`
</output>
