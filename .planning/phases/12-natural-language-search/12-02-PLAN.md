---
phase: 12-natural-language-search
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - services/hh-search-svc/src/nlp/entity-extractor.ts
  - services/hh-search-svc/src/nlp/__tests__/entity-extractor.spec.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Entity extraction parses role, skills, seniority, location from natural language"
    - "Experience years are extracted from patterns like '5+ years', '3-5 years'"
    - "Remote work preference is detected from 'remote', 'work from home'"
    - "Extraction completes under 150ms or falls back gracefully"
  artifacts:
    - path: "services/hh-search-svc/src/nlp/entity-extractor.ts"
      provides: "Together AI JSON mode entity extraction"
      exports: ["EntityExtractor", "extractEntities"]
  key_links:
    - from: "services/hh-search-svc/src/nlp/entity-extractor.ts"
      to: "services/hh-search-svc/src/nlp/types.ts"
      via: "import ExtractedEntities"
      pattern: "import.*ExtractedEntities.*types"
---

<objective>
Build the entity extractor using Together AI JSON mode for structured extraction of recruiting entities.

Purpose: Extract role, skills, seniority, location, experience years, and remote preference from natural language queries using LLM with JSON schema enforcement.

Output: EntityExtractor class with timeout handling, caching support, and graceful fallback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-natural-language-search/12-RESEARCH.md

# Existing code to reference
@services/hh-search-svc/src/rerank-client.ts
@services/hh-search-svc/src/nlp/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement EntityExtractor with Together AI JSON mode</name>
  <files>
    services/hh-search-svc/src/nlp/entity-extractor.ts
  </files>
  <action>
Create entity-extractor.ts implementing LLM-based entity extraction:

```typescript
import Together from 'together-ai';
import type { Logger } from 'pino';
import type { ExtractedEntities } from './types';

/**
 * JSON schema for entity extraction.
 * Together AI will enforce this structure in the response.
 */
const ENTITY_SCHEMA = {
  type: 'object',
  properties: {
    role: {
      type: 'string',
      description: 'Job role or title mentioned (developer, engineer, manager, analyst, designer, etc.)'
    },
    skills: {
      type: 'array',
      items: { type: 'string' },
      description: 'Technical or soft skills explicitly mentioned in the query'
    },
    seniority: {
      type: 'string',
      enum: ['junior', 'mid', 'senior', 'staff', 'principal', 'lead', 'manager', 'director', 'vp', 'c-level'],
      description: 'Seniority or experience level mentioned'
    },
    location: {
      type: 'string',
      description: 'City, state, region, or country mentioned'
    },
    remote: {
      type: 'boolean',
      description: 'Whether remote work is mentioned or implied'
    },
    experienceYears: {
      type: 'object',
      properties: {
        min: { type: 'number', description: 'Minimum years of experience' },
        max: { type: 'number', description: 'Maximum years of experience' }
      },
      description: 'Years of experience if mentioned (e.g., "5+ years" -> min: 5, "3-5 years" -> min: 3, max: 5)'
    }
  },
  required: []  // All fields optional - only extract what's present
} as const;

/**
 * System prompt for entity extraction.
 * Emphasizes extracting ONLY what is explicitly mentioned.
 */
const SYSTEM_PROMPT = `You are a recruiting query parser. Extract structured entities from job search queries.

IMPORTANT RULES:
1. ONLY extract entities that are EXPLICITLY mentioned in the query
2. Do NOT infer or assume skills based on the role (e.g., don't add "Python" just because it says "developer")
3. If an entity is not mentioned, omit it from the response
4. For seniority, match common terms: "senior"/"sr." -> senior, "junior"/"jr." -> junior, "lead" -> lead
5. For experience years, extract ranges like "5+ years" -> min: 5, "3-5 years" -> min: 3, max: 5
6. For remote, detect "remote", "work from home", "wfh", "distributed", "anywhere"
7. Support Portuguese terms: "sênior" -> senior, "pleno" -> mid, "júnior" -> junior, "remoto" -> remote: true

Respond ONLY with valid JSON matching the schema. No explanations.`;

interface EntityExtractorConfig {
  apiKey: string;
  model: string;
  timeoutMs: number;
  maxRetries: number;
}

interface EntityExtractorDeps {
  config: EntityExtractorConfig;
  logger: Logger;
}

export class EntityExtractor {
  private readonly client: Together;
  private readonly model: string;
  private readonly timeoutMs: number;
  private readonly maxRetries: number;
  private readonly logger: Logger;

  constructor(deps: EntityExtractorDeps) {
    this.client = new Together({ apiKey: deps.config.apiKey });
    this.model = deps.config.model;
    this.timeoutMs = deps.config.timeoutMs;
    this.maxRetries = deps.config.maxRetries;
    this.logger = deps.logger.child({ module: 'entity-extractor' });
  }

  /**
   * Extract entities from a natural language query.
   *
   * @param query - Natural language search query
   * @returns Extracted entities (may be partial if some fields not detected)
   */
  async extractEntities(query: string): Promise<{
    entities: ExtractedEntities;
    timingMs: number;
    fromCache: boolean;
  }> {
    const start = Date.now();
    const trimmedQuery = query.trim();

    // Skip extraction for very short or obviously invalid queries
    if (trimmedQuery.length < 3 || !this.looksLikeNaturalLanguage(trimmedQuery)) {
      this.logger.debug({ query: trimmedQuery }, 'Skipping extraction for short/invalid query');
      return {
        entities: { skills: [] },
        timingMs: Date.now() - start,
        fromCache: false
      };
    }

    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        const entities = await this.doExtraction(trimmedQuery, attempt);
        return {
          entities,
          timingMs: Date.now() - start,
          fromCache: false
        };
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        this.logger.warn(
          { error: lastError.message, attempt, maxRetries: this.maxRetries },
          'Entity extraction attempt failed'
        );

        if (attempt < this.maxRetries) {
          // Brief backoff before retry
          await this.delay(100 * attempt);
        }
      }
    }

    // All retries failed - return empty entities
    this.logger.error(
      { error: lastError?.message, query: trimmedQuery },
      'Entity extraction failed after all retries'
    );

    return {
      entities: { skills: [] },
      timingMs: Date.now() - start,
      fromCache: false
    };
  }

  private async doExtraction(query: string): Promise<ExtractedEntities> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeoutMs);

    try {
      const response = await this.client.chat.completions.create({
        model: this.model,
        messages: [
          { role: 'system', content: SYSTEM_PROMPT },
          { role: 'user', content: `Extract entities from: "${query}"` }
        ],
        response_format: {
          type: 'json_schema',
          json_schema: {
            name: 'query_entities',
            schema: ENTITY_SCHEMA
          }
        },
        temperature: 0.1,  // Low temperature for consistent extraction
        max_tokens: 256    // Entities don't need many tokens
      }, {
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      const content = response.choices?.[0]?.message?.content;
      if (!content) {
        throw new Error('Empty response from Together AI');
      }

      const parsed = JSON.parse(content) as Partial<ExtractedEntities>;

      // Validate and normalize the response
      return this.normalizeEntities(parsed, query);
    } catch (error) {
      clearTimeout(timeoutId);

      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error(`Entity extraction timed out after ${this.timeoutMs}ms`);
      }
      throw error;
    }
  }

  /**
   * Normalize and validate extracted entities.
   * Ensures skills is always an array and validates seniority enum.
   */
  private normalizeEntities(
    parsed: Partial<ExtractedEntities>,
    originalQuery: string
  ): ExtractedEntities {
    const result: ExtractedEntities = {
      skills: []
    };

    // Role
    if (typeof parsed.role === 'string' && parsed.role.trim()) {
      result.role = parsed.role.trim().toLowerCase();
    }

    // Skills - filter out hallucinated skills
    if (Array.isArray(parsed.skills)) {
      const validSkills = parsed.skills
        .filter(s => typeof s === 'string' && s.trim())
        .map(s => s.trim())
        .filter(s => this.isSkillMentioned(s, originalQuery));

      result.skills = validSkills;

      // Log if skills were filtered out
      if (validSkills.length < parsed.skills.length) {
        this.logger.debug(
          {
            original: parsed.skills,
            filtered: validSkills,
            query: originalQuery
          },
          'Filtered hallucinated skills'
        );
      }
    }

    // Seniority
    if (parsed.seniority) {
      const normalizedSeniority = this.normalizeSeniority(parsed.seniority);
      if (normalizedSeniority) {
        result.seniority = normalizedSeniority;
      }
    }

    // Location
    if (typeof parsed.location === 'string' && parsed.location.trim()) {
      result.location = parsed.location.trim();
    }

    // Remote
    if (typeof parsed.remote === 'boolean') {
      result.remote = parsed.remote;
    }

    // Experience years
    if (parsed.experienceYears) {
      const exp = parsed.experienceYears;
      if (typeof exp.min === 'number' || typeof exp.max === 'number') {
        result.experienceYears = {
          min: typeof exp.min === 'number' ? exp.min : undefined,
          max: typeof exp.max === 'number' ? exp.max : undefined
        };
      }
    }

    return result;
  }

  /**
   * Check if a skill appears to be mentioned in the original query.
   * Uses fuzzy matching to allow for minor variations.
   */
  private isSkillMentioned(skill: string, query: string): boolean {
    const skillLower = skill.toLowerCase();
    const queryLower = query.toLowerCase();

    // Direct mention
    if (queryLower.includes(skillLower)) {
      return true;
    }

    // Check for common abbreviations
    const abbreviations: Record<string, string[]> = {
      'javascript': ['js'],
      'typescript': ['ts'],
      'kubernetes': ['k8s'],
      'postgresql': ['postgres', 'psql'],
      'machine learning': ['ml'],
      'artificial intelligence': ['ai'],
      'amazon web services': ['aws'],
      'google cloud platform': ['gcp'],
      'continuous integration': ['ci'],
      'continuous deployment': ['cd']
    };

    for (const [full, abbrevs] of Object.entries(abbreviations)) {
      if (skillLower === full) {
        for (const abbrev of abbrevs) {
          if (queryLower.includes(abbrev)) {
            return true;
          }
        }
      }
    }

    return false;
  }

  /**
   * Normalize seniority terms to standard enum values.
   */
  private normalizeSeniority(value: string): ExtractedEntities['seniority'] | null {
    const normalized = value.toLowerCase().trim();

    const mapping: Record<string, ExtractedEntities['seniority']> = {
      'junior': 'junior',
      'jr': 'junior',
      'jr.': 'junior',
      'entry': 'junior',
      'entry-level': 'junior',
      'júnior': 'junior',

      'mid': 'mid',
      'mid-level': 'mid',
      'midlevel': 'mid',
      'intermediate': 'mid',
      'pleno': 'mid',

      'senior': 'senior',
      'sr': 'senior',
      'sr.': 'senior',
      'sênior': 'senior',

      'staff': 'staff',

      'principal': 'principal',

      'lead': 'lead',
      'tech lead': 'lead',
      'team lead': 'lead',

      'manager': 'manager',
      'mgr': 'manager',
      'gerente': 'manager',

      'director': 'director',
      'dir': 'director',
      'diretor': 'director',

      'vp': 'vp',
      'vice president': 'vp',

      'c-level': 'c-level',
      'cto': 'c-level',
      'ceo': 'c-level',
      'cfo': 'c-level',
      'cpo': 'c-level'
    };

    return mapping[normalized] ?? null;
  }

  /**
   * Quick check if input looks like natural language vs random characters.
   */
  private looksLikeNaturalLanguage(text: string): boolean {
    // Must have at least one letter
    if (!/[a-zA-Z]/.test(text)) {
      return false;
    }

    // Check for minimum word-like patterns
    const words = text.split(/\s+/).filter(w => w.length > 0);
    if (words.length === 0) {
      return false;
    }

    // At least one word should have multiple letters
    const hasRealWord = words.some(w => (w.match(/[a-zA-Z]/g) ?? []).length >= 2);
    return hasRealWord;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

/**
 * Factory function to create EntityExtractor with default config.
 */
export function createEntityExtractor(
  logger: Logger,
  config?: Partial<EntityExtractorConfig>
): EntityExtractor {
  const apiKey = config?.apiKey ?? process.env.TOGETHER_API_KEY;
  if (!apiKey) {
    throw new Error('TOGETHER_API_KEY environment variable is required');
  }

  return new EntityExtractor({
    config: {
      apiKey,
      model: config?.model ?? 'meta-llama/Llama-3.3-70B-Instruct-Turbo',
      timeoutMs: config?.timeoutMs ?? 100,  // Aggressive timeout for latency budget
      maxRetries: config?.maxRetries ?? 2
    },
    logger
  });
}

/**
 * Convenience function for one-off extraction.
 */
export async function extractEntities(
  extractor: EntityExtractor,
  query: string
): Promise<ExtractedEntities> {
  const result = await extractor.extractEntities(query);
  return result.entities;
}
```

Note: The 100ms timeout is aggressive per RESEARCH.md latency budget. In practice, may need to increase to 150-200ms and rely on caching.
  </action>
  <verify>
TypeScript compiles:
```bash
cd services/hh-search-svc && npm run typecheck
grep -l "EntityExtractor" src/nlp/entity-extractor.ts
```
  </verify>
  <done>
EntityExtractor class exists with Together AI JSON mode integration, timeout handling, hallucination filtering, and Portuguese term support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for entity extractor</name>
  <files>
    services/hh-search-svc/src/nlp/__tests__/entity-extractor.spec.ts
  </files>
  <action>
Create entity-extractor.spec.ts with tests covering extraction scenarios:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { EntityExtractor, createEntityExtractor } from '../entity-extractor';
import type { Logger } from 'pino';

// Mock together-ai
vi.mock('together-ai', () => {
  return {
    default: vi.fn().mockImplementation(() => ({
      chat: {
        completions: {
          create: vi.fn()
        }
      }
    }))
  };
});

// Mock logger
const mockLogger = {
  info: vi.fn(),
  debug: vi.fn(),
  trace: vi.fn(),
  warn: vi.fn(),
  error: vi.fn(),
  child: vi.fn().mockReturnThis()
} as unknown as Logger;

// Get the mocked Together client
import Together from 'together-ai';
const MockedTogether = vi.mocked(Together);

describe('EntityExtractor', () => {
  let extractor: EntityExtractor;
  let mockCreate: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    vi.clearAllMocks();

    // Get reference to the mock create function
    mockCreate = vi.fn();
    MockedTogether.mockImplementation(() => ({
      chat: {
        completions: {
          create: mockCreate
        }
      }
    }) as unknown as Together);

    extractor = new EntityExtractor({
      config: {
        apiKey: 'test-api-key',
        model: 'test-model',
        timeoutMs: 1000,
        maxRetries: 2
      },
      logger: mockLogger
    });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('extractEntities', () => {
    it('should extract role and skills', async () => {
      mockCreate.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              role: 'developer',
              skills: ['Python', 'Django'],
              seniority: 'senior',
              location: 'NYC'
            })
          }
        }]
      });

      const result = await extractor.extractEntities('senior python django developer in NYC');

      expect(result.entities.role).toBe('developer');
      expect(result.entities.skills).toContain('Python');
      expect(result.entities.skills).toContain('Django');
      expect(result.entities.seniority).toBe('senior');
      expect(result.entities.location).toBe('NYC');
    });

    it('should extract experience years from "5+ years"', async () => {
      mockCreate.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              role: 'engineer',
              skills: [],
              experienceYears: { min: 5 }
            })
          }
        }]
      });

      const result = await extractor.extractEntities('engineer with 5+ years experience');

      expect(result.entities.experienceYears?.min).toBe(5);
      expect(result.entities.experienceYears?.max).toBeUndefined();
    });

    it('should extract experience years range from "3-5 years"', async () => {
      mockCreate.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              role: 'developer',
              skills: [],
              experienceYears: { min: 3, max: 5 }
            })
          }
        }]
      });

      const result = await extractor.extractEntities('developer with 3-5 years experience');

      expect(result.entities.experienceYears?.min).toBe(3);
      expect(result.entities.experienceYears?.max).toBe(5);
    });

    it('should detect remote work preference', async () => {
      mockCreate.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              role: 'engineer',
              skills: [],
              remote: true
            })
          }
        }]
      });

      const result = await extractor.extractEntities('remote software engineer');

      expect(result.entities.remote).toBe(true);
    });

    it('should filter hallucinated skills not in query', async () => {
      mockCreate.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              role: 'developer',
              skills: ['Python', 'AWS', 'Docker']  // AWS and Docker not mentioned
            })
          }
        }]
      });

      const result = await extractor.extractEntities('python developer');

      // Only Python should remain
      expect(result.entities.skills).toContain('Python');
      expect(result.entities.skills).not.toContain('AWS');
      expect(result.entities.skills).not.toContain('Docker');
    });

    it('should handle abbreviations in skill matching', async () => {
      mockCreate.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              role: 'developer',
              skills: ['JavaScript', 'TypeScript', 'Kubernetes']
            })
          }
        }]
      });

      const result = await extractor.extractEntities('js ts k8s developer');

      expect(result.entities.skills).toContain('JavaScript');
      expect(result.entities.skills).toContain('TypeScript');
      expect(result.entities.skills).toContain('Kubernetes');
    });

    it('should normalize Portuguese seniority terms', async () => {
      mockCreate.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({
              role: 'desenvolvedor',
              skills: ['Python'],
              seniority: 'sênior'
            })
          }
        }]
      });

      const result = await extractor.extractEntities('desenvolvedor sênior python');

      expect(result.entities.seniority).toBe('senior');
    });

    it('should return empty entities for very short queries', async () => {
      const result = await extractor.extractEntities('ab');

      expect(result.entities.skills).toEqual([]);
      expect(mockCreate).not.toHaveBeenCalled();
    });

    it('should return empty entities for non-text queries', async () => {
      const result = await extractor.extractEntities('12345');

      expect(result.entities.skills).toEqual([]);
      expect(mockCreate).not.toHaveBeenCalled();
    });

    it('should handle API errors gracefully', async () => {
      mockCreate.mockRejectedValue(new Error('API error'));

      const result = await extractor.extractEntities('senior python developer');

      expect(result.entities.skills).toEqual([]);
      expect(mockLogger.error).toHaveBeenCalled();
    });

    it('should retry on failure', async () => {
      mockCreate
        .mockRejectedValueOnce(new Error('Temporary error'))
        .mockResolvedValueOnce({
          choices: [{
            message: {
              content: JSON.stringify({
                role: 'developer',
                skills: []
              })
            }
          }]
        });

      const result = await extractor.extractEntities('developer');

      expect(result.entities.role).toBe('developer');
      expect(mockCreate).toHaveBeenCalledTimes(2);
    });

    it('should report timing', async () => {
      mockCreate.mockResolvedValueOnce({
        choices: [{
          message: {
            content: JSON.stringify({ skills: [] })
          }
        }]
      });

      const result = await extractor.extractEntities('test query');

      expect(result.timingMs).toBeGreaterThanOrEqual(0);
    });
  });

  describe('createEntityExtractor', () => {
    it('should throw if API key is missing', () => {
      const originalEnv = process.env.TOGETHER_API_KEY;
      delete process.env.TOGETHER_API_KEY;

      expect(() => createEntityExtractor(mockLogger, {})).toThrow('TOGETHER_API_KEY');

      process.env.TOGETHER_API_KEY = originalEnv;
    });

    it('should use environment variable for API key', () => {
      const originalEnv = process.env.TOGETHER_API_KEY;
      process.env.TOGETHER_API_KEY = 'env-api-key';

      expect(() => createEntityExtractor(mockLogger)).not.toThrow();

      process.env.TOGETHER_API_KEY = originalEnv;
    });

    it('should allow config overrides', () => {
      const originalEnv = process.env.TOGETHER_API_KEY;
      process.env.TOGETHER_API_KEY = 'env-api-key';

      const extractor = createEntityExtractor(mockLogger, {
        model: 'custom-model',
        timeoutMs: 500
      });

      expect(extractor).toBeDefined();

      process.env.TOGETHER_API_KEY = originalEnv;
    });
  });
});
```
  </action>
  <verify>
Run the tests:
```bash
cd services/hh-search-svc && npm test -- src/nlp/__tests__/entity-extractor.spec.ts
```
  </verify>
  <done>
All tests pass, covering entity extraction, hallucination filtering, abbreviations, Portuguese terms, error handling, and retries.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd services/hh-search-svc && npm run typecheck`
2. Tests pass: `npm test -- src/nlp/__tests__/entity-extractor.spec.ts`
3. Entity extractor handles:
   - Role, skills, seniority, location, remote, experience years extraction
   - Hallucination filtering (skills not in query)
   - Portuguese term normalization
   - Timeout and retry handling
</verification>

<success_criteria>
- EntityExtractor class with Together AI JSON mode
- Extracts: role, skills, seniority, location, remote, experienceYears
- Filters hallucinated skills that weren't mentioned in query
- Normalizes Portuguese seniority terms (senhor -> senior, pleno -> mid)
- Handles timeouts and retries gracefully
- Returns empty entities on failure (graceful degradation)
</success_criteria>

<output>
After completion, create `.planning/phases/12-natural-language-search/12-02-SUMMARY.md`
</output>
