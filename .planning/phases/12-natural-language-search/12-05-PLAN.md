---
phase: 12-natural-language-search
plan: 05
type: execute
wave: 3
depends_on:
  - 12-04
files_modified:
  - services/hh-search-svc/src/search-service.ts
  - services/hh-search-svc/src/types.ts
  - services/hh-search-svc/src/routes.ts
  - services/hh-search-svc/src/__tests__/search-service.spec.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Search service accepts natural language queries"
    - "NLP parsing is optional and controlled by enableNlp flag in request"
    - "Parsed query filters are applied to hybrid search"
    - "Semantic seniority expansion is applied (Lead matches Senior/Staff/Principal)"
    - "Response includes NLP metadata (confidence, parse method, timings)"
    - "Fallback to keyword search preserves original query for BM25"
  artifacts:
    - path: "services/hh-search-svc/src/search-service.ts"
      provides: "NLP integration in search pipeline"
      contains: "QueryParser"
    - path: "services/hh-search-svc/src/types.ts"
      provides: "NLP request/response fields"
      contains: "enableNlp"
  key_links:
    - from: "services/hh-search-svc/src/search-service.ts"
      to: "services/hh-search-svc/src/nlp/query-parser.ts"
      via: "import QueryParser"
      pattern: "import.*QueryParser.*nlp"
    - from: "services/hh-search-svc/src/search-service.ts"
      to: "services/hh-search-svc/src/nlp/semantic-synonyms.ts"
      via: "expandedSeniorities filter application"
      pattern: "semanticExpansion.*expandedSeniorities"
---

<objective>
Integrate the NLP pipeline into the search service, enabling natural language queries to be parsed and converted into structured search filters.

Purpose: Complete the end-to-end natural language search feature by wiring the NLP module into the existing search pipeline.

Output: Search service that accepts natural language queries, parses them, applies extracted filters (including semantic seniority expansion), and returns results with NLP metadata.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-natural-language-search/12-RESEARCH.md

# Prior plan SUMMARYs
# (12-04 provides QueryParser)

# Files to modify
@services/hh-search-svc/src/search-service.ts
@services/hh-search-svc/src/types.ts
@services/hh-search-svc/src/routes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NLP types to request/response interfaces</name>
  <files>
    services/hh-search-svc/src/types.ts
  </files>
  <action>
Update types.ts to include NLP-related request and response fields.

Add to HybridSearchRequest interface:
```typescript
/**
 * Enable natural language query parsing.
 * When true, the query will be parsed to extract:
 * - Role, skills, seniority, location, experience years
 * - Skills will be expanded using ontology
 * If parsing fails or confidence is low, falls back to keyword search.
 * @default false
 */
enableNlp?: boolean;

/**
 * Override NLP confidence threshold for this request.
 * Queries with lower confidence will fall back to keyword search.
 * @default 0.6
 */
nlpConfidenceThreshold?: number;
```

Add new interface for NLP metadata in response:
```typescript
/**
 * NLP parsing metadata included in response when enableNlp is true.
 */
export interface NLPParseResult {
  /** Whether NLP parsing was used or fell back to keyword */
  parseMethod: 'nlp' | 'keyword_fallback';

  /** Intent classification result */
  intent: 'structured_search' | 'similarity_search' | 'keyword_fallback';

  /** Confidence score of intent classification (0-1) */
  confidence: number;

  /** Entities extracted from query */
  entities: {
    role?: string;
    skills: string[];
    expandedSkills: string[];
    seniority?: string;
    location?: string;
    remote?: boolean;
    experienceYears?: { min?: number; max?: number };
  };

  /** Semantic expansions applied */
  semanticExpansion?: {
    expandedSeniorities: string[];
    expandedRoles: string[];
  };

  /** Timing breakdown for NLP operations */
  timings: {
    intentMs: number;
    extractionMs: number;
    expansionMs: number;
    totalMs: number;
  };
}
```

Add to HybridSearchResponse metadata:
```typescript
/** NLP parsing result (only present when enableNlp was true) */
nlp?: NLPParseResult;
```

Add to HybridSearchTimings:
```typescript
/** NLP parsing time in ms */
nlpMs?: number;
```
  </action>
  <verify>
TypeScript compiles:
```bash
cd services/hh-search-svc && npm run typecheck
```
  </verify>
  <done>
types.ts includes enableNlp request field and NLPParseResult response type with semanticExpansion.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate QueryParser into SearchService with semantic seniority expansion</name>
  <files>
    services/hh-search-svc/src/search-service.ts
  </files>
  <action>
Update search-service.ts to use QueryParser when enableNlp is true.

1. Add imports at top of file:
```typescript
import { QueryParser } from './nlp';
import type { ParsedQuery, NLPParseResult } from './nlp/types';
```

2. Add QueryParser to HybridSearchDependencies interface:
```typescript
queryParser?: QueryParser;
```

3. Add to SearchService class properties:
```typescript
private readonly queryParser: QueryParser | null;
```

4. Initialize in constructor:
```typescript
this.queryParser = deps.queryParser ?? null;
```

5. Add method to convert ParsedQuery to filters.
CRITICAL: Use semanticExpansion.expandedSeniorities for seniority filter expansion:
```typescript
/**
 * Convert NLP ParsedQuery to HybridSearchFilters.
 * Merges with existing filters, NLP-extracted filters take precedence for empty fields.
 *
 * IMPORTANT: Uses semantic expansion for seniority levels so that
 * "Lead engineer" matches Senior/Staff/Principal candidates.
 */
private applyNlpFilters(
  existingFilters: HybridSearchFilters | undefined,
  parsed: ParsedQuery
): HybridSearchFilters {
  const filters: HybridSearchFilters = { ...existingFilters };

  // Skills: merge explicit + expanded with existing
  if (parsed.entities.skills.length > 0 || parsed.entities.expandedSkills.length > 0) {
    const nlpSkills = [
      ...parsed.entities.skills,
      ...parsed.entities.expandedSkills
    ];

    if (filters.skills && filters.skills.length > 0) {
      // Merge, avoiding duplicates
      const allSkills = new Set([
        ...filters.skills.map(s => s.toLowerCase()),
        ...nlpSkills.map(s => s.toLowerCase())
      ]);
      filters.skills = Array.from(allSkills);
    } else {
      filters.skills = nlpSkills;
    }
  }

  // Location: only apply if not already set
  if (parsed.entities.location && !filters.locations?.length) {
    filters.locations = [parsed.entities.location];
  }

  // Seniority: Use EXPANDED seniorities from semantic synonyms, not just singular
  // This is the key link that enables "Lead engineer" -> Senior/Staff/Principal matching
  if (parsed.semanticExpansion?.expandedSeniorities?.length) {
    // Use expanded seniorities (includes synonyms like Lead -> [lead, senior, staff])
    if (!filters.seniorityLevels?.length) {
      filters.seniorityLevels = parsed.semanticExpansion.expandedSeniorities;

      this.logger.debug(
        {
          originalSeniority: parsed.entities.seniority,
          expandedSeniorities: parsed.semanticExpansion.expandedSeniorities
        },
        'Applied semantic seniority expansion to filters'
      );
    }
  } else if (parsed.entities.seniority && !filters.seniorityLevels?.length) {
    // Fallback: use singular seniority if no expansion available
    filters.seniorityLevels = [parsed.entities.seniority];
  }

  // Experience years: only apply if not already set
  if (parsed.entities.experienceYears) {
    if (parsed.entities.experienceYears.min !== undefined && filters.minExperienceYears === undefined) {
      filters.minExperienceYears = parsed.entities.experienceYears.min;
    }
    if (parsed.entities.experienceYears.max !== undefined && filters.maxExperienceYears === undefined) {
      filters.maxExperienceYears = parsed.entities.experienceYears.max;
    }
  }

  return filters;
}

/**
 * Convert ParsedQuery to NLPParseResult for response.
 */
private toNlpParseResult(parsed: ParsedQuery): NLPParseResult {
  return {
    parseMethod: parsed.parseMethod,
    intent: parsed.intent,
    confidence: parsed.confidence,
    entities: {
      role: parsed.entities.role,
      skills: parsed.entities.skills,
      expandedSkills: parsed.entities.expandedSkills,
      seniority: parsed.entities.seniority,
      location: parsed.entities.location,
      remote: parsed.entities.remote,
      experienceYears: parsed.entities.experienceYears
    },
    semanticExpansion: parsed.semanticExpansion,
    timings: parsed.timings
  };
}
```

6. Update hybridSearch method to use NLP when enabled:

Insert after the line `const sanitizedQuery = (request.query ?? '').trim();` and before embedding generation:

```typescript
// === NLP PARSING (if enabled) ===
let nlpResult: NLPParseResult | undefined;
let parsedQuery: ParsedQuery | undefined;

if (request.enableNlp && this.queryParser && sanitizedQuery.length >= 3) {
  const nlpStart = Date.now();

  try {
    // Parse query - note: we don't have embedding yet, so parser will generate one
    parsedQuery = await this.queryParser.parse(sanitizedQuery);
    nlpResult = this.toNlpParseResult(parsedQuery);
    timings.nlpMs = Date.now() - nlpStart;

    this.logger.info(
      {
        requestId: context.requestId,
        parseMethod: parsedQuery.parseMethod,
        confidence: parsedQuery.confidence.toFixed(3),
        extractedSkills: parsedQuery.entities.skills.length,
        expandedSkills: parsedQuery.entities.expandedSkills.length,
        semanticSeniorities: parsedQuery.semanticExpansion?.expandedSeniorities?.length ?? 0,
        nlpMs: timings.nlpMs
      },
      'NLP query parsing complete'
    );

    // Apply extracted filters if NLP succeeded
    if (parsedQuery.parseMethod === 'nlp') {
      request = {
        ...request,
        filters: this.applyNlpFilters(request.filters, parsedQuery)
      };

      this.logger.debug(
        {
          requestId: context.requestId,
          appliedFilters: request.filters,
          seniorityExpansion: parsedQuery.semanticExpansion?.expandedSeniorities
        },
        'NLP filters applied to search'
      );
    }
  } catch (error) {
    this.logger.warn(
      { error, requestId: context.requestId },
      'NLP parsing failed, falling back to keyword search'
    );
    // Continue with original query
  }
}
```

7. Include NLP result in response metadata. Find where response.metadata is set and add:

```typescript
if (nlpResult) {
  response.metadata = {
    ...response.metadata,
    nlp: nlpResult
  };
}
```

8. Include NLP debug info when includeDebug is true. In the debug section add:

```typescript
nlpParsing: nlpResult ? {
  parseMethod: nlpResult.parseMethod,
  intent: nlpResult.intent,
  confidence: nlpResult.confidence,
  extractedEntities: nlpResult.entities,
  semanticExpansion: nlpResult.semanticExpansion,
  appliedFilters: request.filters,
  timings: nlpResult.timings
} : undefined
```
  </action>
  <verify>
TypeScript compiles and search-service has NLP integration:
```bash
cd services/hh-search-svc && npm run typecheck
grep -l "QueryParser" src/search-service.ts
grep "expandedSeniorities" src/search-service.ts
```
  </verify>
  <done>
search-service.ts integrates QueryParser with filter application including semantic seniority expansion, response metadata, and debug info.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update routes schema and add integration tests</name>
  <files>
    services/hh-search-svc/src/routes.ts
    services/hh-search-svc/src/__tests__/search-service.spec.ts
  </files>
  <action>
1. Update routes.ts to add enableNlp to request schema:

Find the search route schema (hybridSearchBodySchema or similar) and add:
```typescript
enableNlp: Type.Optional(Type.Boolean({ description: 'Enable natural language query parsing' })),
nlpConfidenceThreshold: Type.Optional(Type.Number({
  description: 'Override NLP confidence threshold (0-1)',
  minimum: 0,
  maximum: 1
}))
```

2. Add integration tests to search-service.spec.ts:

Add a new describe block for NLP integration:

```typescript
describe('NLP Integration', () => {
  // Mock QueryParser
  const mockQueryParser = {
    parse: vi.fn(),
    initialize: vi.fn().mockResolvedValue(undefined),
    isInitialized: vi.fn().mockReturnValue(true)
  };

  beforeEach(() => {
    mockQueryParser.parse.mockReset();
  });

  it('should skip NLP when enableNlp is false', async () => {
    const service = new SearchService({
      ...baseDeps,
      queryParser: mockQueryParser as unknown as QueryParser
    });

    await service.hybridSearch(mockContext, {
      query: 'senior python developer',
      enableNlp: false
    });

    expect(mockQueryParser.parse).not.toHaveBeenCalled();
  });

  it('should apply NLP-extracted skills to filters', async () => {
    mockQueryParser.parse.mockResolvedValue({
      originalQuery: 'senior python developer',
      parseMethod: 'nlp',
      confidence: 0.85,
      intent: 'structured_search',
      entities: {
        role: 'developer',
        skills: ['Python'],
        expandedSkills: ['Django', 'Flask'],
        seniority: 'senior'
      },
      semanticExpansion: {
        expandedSeniorities: ['senior', 'sr', 'sr.', 'staff', 'principal'],
        expandedRoles: ['developer', 'engineer', 'programmer']
      },
      timings: { intentMs: 5, extractionMs: 50, expansionMs: 2, totalMs: 57 }
    });

    const service = new SearchService({
      ...baseDeps,
      queryParser: mockQueryParser as unknown as QueryParser
    });

    // Spy on pgClient to capture the filters
    const hybridSearchSpy = vi.spyOn(mockPgClient, 'hybridSearch');

    await service.hybridSearch(mockContext, {
      query: 'senior python developer',
      enableNlp: true
    });

    expect(mockQueryParser.parse).toHaveBeenCalledWith('senior python developer');

    // Verify filters were applied
    const callArgs = hybridSearchSpy.mock.calls[0][0];
    expect(callArgs.filters?.skills).toContain('python');
    expect(callArgs.filters?.skills).toContain('django');
    expect(callArgs.filters?.skills).toContain('flask');
  });

  it('should apply semantic seniority expansion - Lead matches Senior/Staff/Principal', async () => {
    mockQueryParser.parse.mockResolvedValue({
      originalQuery: 'lead engineer',
      parseMethod: 'nlp',
      confidence: 0.85,
      intent: 'structured_search',
      entities: {
        role: 'engineer',
        skills: [],
        expandedSkills: [],
        seniority: 'lead'
      },
      semanticExpansion: {
        expandedSeniorities: ['lead', 'tech lead', 'team lead', 'senior', 'staff'],
        expandedRoles: ['engineer', 'developer', 'programmer']
      },
      timings: { intentMs: 3, extractionMs: 40, expansionMs: 2, totalMs: 45 }
    });

    const service = new SearchService({
      ...baseDeps,
      queryParser: mockQueryParser as unknown as QueryParser
    });

    const hybridSearchSpy = vi.spyOn(mockPgClient, 'hybridSearch');

    await service.hybridSearch(mockContext, {
      query: 'lead engineer',
      enableNlp: true
    });

    // CRITICAL: Verify expanded seniorities are used, not just 'lead'
    const callArgs = hybridSearchSpy.mock.calls[0][0];
    expect(callArgs.filters?.seniorityLevels).toContain('lead');
    expect(callArgs.filters?.seniorityLevels).toContain('senior');
    expect(callArgs.filters?.seniorityLevels).toContain('staff');
  });

  it('should include NLP metadata in response', async () => {
    mockQueryParser.parse.mockResolvedValue({
      originalQuery: 'python dev',
      parseMethod: 'nlp',
      confidence: 0.78,
      intent: 'structured_search',
      entities: {
        skills: ['Python'],
        expandedSkills: []
      },
      semanticExpansion: {
        expandedSeniorities: [],
        expandedRoles: []
      },
      timings: { intentMs: 3, extractionMs: 45, expansionMs: 1, totalMs: 49 }
    });

    const service = new SearchService({
      ...baseDeps,
      queryParser: mockQueryParser as unknown as QueryParser
    });

    const response = await service.hybridSearch(mockContext, {
      query: 'python dev',
      enableNlp: true
    });

    expect(response.metadata?.nlp).toBeDefined();
    expect(response.metadata?.nlp?.parseMethod).toBe('nlp');
    expect(response.metadata?.nlp?.confidence).toBe(0.78);
    expect(response.metadata?.nlp?.semanticExpansion).toBeDefined();
  });

  it('should fall back gracefully when NLP fails', async () => {
    mockQueryParser.parse.mockRejectedValue(new Error('NLP service unavailable'));

    const service = new SearchService({
      ...baseDeps,
      queryParser: mockQueryParser as unknown as QueryParser
    });

    // Should not throw
    const response = await service.hybridSearch(mockContext, {
      query: 'python developer',
      enableNlp: true
    });

    expect(response.results).toBeDefined();
    expect(response.metadata?.nlp).toBeUndefined();
  });

  it('should preserve original query for BM25 text search', async () => {
    mockQueryParser.parse.mockResolvedValue({
      originalQuery: 'senior python developer in NYC',
      parseMethod: 'nlp',
      confidence: 0.85,
      intent: 'structured_search',
      entities: {
        skills: ['Python'],
        expandedSkills: [],
        location: 'NYC',
        seniority: 'senior'
      },
      semanticExpansion: {
        expandedSeniorities: ['senior', 'sr', 'staff', 'principal'],
        expandedRoles: []
      },
      timings: { intentMs: 3, extractionMs: 50, expansionMs: 1, totalMs: 54 }
    });

    const service = new SearchService({
      ...baseDeps,
      queryParser: mockQueryParser as unknown as QueryParser
    });

    const hybridSearchSpy = vi.spyOn(mockPgClient, 'hybridSearch');

    await service.hybridSearch(mockContext, {
      query: 'senior python developer in NYC',
      enableNlp: true
    });

    // Text query should remain the original for BM25
    const callArgs = hybridSearchSpy.mock.calls[0][0];
    expect(callArgs.textQuery).toBe('senior python developer in NYC');
  });
});
```
  </action>
  <verify>
Routes compile and tests pass:
```bash
cd services/hh-search-svc && npm run typecheck
npm test -- src/__tests__/search-service.spec.ts
```
  </verify>
  <done>
Routes schema includes enableNlp, search-service tests cover NLP integration including semantic seniority expansion.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd services/hh-search-svc && npm run typecheck`
2. All tests pass: `npm test -- src/__tests__/`
3. Search endpoint accepts enableNlp parameter
4. Response includes NLP metadata when parsing succeeds
5. Filters are correctly applied from NLP extraction
6. Semantic seniority expansion is applied (Lead -> Senior/Staff/Principal)
7. Graceful fallback when NLP fails
</verification>

<success_criteria>
- Search request accepts enableNlp: boolean parameter
- NLP parsing is attempted when enableNlp is true and query is long enough
- Extracted skills (explicit + expanded) are applied to filters
- Extracted location, seniority, experience years are applied to filters
- Semantic seniority expansion is used (semanticExpansion.expandedSeniorities)
- Response metadata includes full NLP parse result
- Debug info includes NLP parsing details
- Original query is preserved for BM25 text search
- Graceful fallback when NLP parsing fails
- "Lead engineer" returns Senior/Staff/Principal candidates (via expanded seniorities)
</success_criteria>

<output>
After completion, create `.planning/phases/12-natural-language-search/12-05-SUMMARY.md`
</output>
