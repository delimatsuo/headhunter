---
phase: 04-multi-signal-scoring-framework
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - services/hh-search-svc/src/search-service.ts
autonomous: true

must_haves:
  truths:
    - "hybridSearch resolves signal weights from request or role-type defaults"
    - "Each result includes signalScores with all 7 signals (0-1 normalized)"
    - "Final score is computed as weighted combination of signals"
    - "Response metadata includes weightsApplied and roleTypeUsed"
  artifacts:
    - path: "services/hh-search-svc/src/search-service.ts"
      provides: "Integrated signal scoring in hybrid search"
      contains: "resolveWeights"
  key_links:
    - from: "services/hh-search-svc/src/search-service.ts"
      to: "services/hh-search-svc/src/signal-weights.ts"
      via: "Weight resolution for search"
      pattern: "resolveWeights"
    - from: "services/hh-search-svc/src/search-service.ts"
      to: "services/hh-search-svc/src/scoring.ts"
      via: "Weighted score computation"
      pattern: "computeWeightedScore"
---

<objective>
Integrate signal weight resolution and weighted scoring into the SearchService.

Purpose: Connect the signal weight configuration and scoring utilities to the actual hybrid search flow. Each search request will resolve appropriate weights and compute weighted scores.

Output:
- Updated `search-service.ts` with signal weight resolution and weighted score computation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-multi-signal-scoring-framework/04-RESEARCH.md
@.planning/phases/04-multi-signal-scoring-framework/04-01-SUMMARY.md
@.planning/phases/04-multi-signal-scoring-framework/04-02-SUMMARY.md

# Reference files
@services/hh-search-svc/src/search-service.ts
@services/hh-search-svc/src/signal-weights.ts
@services/hh-search-svc/src/scoring.ts
@services/hh-search-svc/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add signal weight resolution to hybridSearch</name>
  <files>services/hh-search-svc/src/search-service.ts</files>
  <action>
Update the SearchService to resolve signal weights at the start of each search:

1. **Add imports** at top of file:
   ```typescript
   import { resolveWeights, type SignalWeightConfig, type RoleType } from './signal-weights';
   import { computeWeightedScore, extractSignalScores, normalizeVectorScore } from './scoring';
   ```

2. **Resolve weights in hybridSearch method** - Add after limit/offset parsing (around line 183):
   ```typescript
   // Resolve signal weights from request or role-type defaults
   const roleType: RoleType = request.roleType ?? 'default';
   const resolvedWeights = resolveWeights(request.signalWeights, roleType);

   this.logger.info(
     { requestId: context.requestId, roleType, weightsApplied: resolvedWeights },
     'Signal weights resolved for search.'
   );
   ```

3. **Store resolved weights** for later use in hydrateResult:
   - Pass resolvedWeights and roleType to hydrateResult method
   - Add these as additional parameters to the method signature

4. **Update the rows.map call** (around line 254):
   ```typescript
   let candidates = rows.map((row) => this.hydrateResult(row, request, resolvedWeights, roleType));
   ```
  </action>
  <verify>
- `npm run typecheck --prefix services/hh-search-svc` passes
- `grep "resolveWeights" services/hh-search-svc/src/search-service.ts` shows import and usage
  </verify>
  <done>
- Signal weights are resolved from request or defaults at search start
- roleType is determined from request or defaults to 'default'
- Weights are logged for debugging and passed to hydrateResult
  </done>
</task>

<task type="auto">
  <name>Task 2: Compute weighted scores in hydrateResult</name>
  <files>services/hh-search-svc/src/search-service.ts</files>
  <action>
Update the hydrateResult method to compute and include signal scores:

1. **Update hydrateResult signature**:
   ```typescript
   private hydrateResult(
     row: PgHybridSearchRow,
     request: HybridSearchRequest,
     resolvedWeights: SignalWeightConfig,
     roleType: RoleType
   ): HybridSearchResultItem {
   ```

2. **Extract signal scores** - Add after requestedSkills processing:
   ```typescript
   // Extract and normalize signal scores from row
   const signalScores = extractSignalScores(row);

   // Override vectorSimilarity with normalized value from hybrid search
   signalScores.vectorSimilarity = normalizeVectorScore(row.vector_score);
   ```

3. **Compute weighted score** - Replace or augment the existing hybridScore calculation:
   ```typescript
   // Compute weighted score from signals
   const weightedScore = computeWeightedScore(signalScores, resolvedWeights);

   // Use weighted score as base, then apply existing modifiers
   let hybridScore = weightedScore;

   // Apply skill coverage boost (existing logic)
   if (coverage > 0) {
     hybridScore += coverage * 0.1;
   }

   // Apply confidence penalty (existing logic)
   const confidence = Number(row.analysis_confidence ?? 0);
   if (confidence < this.config.search.confidenceFloor) {
     hybridScore *= 0.9;
     matchReasons.push('Lower profile confidence score');
   }

   // Clamp to 0-1 range
   hybridScore = Math.max(0, Math.min(1, hybridScore));
   ```

4. **Add signal breakdown to result** - Update the return object:
   ```typescript
   return {
     candidateId: row.candidate_id,
     score: hybridScore,
     vectorScore: baseVector,
     textScore: baseText,
     // RRF fields (existing)
     rrfScore: row.rrf_score != null ? Number(row.rrf_score) : undefined,
     vectorRank: row.vector_rank != null ? Number(row.vector_rank) : undefined,
     textRank: row.text_rank != null ? Number(row.text_rank) : undefined,
     confidence,
     fullName: row.full_name ?? undefined,
     title: row.current_title ?? undefined,
     headline: row.headline ?? undefined,
     location: row.location ?? undefined,
     country: row.country ?? undefined,
     industries: row.industries ?? undefined,
     yearsExperience: row.years_experience ?? undefined,
     skills: (row.skills ?? []).map((skill) => ({
       name: skill,
       weight: normalizedMatches.has(skill.toLowerCase()) ? 1 : 0.3
     })),
     matchReasons,
     metadata: row.metadata ?? undefined,
     compliance: hasCompliance ? compliance : undefined,
     // NEW: Signal scoring fields
     signalScores,
     weightsApplied: resolvedWeights,
     roleTypeUsed: roleType
   } satisfies HybridSearchResultItem;
   ```

5. **Update Firestore fallback mapping** (around line 260-280):
   - Add default signalScores with 0.5 for all signals (neutral)
   - Add weightsApplied and roleTypeUsed
  </action>
  <verify>
- `npm run typecheck --prefix services/hh-search-svc` passes
- `grep "signalScores" services/hh-search-svc/src/search-service.ts` shows field assignment
- `grep "computeWeightedScore" services/hh-search-svc/src/search-service.ts` shows usage
  </verify>
  <done>
- hydrateResult computes weighted score from extracted signals
- signalScores breakdown is included in each result
- weightsApplied and roleTypeUsed are included for transparency
- Firestore fallback includes neutral signal scores
  </done>
</task>

<task type="auto">
  <name>Task 3: Add signal scoring to response metadata and debug</name>
  <files>services/hh-search-svc/src/search-service.ts</files>
  <action>
Enhance response metadata and debug output with signal scoring information:

1. **Update response metadata** (around line 301-305):
   ```typescript
   metadata: {
     vectorWeight: this.config.search.vectorWeight,
     textWeight: this.config.search.textWeight,
     minSimilarity: this.config.search.minSimilarity,
     // NEW: Signal scoring config
     signalWeights: {
       roleType,
       weightsApplied: resolvedWeights
     }
   }
   ```

2. **Enhance debug output** (around line 315-336):
   ```typescript
   if (request.includeDebug) {
     response.debug = {
       candidateCount: ranked.length,
       filtersApplied: request.filters ?? {},
       minSimilarity: this.config.search.minSimilarity,
       // RRF configuration (existing)
       rrfConfig: {
         enabled: this.config.search.enableRrf,
         k: this.config.search.rrfK,
         perMethodLimit: this.config.search.perMethodLimit
       },
       // NEW: Signal scoring configuration
       signalScoringConfig: {
         roleType,
         weightsApplied: resolvedWeights,
         requestOverrides: request.signalWeights ?? null
       },
       // Enhanced score breakdown with signal scores
       scoreBreakdown: ranked.slice(0, 5).map(r => ({
         candidateId: r.candidateId,
         score: r.score,
         vectorScore: r.vectorScore,
         textScore: r.textScore,
         rrfScore: r.rrfScore,
         vectorRank: r.vectorRank,
         textRank: r.textRank,
         // NEW: Individual signal scores
         signalScores: r.signalScores
       }))
     };
   }
   ```

3. **Log signal scoring summary** (before returning response):
   ```typescript
   this.logger.info(
     {
       requestId: context.requestId,
       tenantId: context.tenant.id,
       timings,
       resultCount: response.results.length,
       roleType,
       avgWeightedScore: response.results.length > 0
         ? (response.results.reduce((sum, r) => sum + r.score, 0) / response.results.length).toFixed(3)
         : 0
     },
     'Hybrid search with signal scoring completed.'
   );
   ```
  </action>
  <verify>
- `npm run typecheck --prefix services/hh-search-svc` passes
- `grep "signalScoringConfig" services/hh-search-svc/src/search-service.ts` shows debug output
- `grep "avgWeightedScore" services/hh-search-svc/src/search-service.ts` shows logging
  </verify>
  <done>
- Response metadata includes signal weight configuration
- Debug output includes signalScoringConfig and per-candidate signal breakdown
- Search completion log includes roleType and average weighted score
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npm run typecheck --prefix services/hh-search-svc`
2. Run service tests: `npm test --prefix services/hh-search-svc` (if tests exist)
3. Manual API test with includeDebug=true to verify signal breakdown in response
4. Verify log output includes signal weight resolution
</verification>

<success_criteria>
- SCOR-01: vectorSimilarity is normalized to 0-1 and included in signalScores
- SCOR-07: Weights are resolved from request.signalWeights or role-type defaults
- SCOR-08: Final score is computed as weighted combination via computeWeightedScore
- Response includes signalScores, weightsApplied, roleTypeUsed for transparency
- Debug output shows signal scoring configuration and per-candidate breakdown
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-signal-scoring-framework/04-03-SUMMARY.md`
</output>
