---
phase: 04-multi-signal-scoring-framework
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - services/hh-search-svc/src/types.ts
  - services/hh-search-svc/src/scoring.ts
autonomous: true

must_haves:
  truths:
    - "HybridSearchRequest accepts optional signalWeights and roleType fields"
    - "HybridSearchResultItem includes signalScores breakdown (0-1 normalized)"
    - "computeWeightedScore function computes final score from signals and weights"
    - "Missing signals default to 0.5 (neutral) to avoid NaN"
  artifacts:
    - path: "services/hh-search-svc/src/types.ts"
      provides: "Extended request/response types for signal scoring"
      contains: "signalWeights"
    - path: "services/hh-search-svc/src/scoring.ts"
      provides: "Weighted score computation utilities"
      exports: ["SignalScores", "computeWeightedScore", "extractSignalScores"]
  key_links:
    - from: "services/hh-search-svc/src/scoring.ts"
      to: "services/hh-search-svc/src/signal-weights.ts"
      via: "SignalWeightConfig import"
      pattern: "import.*SignalWeightConfig"
    - from: "services/hh-search-svc/src/scoring.ts"
      to: "services/hh-search-svc/src/types.ts"
      via: "SignalScores used in response"
      pattern: "SignalScores"
---

<objective>
Extend search types and create scoring utilities for weighted signal combination.

Purpose: Enable HybridSearchRequest to accept custom weights and HybridSearchResultItem to return signal breakdowns. Create the core scoring function that computes weighted combinations.

Output:
- Extended types in `types.ts` for request weights and response signal breakdown
- New `scoring.ts` module with computation utilities
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-multi-signal-scoring-framework/04-RESEARCH.md
@.planning/phases/04-multi-signal-scoring-framework/04-01-SUMMARY.md

# Reference files
@services/hh-search-svc/src/types.ts
@services/hh-search-svc/src/signal-weights.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend HybridSearchRequest and HybridSearchResultItem types</name>
  <files>services/hh-search-svc/src/types.ts</files>
  <action>
Extend the existing types to support signal weights:

1. **Import SignalWeightConfig and RoleType** from signal-weights.ts

2. **Add SignalScores interface** (before HybridSearchResultItem):
   ```typescript
   export interface SignalScores {
     vectorSimilarity: number;  // 0-1 normalized vector score
     levelMatch: number;        // 0-1 level alignment
     specialtyMatch: number;    // 0-1 specialty match
     techStackMatch: number;    // 0-1 tech stack compatibility
     functionMatch: number;     // 0-1 function alignment
     trajectoryFit: number;     // 0-1 trajectory fit
     companyPedigree: number;   // 0-1 company pedigree
     skillsMatch?: number;      // 0-1 optional skills match
   }
   ```

3. **Extend HybridSearchRequest interface** - Add after existing fields:
   ```typescript
   /**
    * Override signal weights for this search.
    * If not provided, role-type defaults are used.
    * Weights should sum to 1.0 (will be normalized if not).
    */
   signalWeights?: Partial<SignalWeightConfig>;

   /**
    * Role type for weight preset selection.
    * Options: 'executive', 'manager', 'ic', 'default'
    * If not provided, defaults to 'default'.
    */
   roleType?: RoleType;
   ```

4. **Extend HybridSearchResultItem interface** - Add after existing fields:
   ```typescript
   /**
    * Individual signal scores (0-1 normalized) contributing to final score.
    * Only present when signal scoring is enabled.
    */
   signalScores?: SignalScores;

   /**
    * The signal weights that were applied to compute the score.
    * Useful for transparency and debugging.
    */
   weightsApplied?: SignalWeightConfig;

   /**
    * Which role type preset was used for scoring.
    */
   roleTypeUsed?: RoleType;
   ```

5. **Export SignalScores** in the module exports
  </action>
  <verify>
- `npm run typecheck --prefix services/hh-search-svc` passes
- `grep "signalWeights" services/hh-search-svc/src/types.ts` shows field in request
- `grep "SignalScores" services/hh-search-svc/src/types.ts` shows interface and usage
  </verify>
  <done>
- SignalScores interface defines all 7 core signals plus optional skillsMatch
- HybridSearchRequest has signalWeights and roleType optional fields
- HybridSearchResultItem has signalScores, weightsApplied, and roleTypeUsed fields
- All imports are added from signal-weights.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create scoring.ts computation module</name>
  <files>services/hh-search-svc/src/scoring.ts</files>
  <action>
Create a new module `scoring.ts` with weighted score computation utilities:

1. **Import dependencies**:
   ```typescript
   import type { SignalWeightConfig } from './signal-weights';
   import type { SignalScores, PgHybridSearchRow } from './types';
   ```

2. **computeWeightedScore function**:
   ```typescript
   /**
    * Computes the final weighted score from individual signals.
    * Missing signals default to 0.5 (neutral) to avoid NaN.
    *
    * @param signals - Individual signal scores (0-1 normalized)
    * @param weights - Weight configuration (should sum to 1.0)
    * @returns Final weighted score (0-1 range)
    */
   export function computeWeightedScore(
     signals: Partial<SignalScores>,
     weights: SignalWeightConfig
   ): number {
     // Default missing signals to 0.5 (neutral)
     const vs = signals.vectorSimilarity ?? 0.5;
     const lm = signals.levelMatch ?? 0.5;
     const sm = signals.specialtyMatch ?? 0.5;
     const ts = signals.techStackMatch ?? 0.5;
     const fm = signals.functionMatch ?? 0.5;
     const tf = signals.trajectoryFit ?? 0.5;
     const cp = signals.companyPedigree ?? 0.5;

     let score = 0;
     score += vs * weights.vectorSimilarity;
     score += lm * weights.levelMatch;
     score += sm * weights.specialtyMatch;
     score += ts * weights.techStackMatch;
     score += fm * weights.functionMatch;
     score += tf * weights.trajectoryFit;
     score += cp * weights.companyPedigree;

     // Handle optional skillsMatch if both signal and weight exist
     if (signals.skillsMatch !== undefined && weights.skillsMatch) {
       score += signals.skillsMatch * weights.skillsMatch;
     }

     return score;
   }
   ```

3. **extractSignalScores function** - Extract scores from hybrid search row:
   ```typescript
   /**
    * Extracts signal scores from a PgHybridSearchRow.
    * Normalizes vector score to 0-1 range (database may return 0-100 or 0-1).
    *
    * @param row - Database row with scores
    * @returns SignalScores with all signals extracted and normalized
    */
   export function extractSignalScores(row: PgHybridSearchRow): SignalScores {
     // Normalize vector score to 0-1 (handle both 0-100 and 0-1 scales)
     const rawVector = Number(row.vector_score ?? 0);
     const vectorSimilarity = rawVector > 1 ? rawVector / 100 : rawVector;

     // Extract profile-based scores from metadata if available
     // These will be populated by Phase 2 scoring or default to 0.5
     const profile = row.profile as Record<string, unknown> | null;
     const metadata = row.metadata as Record<string, unknown> | null;

     return {
       vectorSimilarity,
       levelMatch: extractScore(metadata, '_level_score'),
       specialtyMatch: extractScore(metadata, '_specialty_score'),
       techStackMatch: extractScore(metadata, '_tech_stack_score'),
       functionMatch: extractScore(metadata, '_function_title_score'),
       trajectoryFit: extractScore(metadata, '_trajectory_score'),
       companyPedigree: extractScore(metadata, '_company_score')
     };
   }

   /**
    * Helper to extract a score from metadata, defaulting to 0.5 if not found.
    */
   function extractScore(
     obj: Record<string, unknown> | null | undefined,
     key: string,
     defaultValue = 0.5
   ): number {
     if (!obj) return defaultValue;
     const value = obj[key];
     if (typeof value === 'number' && Number.isFinite(value)) {
       // Normalize to 0-1 if in 0-100 range
       return value > 1 ? value / 100 : value;
     }
     return defaultValue;
   }
   ```

4. **normalizeVectorScore utility** (exported):
   ```typescript
   /**
    * Normalizes a vector similarity score to 0-1 range.
    * Handles both 0-100 and 0-1 input scales.
    */
   export function normalizeVectorScore(score: number | null | undefined): number {
     const value = Number(score ?? 0);
     if (!Number.isFinite(value)) return 0;
     return value > 1 ? value / 100 : value;
   }
   ```

Export all functions and re-export SignalScores type for convenience.
  </action>
  <verify>
- `npm run typecheck --prefix services/hh-search-svc` passes
- `grep "computeWeightedScore" services/hh-search-svc/src/scoring.ts` shows function export
- `grep "extractSignalScores" services/hh-search-svc/src/scoring.ts` shows function export
  </verify>
  <done>
- computeWeightedScore handles all 7 signals plus optional skillsMatch
- extractSignalScores extracts scores from PgHybridSearchRow
- Missing signals default to 0.5 (neutral) preventing NaN
- normalizeVectorScore handles both 0-100 and 0-1 scales
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npm run typecheck --prefix services/hh-search-svc`
2. Import chain: Verify scoring.ts imports work correctly from types.ts and signal-weights.ts
3. Manual review: Check that SignalScores interface matches Phase 2 score field names
</verification>

<success_criteria>
- HybridSearchRequest accepts signalWeights and roleType fields
- HybridSearchResultItem includes signalScores, weightsApplied, roleTypeUsed fields
- computeWeightedScore correctly computes weighted sum with missing signal defaults
- extractSignalScores normalizes vector scores to 0-1 range
- All TypeScript types compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-signal-scoring-framework/04-02-SUMMARY.md`
</output>
