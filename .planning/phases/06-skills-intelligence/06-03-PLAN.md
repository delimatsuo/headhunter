---
phase: 06-skills-intelligence
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - functions/src/vector-search.ts
  - functions/src/skill-aware-search.ts
autonomous: true

must_haves:
  truths:
    - "Searching for Python returns candidates who have Django or Flask (related skills)"
    - "Related skills are flagged with relationship type (exact, related, inferred, transferable)"
    - "Skills inference detects implied skills from job titles during search"
  artifacts:
    - path: "functions/src/vector-search.ts"
      provides: "Skill-aware search with expansion and inference integration"
      contains: "expandSkills"
    - path: "functions/src/skill-aware-search.ts"
      provides: "Search API with skill match metadata"
      contains: "matchType"
  key_links:
    - from: "functions/src/vector-search.ts"
      to: "functions/src/shared/skills-service.ts"
      via: "imports expandSkills, getCachedSkillExpansion"
      pattern: "import.*expandSkills.*from.*skills-service"
    - from: "functions/src/skill-aware-search.ts"
      to: "functions/src/shared/skills-service.ts"
      via: "imports inferSkillsFromTitle, findTransferableSkills"
      pattern: "import.*inferSkillsFromTitle.*from.*skills-service"
---

<objective>
Integrate skill expansion and inference into the search pipeline so searches return candidates with related, inferred, and transferable skills.

Purpose: Enable "Python" searches to find Django/Flask users, and surface transferable skill opportunities with confidence metadata.

Output: Modified vector-search.ts and skill-aware-search.ts with skill intelligence integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-skills-intelligence/06-RESEARCH.md
@.planning/phases/06-skills-intelligence/06-01-SUMMARY.md
@.planning/phases/06-skills-intelligence/06-02-SUMMARY.md
@functions/src/vector-search.ts
@functions/src/skill-aware-search.ts
@functions/src/shared/skills-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add skill expansion to findMatchingSkill in vector-search.ts</name>
  <files>functions/src/vector-search.ts</files>
  <action>
Enhance `findMatchingSkill()` in vector-search.ts to use skill expansion:

1. **Update imports at top of file:**
```typescript
import {
  normalizeSkillName,
  skillsMatch,
  getCachedSkillExpansion,
  type SkillExpansionResult
} from './shared/skills-service';
```

2. **Add SkillMatchResult type (add near other interfaces):**
```typescript
interface SkillMatchResult {
  skill: string;
  confidence: number;
  matchType: 'exact' | 'alias' | 'related' | 'partial';
  distance?: number;  // Graph distance for related matches
  reasoning?: string; // Why this matched
}
```

3. **Modify findMatchingSkill() signature and implementation:**

Change from:
```typescript
private findMatchingSkill(candidateSkills: Array<{...}>, targetSkill: string): { skill: string, confidence: number } | null
```

To:
```typescript
private findMatchingSkill(
  candidateSkills: Array<{ skill: string, confidence: number, source: string, category: string }>,
  targetSkill: string,
  useExpansion: boolean = true
): SkillMatchResult | null
```

4. **Update implementation:**
```typescript
private findMatchingSkill(
  candidateSkills: Array<{ skill: string, confidence: number, source: string, category: string }>,
  targetSkill: string,
  useExpansion: boolean = true
): SkillMatchResult | null {
  // 1. Exact match via alias normalization (e.g., "JS" matches "JavaScript")
  const aliasMatch = candidateSkills.find(s => skillsMatch(s.skill, targetSkill));
  if (aliasMatch) {
    return {
      skill: aliasMatch.skill,
      confidence: aliasMatch.confidence,
      matchType: 'exact',
      reasoning: 'Direct skill match'
    };
  }

  // 2. Related skill match via graph expansion
  if (useExpansion) {
    const expansion = getCachedSkillExpansion(targetSkill, 2);

    for (const related of expansion.relatedSkills) {
      const relatedMatch = candidateSkills.find(s =>
        skillsMatch(s.skill, related.skillName)
      );

      if (relatedMatch) {
        // Apply confidence decay: candidate confidence * expansion confidence
        const effectiveConfidence = relatedMatch.confidence * related.confidence;
        return {
          skill: relatedMatch.skill,
          confidence: effectiveConfidence,
          matchType: 'related',
          distance: related.distance,
          reasoning: `Related to ${targetSkill} via ${related.relationshipType} relationship`
        };
      }
    }
  }

  // 3. Partial match (skill contains target or vice versa) - only for 3+ characters
  if (targetSkill.length >= 3) {
    const target = targetSkill.toLowerCase();
    const partialMatch = candidateSkills.find(s =>
      s.skill.includes(target) || target.includes(s.skill)
    );
    if (partialMatch) {
      return {
        skill: partialMatch.skill,
        confidence: partialMatch.confidence * 0.8,
        matchType: 'partial',
        reasoning: 'Partial string match'
      };
    }
  }

  return null;
}
```

5. **Update callers of findMatchingSkill() in calculateSkillAwareScores():**
The existing code uses:
```typescript
const candidateSkill = this.findMatchingSkill(candidateSkills, requiredSkill.skill);
if (candidateSkill) {
  const confidence = candidateSkill.confidence;
```

This continues to work because the return type still has `skill` and `confidence`. No changes needed to calling code.
  </action>
  <verify>
```bash
cd "/Volumes/Extreme Pro/myprojects/headhunter/functions"
npx tsc --noEmit
```
TypeScript compilation passes.
  </verify>
  <done>
- getCachedSkillExpansion imported from skills-service
- SkillMatchResult interface added with matchType field
- findMatchingSkill() uses skill expansion for related matches
- Confidence decay applied (candidate * expansion confidence)
- TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add skill inference to search in skill-aware-search.ts</name>
  <files>functions/src/skill-aware-search.ts</files>
  <action>
Enhance skill-aware-search.ts to use job title inference and transferable skills:

1. **Update imports:**
```typescript
import {
  normalizeSkillName,
  inferSkillsFromTitle,
  findTransferableSkills,
  type InferredSkill,
  type TransferableSkill
} from './shared/skills-service';
```

2. **Modify extractSkillProfile() to include inferred skills from title:**

In the extractSkillProfile method, add job title inference:

```typescript
private extractSkillProfile(candidateData: any): {
  skills: Record<string, { confidence: number; category: string; evidence: string[]; matchType?: string }>;
  average_confidence: number;
  skill_categories: Record<string, number>;
  transferableSkills?: TransferableSkill[];
} {
  const skills: Record<string, { confidence: number; category: string; evidence: string[]; matchType?: string }> = {};
  const skillCategories: Record<string, number> = {};

  // ... existing explicit and inferred skill extraction code ...

  // NEW: Infer skills from current job title
  const currentTitle = candidateData.current_role ||
                       candidateData.professional?.current_title ||
                       candidateData.intelligent_analysis?.career_trajectory_analysis?.current_level || '';

  if (currentTitle) {
    const titleInferred = inferSkillsFromTitle(currentTitle);
    for (const inferred of titleInferred) {
      const skillName = normalizeSkillName(inferred.skill);

      // Only add if not already present with higher confidence
      if (!skills[skillName] || skills[skillName].confidence < inferred.confidence * 100) {
        skills[skillName] = {
          confidence: inferred.confidence * 100,  // Convert 0-1 to 0-100
          category: 'technical',
          evidence: [inferred.reasoning],
          matchType: 'inferred'
        };
        skillCategories['inferred'] = (skillCategories['inferred'] || 0) + 1;
      }
    }
  }

  // NEW: Detect transferable skills
  const explicitSkillNames = Object.keys(skills);
  const transferableSkills = findTransferableSkills(explicitSkillNames);

  // ... rest of existing code ...

  return {
    skills,
    average_confidence: avgConfidence,
    skill_categories: skillCategories,
    transferableSkills
  };
}
```

3. **Modify calculateSkillMatch() to use matchType in scoring:**

```typescript
private calculateSkillMatch(
  candidateSkills: Record<string, any>,
  requiredSkills: SkillRequirement[]
): number {
  if (requiredSkills.length === 0) {
    return 80;
  }

  let totalScore = 0;
  let totalWeight = 0;

  for (const requirement of requiredSkills) {
    const normalizedSkill = normalizeSkillName(requirement.skill);
    totalWeight += requirement.weight;

    if (candidateSkills[normalizedSkill]) {
      const skillData = candidateSkills[normalizedSkill];

      // Apply match type penalty
      let matchTypeMultiplier = 1.0;
      if (skillData.matchType === 'inferred') {
        matchTypeMultiplier = 0.85;  // 15% penalty for inferred skills
      } else if (skillData.matchType === 'related') {
        matchTypeMultiplier = 0.9;   // 10% penalty for related skills
      }

      if (skillData.confidence >= requirement.minimum_confidence) {
        totalScore += skillData.confidence * requirement.weight * matchTypeMultiplier;
      } else {
        totalScore += skillData.confidence * 0.5 * requirement.weight * matchTypeMultiplier;
      }
    } else {
      // ... existing related skills fallback code ...
    }
  }

  return totalWeight > 0 ? totalScore / totalWeight : 0;
}
```
  </action>
  <verify>
```bash
cd "/Volumes/Extreme Pro/myprojects/headhunter/functions"
npx tsc --noEmit
```
TypeScript compilation passes.
  </verify>
  <done>
- inferSkillsFromTitle and findTransferableSkills imported
- extractSkillProfile() adds inferred skills from job title
- Inferred skills marked with matchType: 'inferred'
- Transferable skills detected and returned
- Match type affects scoring (exact > related > inferred)
- TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 3: Add skill match metadata to search results</name>
  <files>functions/src/vector-search.ts</files>
  <action>
Enhance search results to include skill match metadata showing match types:

1. **Add to SkillAwareSearchResult interface (in vector-search.ts):**

Find the SkillAwareSearchResult interface and add:
```typescript
interface SkillAwareSearchResult {
  // ... existing fields ...
  skill_match_details?: Array<{
    queriedSkill: string;
    matchedSkill: string;
    matchType: 'exact' | 'alias' | 'related' | 'inferred' | 'transferable' | 'partial';
    confidence: number;
    reasoning?: string;
  }>;
  transferable_opportunities?: Array<{
    fromSkill: string;
    toSkill: string;
    transferabilityScore: number;
    reasoning: string;
  }>;
}
```

2. **Update calculateSkillAwareScores() to return match details:**

Modify the return type and implementation to track match details:

```typescript
private calculateSkillAwareScores(candidateData: any, query: SkillAwareSearchQuery): {
  skill_match_score: number;
  confidence_score: number;
  experience_match_score: number;
  skill_breakdown: Record<string, number>;
  ranking_factors: SkillAwareSearchResult['ranking_factors'];
  skill_match_details: SkillAwareSearchResult['skill_match_details'];
  transferable_opportunities: SkillAwareSearchResult['transferable_opportunities'];
} {
  const candidateSkills = this.extractCandidateSkills(candidateData);
  const requiredSkills = query.required_skills || [];
  const preferredSkills = query.preferred_skills || [];

  const skillMatchDetails: NonNullable<SkillAwareSearchResult['skill_match_details']> = [];

  // ... existing scoring code, but track match details ...

  for (const requiredSkill of requiredSkills) {
    const match = this.findMatchingSkill(candidateSkills, requiredSkill.skill, true);

    if (match) {
      skillMatchDetails.push({
        queriedSkill: requiredSkill.skill,
        matchedSkill: match.skill,
        matchType: match.matchType,
        confidence: match.confidence,
        reasoning: match.reasoning
      });
      // ... existing scoring logic ...
    }
  }

  // Get transferable skills from candidate's existing skills
  const candidateSkillNames = candidateSkills.map(s => s.skill);
  const transferable = findTransferableSkills(candidateSkillNames)
    .slice(0, 5)  // Top 5 opportunities
    .map(t => ({
      fromSkill: t.fromSkill,
      toSkill: t.toSkill,
      transferabilityScore: t.transferabilityScore,
      reasoning: t.reasoning
    }));

  return {
    // ... existing fields ...
    skill_match_details: skillMatchDetails,
    transferable_opportunities: transferable
  };
}
```

3. **Pass through to searchCandidatesSkillAware() results:**

In the enrichedResults.push() call, add:
```typescript
enrichedResults.push({
  // ... existing fields ...
  skill_match_details: skillScores.skill_match_details,
  transferable_opportunities: skillScores.transferable_opportunities,
});
```

4. **Import findTransferableSkills at top:**
```typescript
import {
  normalizeSkillName,
  skillsMatch,
  getCachedSkillExpansion,
  findTransferableSkills,
  type SkillExpansionResult
} from './shared/skills-service';
```
  </action>
  <verify>
```bash
cd "/Volumes/Extreme Pro/myprojects/headhunter/functions"
npx tsc --noEmit
```
TypeScript compilation passes.
  </verify>
  <done>
- skill_match_details array in search results shows match types
- transferable_opportunities shows career pivot potential
- Each matched skill includes: queriedSkill, matchedSkill, matchType, confidence, reasoning
- findTransferableSkills imported and used
- TypeScript compiles cleanly
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd functions && npx tsc --noEmit`
2. No runtime errors: `cd functions && npm run build`
3. Check expanded search results include match metadata
</verification>

<success_criteria>
1. findMatchingSkill() uses skill expansion to find related skill matches
2. extractSkillProfile() infers skills from job titles
3. Search results include skill_match_details with match types
4. Search results include transferable_opportunities
5. Match types affect scoring (exact > related > inferred)
6. TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/06-skills-intelligence/06-03-SUMMARY.md`
</output>
