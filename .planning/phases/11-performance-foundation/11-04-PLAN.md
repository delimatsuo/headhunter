---
phase: 11-performance-foundation
plan: 04
type: execute
wave: 2
depends_on: ["11-02"]
files_modified:
  - services/hh-search-svc/src/redis-client.ts
  - services/hh-search-svc/src/cache-strategy.ts
  - services/hh-search-svc/src/config.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Multi-layer cache exists: search results, rerank scores, specialty lookups"
    - "Cache keys include tenant ID for multi-tenant isolation"
    - "TTLs are randomized with jitter to prevent cache stampede"
    - "Cache hit rate is tracked and logged"
  artifacts:
    - path: "services/hh-search-svc/src/cache-strategy.ts"
      provides: "Multi-layer caching with invalidation"
      exports: ["CacheStrategy", "CacheLayer"]
    - path: "services/hh-search-svc/src/redis-client.ts"
      provides: "Enhanced Redis client with TTL jitter"
      contains: "setWithJitter"
  key_links:
    - from: "services/hh-search-svc/src/cache-strategy.ts"
      to: "services/hh-search-svc/src/redis-client.ts"
      via: "Redis operations"
      pattern: "redisClient"
---

<objective>
Implement multi-layer Redis caching strategy with TTL jitter and cache hit tracking.

Purpose: Strategic caching at multiple layers (search results, rerank scores, embeddings) dramatically reduces latency for repeated searches, with cache hits returning in under 50ms.
Output: Cache strategy module with multi-layer support, TTL jitter, and hit rate tracking.
</objective>

<execution_context>
@/Users/delimatsuo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/delimatsuo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-performance-foundation/11-RESEARCH.md
@services/hh-search-svc/src/redis-client.ts
@services/hh-search-svc/src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TTL jitter and cache metrics to Redis client</name>
  <files>services/hh-search-svc/src/redis-client.ts</files>
  <action>
    Enhance SearchRedisClient with TTL jitter and cache metrics:

    1. Add cache metrics tracking:
    ```typescript
    interface CacheMetrics {
      hits: number;
      misses: number;
      sets: number;
      deletes: number;
    }

    export class SearchRedisClient {
      private client: Redis | Cluster | null = null;
      private metrics: CacheMetrics = { hits: 0, misses: 0, sets: 0, deletes: 0 };
      // ... existing code
    ```

    2. Add setWithJitter method:
    ```typescript
    /**
     * Set a value with randomized TTL jitter to prevent cache stampede.
     * Jitter adds ±20% variation to the base TTL.
     */
    async setWithJitter<T>(key: string, value: T, baseTtlSeconds?: number): Promise<void> {
      const client = this.createClient();
      if (!client) {
        return;
      }

      const baseTtl = baseTtlSeconds ?? this.config.ttlSeconds;
      // Add ±20% jitter to prevent synchronized expiration
      const jitter = baseTtl * 0.2 * (Math.random() * 2 - 1);
      const ttl = Math.floor(baseTtl + jitter);

      try {
        const payload = JSON.stringify(value);
        if (ttl > 0) {
          await client.setex(key, ttl, payload);
        } else {
          await client.set(key, payload);
        }
        this.metrics.sets++;
      } catch (error) {
        this.logger.error({ error, key }, 'Failed to write to Redis with jitter.');
      }
    }
    ```

    3. Update get() to track cache hits/misses:
    ```typescript
    async get<T>(key: string): Promise<T | null> {
      const client = this.createClient();
      if (!client) {
        return null;
      }

      try {
        const raw = await client.get(key);
        if (!raw) {
          this.metrics.misses++;
          return null;
        }

        this.metrics.hits++;
        return JSON.parse(raw) as T;
      } catch (error) {
        this.logger.error({ error, key }, 'Failed to read from Redis.');
        this.metrics.misses++;
        return null;
      }
    }
    ```

    4. Add getMetrics() method:
    ```typescript
    getMetrics(): CacheMetrics & { hitRate: number } {
      const total = this.metrics.hits + this.metrics.misses;
      const hitRate = total > 0 ? this.metrics.hits / total : 0;
      return {
        ...this.metrics,
        hitRate: Math.round(hitRate * 100) / 100
      };
    }

    resetMetrics(): void {
      this.metrics = { hits: 0, misses: 0, sets: 0, deletes: 0 };
    }
    ```

    5. Update healthCheck to include cache metrics:
    ```typescript
    async healthCheck(): Promise<RedisHealthStatus> {
      // ... existing code
      if (response?.toString().toUpperCase() === 'PONG') {
        return {
          status: 'healthy',
          latencyMs: latency,
          metrics: this.getMetrics()
        } satisfies RedisHealthStatus;
      }
    }
    ```

    6. Update RedisHealthStatus interface:
    ```typescript
    export interface RedisHealthStatus {
      status: 'healthy' | 'degraded' | 'disabled' | 'unavailable';
      latencyMs?: number;
      message?: string;
      metrics?: CacheMetrics & { hitRate: number };
    }
    ```
  </action>
  <verify>
    Run: `npm run build --prefix services/hh-search-svc`
    Run: `npm test --prefix services/hh-search-svc -- --grep "redis"`
    Expected: Build succeeds, existing Redis tests pass
  </verify>
  <done>Redis client has TTL jitter, cache hit/miss tracking, and metrics endpoint</done>
</task>

<task type="auto">
  <name>Task 2: Create multi-layer cache strategy module</name>
  <files>services/hh-search-svc/src/cache-strategy.ts</files>
  <action>
    Create a new module for multi-layer caching:

    ```typescript
    import type { Logger } from 'pino';
    import type { SearchRedisClient } from './redis-client';

    /**
     * Cache layer configuration with TTL and invalidation strategy.
     */
    export interface CacheLayerConfig {
      /** Base TTL in seconds */
      ttlSeconds: number;
      /** Whether to use TTL jitter */
      useJitter: boolean;
      /** Key prefix for this layer */
      keyPrefix: string;
    }

    /**
     * Predefined cache layers with recommended TTLs.
     * Based on research: different data types have different staleness tolerance.
     */
    export const CacheLayers = {
      SEARCH_RESULTS: {
        ttlSeconds: 600,      // 10 minutes - balance freshness vs hit rate
        useJitter: true,
        keyPrefix: 'search'
      },
      RERANK_SCORES: {
        ttlSeconds: 21600,    // 6 hours - expensive to compute, rarely changes
        useJitter: true,
        keyPrefix: 'rerank'
      },
      SPECIALTY_LOOKUP: {
        ttlSeconds: 86400,    // 24 hours - static reference data
        useJitter: false,
        keyPrefix: 'specialty'
      },
      EMBEDDING: {
        ttlSeconds: 3600,     // 1 hour - query embeddings
        useJitter: true,
        keyPrefix: 'embedding'
      }
    } as const satisfies Record<string, CacheLayerConfig>;

    export type CacheLayerName = keyof typeof CacheLayers;

    /**
     * Multi-layer cache strategy for search operations.
     * Each layer has its own TTL and invalidation strategy.
     */
    export class CacheStrategy {
      constructor(
        private readonly redisClient: SearchRedisClient,
        private readonly logger: Logger
      ) {}

      /**
       * Build a cache key for a specific layer with tenant isolation.
       */
      buildKey(layer: CacheLayerName, tenantId: string, identifier: string): string {
        const config = CacheLayers[layer];
        return `hh:${config.keyPrefix}:${tenantId}:${identifier}`;
      }

      /**
       * Get a value from a specific cache layer.
       */
      async get<T>(layer: CacheLayerName, tenantId: string, identifier: string): Promise<T | null> {
        if (this.redisClient.isDisabled()) {
          return null;
        }

        const key = this.buildKey(layer, tenantId, identifier);
        const value = await this.redisClient.get<T>(key);

        this.logger.debug(
          { layer, tenantId, hit: value !== null },
          'Cache lookup'
        );

        return value;
      }

      /**
       * Set a value in a specific cache layer with appropriate TTL.
       */
      async set<T>(layer: CacheLayerName, tenantId: string, identifier: string, value: T): Promise<void> {
        if (this.redisClient.isDisabled()) {
          return;
        }

        const config = CacheLayers[layer];
        const key = this.buildKey(layer, tenantId, identifier);

        if (config.useJitter) {
          await this.redisClient.setWithJitter(key, value, config.ttlSeconds);
        } else {
          await this.redisClient.set(key, value, config.ttlSeconds);
        }

        this.logger.debug(
          { layer, tenantId, ttl: config.ttlSeconds, jitter: config.useJitter },
          'Cache set'
        );
      }

      /**
       * Invalidate a specific cache entry.
       */
      async invalidate(layer: CacheLayerName, tenantId: string, identifier: string): Promise<void> {
        if (this.redisClient.isDisabled()) {
          return;
        }

        const key = this.buildKey(layer, tenantId, identifier);
        await this.redisClient.delete(key);

        this.logger.debug({ layer, tenantId, key }, 'Cache invalidated');
      }

      /**
       * Invalidate all cache entries for a tenant in a specific layer.
       * Note: This uses SCAN which can be expensive - use sparingly.
       */
      async invalidateTenantLayer(layer: CacheLayerName, tenantId: string): Promise<number> {
        if (this.redisClient.isDisabled()) {
          return 0;
        }

        const config = CacheLayers[layer];
        const pattern = `hh:${config.keyPrefix}:${tenantId}:*`;

        // Get all matching keys (note: this can be expensive)
        const keys = await this.redisClient.scanKeys(pattern);
        if (keys.length === 0) {
          return 0;
        }

        // Delete in batches
        for (const key of keys) {
          await this.redisClient.delete(key);
        }

        this.logger.info(
          { layer, tenantId, keysDeleted: keys.length },
          'Tenant cache layer invalidated'
        );

        return keys.length;
      }
    }
    ```
  </action>
  <verify>
    Run: `npm run build --prefix services/hh-search-svc`
    Expected: New module compiles without errors
  </verify>
  <done>Multi-layer cache strategy module exists with predefined layers and TTLs</done>
</task>

<task type="auto">
  <name>Task 3: Add scanKeys method to Redis client and configure TTLs</name>
  <files>services/hh-search-svc/src/redis-client.ts, services/hh-search-svc/src/config.ts</files>
  <action>
    1. Add scanKeys method to SearchRedisClient:
    ```typescript
    /**
     * Scan for keys matching a pattern.
     * Uses SCAN to avoid blocking Redis with KEYS command.
     * Note: Returns up to 1000 keys - for larger sets, use cursor.
     */
    async scanKeys(pattern: string, limit: number = 1000): Promise<string[]> {
      const client = this.createClient();
      if (!client) {
        return [];
      }

      try {
        const keys: string[] = [];
        let cursor = '0';

        do {
          // SCAN returns [cursor, keys[]]
          const result = await client.scan(cursor, 'MATCH', pattern, 'COUNT', 100);
          cursor = result[0];
          keys.push(...result[1]);

          if (keys.length >= limit) {
            break;
          }
        } while (cursor !== '0');

        return keys.slice(0, limit);
      } catch (error) {
        this.logger.error({ error, pattern }, 'Failed to scan Redis keys.');
        return [];
      }
    }
    ```

    2. Add cache TTL configuration to config.ts RedisCacheConfig:
    ```typescript
    export interface RedisCacheConfig {
      // ... existing fields
      /** Search results cache TTL in seconds (default: 600 = 10 min) */
      searchResultsTtlSeconds: number;
      /** Rerank scores cache TTL in seconds (default: 21600 = 6 hours) */
      rerankScoresTtlSeconds: number;
      /** Specialty lookup cache TTL in seconds (default: 86400 = 24 hours) */
      specialtyLookupTtlSeconds: number;
      /** Embedding cache TTL in seconds (default: 3600 = 1 hour) */
      embeddingTtlSeconds: number;
    }
    ```

    3. Parse the new config values:
    ```typescript
    const redis: RedisCacheConfig = {
      // ... existing fields
      searchResultsTtlSeconds: parseNumber(process.env.CACHE_SEARCH_RESULTS_TTL, 600),
      rerankScoresTtlSeconds: parseNumber(process.env.CACHE_RERANK_SCORES_TTL, 21600),
      specialtyLookupTtlSeconds: parseNumber(process.env.CACHE_SPECIALTY_LOOKUP_TTL, 86400),
      embeddingTtlSeconds: parseNumber(process.env.CACHE_EMBEDDING_TTL, 3600),
    };
    ```

    4. Update CacheLayers to use config values (in cache-strategy.ts):
    ```typescript
    /**
     * Create cache layers with configuration from environment.
     */
    export function createCacheLayers(config: RedisCacheConfig): Record<CacheLayerName, CacheLayerConfig> {
      return {
        SEARCH_RESULTS: {
          ttlSeconds: config.searchResultsTtlSeconds,
          useJitter: true,
          keyPrefix: 'search'
        },
        RERANK_SCORES: {
          ttlSeconds: config.rerankScoresTtlSeconds,
          useJitter: true,
          keyPrefix: 'rerank'
        },
        SPECIALTY_LOOKUP: {
          ttlSeconds: config.specialtyLookupTtlSeconds,
          useJitter: false,
          keyPrefix: 'specialty'
        },
        EMBEDDING: {
          ttlSeconds: config.embeddingTtlSeconds,
          useJitter: true,
          keyPrefix: 'embedding'
        }
      };
    }
    ```
  </action>
  <verify>
    Run: `npm run build --prefix services/hh-search-svc`
    Run: `npm test --prefix services/hh-search-svc`
    Expected: Build succeeds, all tests pass
  </verify>
  <done>Cache TTLs are configurable via environment and scanKeys method enables invalidation</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Existing tests continue to pass
3. TTL jitter adds ±20% variation
4. Cache metrics track hits, misses, sets, deletes
5. Cache layers have appropriate TTL defaults
6. Multi-tenant isolation via key prefixes
</verification>

<success_criteria>
- TTL jitter implemented with setWithJitter method
- Cache metrics (hit rate) tracked and available via health check
- Multi-layer cache strategy with configurable TTLs
- Search results: 10 min, Rerank: 6 hours, Specialty: 24 hours, Embedding: 1 hour
- Tenant isolation in cache keys
</success_criteria>

<output>
After completion, create `.planning/phases/11-performance-foundation/11-04-SUMMARY.md`
</output>
