---
phase: 11-performance-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/hh-search-svc/src/config.ts
  - services/hh-search-svc/src/pgvector-client.ts
  - scripts/migrations/011_pgvectorscale_extension.sql
  - scripts/migrations/012_streamingdiskann_index.sql
autonomous: true
user_setup: []

must_haves:
  truths:
    - "pgvectorscale extension is installed and enabled on PostgreSQL"
    - "StreamingDiskANN index exists alongside HNSW index"
    - "Feature flag controls which index type is used at query time"
    - "Index type can be switched without code deployment"
  artifacts:
    - path: "scripts/migrations/011_pgvectorscale_extension.sql"
      provides: "Extension installation SQL"
      contains: "CREATE EXTENSION"
    - path: "scripts/migrations/012_streamingdiskann_index.sql"
      provides: "StreamingDiskANN index creation"
      contains: "diskann"
    - path: "services/hh-search-svc/src/config.ts"
      provides: "Index type configuration"
      contains: "PGVECTOR_INDEX_TYPE"
    - path: "services/hh-search-svc/src/pgvector-client.ts"
      provides: "Index-aware query execution"
      contains: "diskann.query_search_list_size"
  key_links:
    - from: "services/hh-search-svc/src/pgvector-client.ts"
      to: "services/hh-search-svc/src/config.ts"
      via: "config.indexType field"
      pattern: "indexType.*diskann"
---

<objective>
Install pgvectorscale extension and create StreamingDiskANN index for 28x vector search latency improvement.

Purpose: StreamingDiskANN provides 28x better latency than HNSW at 99% recall, forming the cornerstone of Phase 11 performance optimization.
Output: PostgreSQL migrations, feature flag configuration, and index-aware query logic.
</objective>

<execution_context>
@/Users/delimatsuo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/delimatsuo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-performance-foundation/11-RESEARCH.md
@services/hh-search-svc/src/config.ts
@services/hh-search-svc/src/pgvector-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pgvectorscale extension migration</name>
  <files>scripts/migrations/011_pgvectorscale_extension.sql</files>
  <action>
    Create SQL migration to install pgvectorscale extension:

    ```sql
    -- Migration: 011_pgvectorscale_extension.sql
    -- Install pgvectorscale for StreamingDiskANN indices
    -- Requires pgvector extension to be installed first

    -- Check if pgvector is installed
    DO $$
    BEGIN
      IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'vector') THEN
        RAISE EXCEPTION 'pgvector extension must be installed before pgvectorscale';
      END IF;
    END $$;

    -- Install pgvectorscale (provides StreamingDiskANN index type)
    CREATE EXTENSION IF NOT EXISTS vectorscale CASCADE;

    -- Verify installation
    DO $$
    BEGIN
      IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'vectorscale') THEN
        RAISE EXCEPTION 'Failed to install vectorscale extension';
      END IF;
      RAISE NOTICE 'pgvectorscale extension installed successfully';
    END $$;
    ```

    Note: If Cloud SQL doesn't support vectorscale, the migration should fail gracefully with a clear error message.
  </action>
  <verify>
    Run: `psql -f scripts/migrations/011_pgvectorscale_extension.sql` on local PostgreSQL
    Expected: "pgvectorscale extension installed successfully" notice
  </verify>
  <done>Migration file exists and can be executed on PostgreSQL with pgvector installed</done>
</task>

<task type="auto">
  <name>Task 2: Create StreamingDiskANN index migration</name>
  <files>scripts/migrations/012_streamingdiskann_index.sql</files>
  <action>
    Create SQL migration for StreamingDiskANN index alongside existing HNSW:

    ```sql
    -- Migration: 012_streamingdiskann_index.sql
    -- Create StreamingDiskANN index for candidate embeddings
    -- Runs alongside existing HNSW index for A/B testing

    -- Create StreamingDiskANN index (if vectorscale is available)
    DO $$
    BEGIN
      IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'vectorscale') THEN
        -- Drop existing diskann index if it exists (for re-runs)
        DROP INDEX IF EXISTS search.candidate_embeddings_embedding_diskann_idx;

        -- Create StreamingDiskANN index with tuned parameters
        -- num_neighbors: Graph degree (higher = better recall, more memory)
        -- search_list_size: Search depth (tunable at query time)
        -- max_alpha: Pruning aggressiveness
        -- num_bits_per_dimension: SBQ compression (2 = high quality)
        EXECUTE 'CREATE INDEX candidate_embeddings_embedding_diskann_idx
          ON search.candidate_embeddings
          USING diskann (embedding)
          WITH (
            num_neighbors = 50,
            search_list_size = 100,
            max_alpha = 1.2,
            num_bits_per_dimension = 2
          )';

        RAISE NOTICE 'StreamingDiskANN index created successfully';
      ELSE
        RAISE NOTICE 'vectorscale extension not available, skipping diskann index';
      END IF;
    END $$;

    -- Verify index creation
    SELECT indexname, indexdef
    FROM pg_indexes
    WHERE schemaname = 'search'
      AND tablename = 'candidate_embeddings'
      AND indexdef LIKE '%diskann%';
    ```

    Parameters chosen based on research:
    - num_neighbors=50: Balanced for 23K candidates with room to scale
    - search_list_size=100: Good default, can increase at query time for better recall
    - max_alpha=1.2: Standard pruning aggressiveness
    - num_bits_per_dimension=2: High quality SBQ compression
  </action>
  <verify>
    Run: `psql -f scripts/migrations/012_streamingdiskann_index.sql` after 011
    Expected: Index appears in pg_indexes with diskann type
  </verify>
  <done>StreamingDiskANN index migration file exists and creates index when vectorscale is available</done>
</task>

<task type="auto">
  <name>Task 3: Add index type configuration and query-time tuning</name>
  <files>services/hh-search-svc/src/config.ts, services/hh-search-svc/src/pgvector-client.ts</files>
  <action>
    Update config.ts to add index type configuration:

    1. Add to PgVectorConfig interface:
    ```typescript
    /** Index type to use for vector search: 'hnsw' | 'diskann' */
    indexType: 'hnsw' | 'diskann';
    /** StreamingDiskANN search list size (runtime tuning) */
    diskannSearchListSize: number;
    ```

    2. Add parsing in getSearchServiceConfig():
    ```typescript
    indexType: (process.env.PGVECTOR_INDEX_TYPE ?? 'hnsw') as 'hnsw' | 'diskann',
    diskannSearchListSize: parseNumber(process.env.DISKANN_SEARCH_LIST_SIZE, 100),
    ```

    Update pgvector-client.ts to use index type at query time:

    1. In hybridSearch() method, before executing the query, add:
    ```typescript
    // Set index-specific runtime parameters
    if (this.config.indexType === 'diskann') {
      const searchListSize = this.config.diskannSearchListSize;
      if (searchListSize > 0) {
        await client.query(`SET LOCAL diskann.query_search_list_size = ${Math.floor(searchListSize)}`);
      }
      this.logger.debug({ indexType: 'diskann', searchListSize }, 'Using StreamingDiskANN index');
    } else if (efSearch && Number.isFinite(efSearch) && efSearch > 0) {
      await client.query(`SET LOCAL hnsw.ef_search = ${Math.floor(efSearch)}`);
      this.logger.debug({ indexType: 'hnsw', efSearch }, 'Using HNSW index');
    }
    ```

    2. Add indexType to hybridSearch logging for observability:
    ```typescript
    this.logger.info({
      indexType: this.config.indexType,
      // ... existing fields
    }, 'RRF hybrid search summary');
    ```

    3. Update health check to report index type.
  </action>
  <verify>
    Run: `npm run build --prefix services/hh-search-svc`
    Run: `npm test --prefix services/hh-search-svc -- --grep "config"`
    Expected: Build succeeds, config tests pass with new fields
  </verify>
  <done>Index type is configurable via PGVECTOR_INDEX_TYPE env var and query-time tuning is applied</done>
</task>

</tasks>

<verification>
1. Migration files exist in scripts/migrations/
2. TypeScript compiles without errors
3. Config parsing tests pass
4. Local PostgreSQL accepts migrations (if vectorscale available)
5. Health check reports index type
</verification>

<success_criteria>
- pgvectorscale extension migration file created
- StreamingDiskANN index migration file created
- Config supports PGVECTOR_INDEX_TYPE=diskann|hnsw
- Query-time tuning applied based on index type
- Logging includes index type for observability
</success_criteria>

<output>
After completion, create `.planning/phases/11-performance-foundation/11-01-SUMMARY.md`
</output>
