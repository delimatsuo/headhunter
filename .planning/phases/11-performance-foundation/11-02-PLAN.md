---
phase: 11-performance-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - services/hh-search-svc/src/config.ts
  - services/hh-search-svc/src/pgvector-client.ts
  - services/hh-search-svc/src/search-service.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Connection pool is tuned for production workload (poolMax=20, poolMin=5)"
    - "Pool metrics (wait time, utilization) are exposed in health check"
    - "Connection pool warmup happens during service startup"
    - "Pool saturation triggers warning logs"
  artifacts:
    - path: "services/hh-search-svc/src/config.ts"
      provides: "Production pool configuration defaults"
      contains: "poolMax: 20"
    - path: "services/hh-search-svc/src/pgvector-client.ts"
      provides: "Pool metrics in health check"
      contains: "waitingRequests"
  key_links:
    - from: "services/hh-search-svc/src/pgvector-client.ts"
      to: "pg.Pool"
      via: "pool configuration"
      pattern: "poolMax|poolMin|idleTimeout"
---

<objective>
Tune PostgreSQL connection pooling for production workload and add pool utilization metrics.

Purpose: Proper pool configuration reduces connection overhead and prevents pool saturation under load, contributing 80ms to latency savings.
Output: Updated pool defaults, enhanced health checks with pool metrics, warmup optimization.
</objective>

<execution_context>
@/Users/delimatsuo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/delimatsuo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-performance-foundation/11-RESEARCH.md
@services/hh-search-svc/src/config.ts
@services/hh-search-svc/src/pgvector-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update connection pool defaults for production</name>
  <files>services/hh-search-svc/src/config.ts</files>
  <action>
    Update the pgvector configuration defaults for production workload:

    1. Change poolMax default from 10 to 20:
    ```typescript
    poolMax: parseNumber(process.env.PGVECTOR_POOL_MAX, 20),
    ```

    2. Change poolMin default from 0 to 5 (keep warm connections):
    ```typescript
    poolMin: parseNumber(process.env.PGVECTOR_POOL_MIN, 5),
    ```

    3. Reduce connection timeout for fail-fast behavior:
    ```typescript
    connectionTimeoutMs: parseNumber(process.env.PGVECTOR_CONNECTION_TIMEOUT_MS, 3_000), // 3s fail-fast
    ```

    4. Reduce statement timeout aligned with latency budget:
    ```typescript
    statementTimeoutMs: parseNumber(process.env.PGVECTOR_STATEMENT_TIMEOUT_MS, 10_000), // 10s max
    ```

    5. Increase idle timeout for better connection reuse:
    ```typescript
    idleTimeoutMs: parseNumber(process.env.PGVECTOR_IDLE_TIMEOUT_MS, 60_000), // 60s
    ```

    Rationale from research:
    - poolMax=20: Higher for Cloud Run concurrency (multiple instances)
    - poolMin=5: Keep warm connections to reduce cold-start latency
    - connectionTimeout=3s: Fail fast on connection issues
    - statementTimeout=10s: Aligned with 500ms latency budget allowing retries
    - idleTimeout=60s: Balance between reuse and resource cleanup
  </action>
  <verify>
    Run: `npm run build --prefix services/hh-search-svc`
    Expected: Build succeeds with updated defaults
  </verify>
  <done>Pool configuration defaults updated for production workload</done>
</task>

<task type="auto">
  <name>Task 2: Enhance health check with pool utilization metrics</name>
  <files>services/hh-search-svc/src/pgvector-client.ts</files>
  <action>
    Enhance the PgVectorHealth interface and healthCheck() method:

    1. Add pool utilization fields to PgVectorHealth interface:
    ```typescript
    export interface PgVectorHealth {
      status: 'healthy' | 'degraded' | 'unhealthy';
      totalCandidates: number;
      poolSize: number;
      idleConnections: number;
      waitingRequests: number;
      // New fields for pool monitoring
      poolUtilization: number;  // (poolSize - idleConnections) / poolSize
      poolMax: number;
      poolMin: number;
      message?: string;
    }
    ```

    2. Update healthCheck() to compute and return pool utilization:
    ```typescript
    async healthCheck(): Promise<PgVectorHealth> {
      try {
        await this.initialize();

        const total = await this.withClient(async (client) => {
          const result = await client.query(
            `SELECT COUNT(*) AS total FROM ${this.config.schema}.${this.config.profilesTable}`
          );
          return Number(result.rows[0]?.total ?? 0);
        });

        const poolSize = this.pool.totalCount;
        const idleConnections = this.pool.idleCount ?? 0;
        const waitingRequests = this.pool.waitingCount ?? 0;
        const poolUtilization = poolSize > 0 ? (poolSize - idleConnections) / poolSize : 0;

        // Log warning if pool is under pressure
        if (waitingRequests > 5) {
          this.logger.warn(
            { waitingRequests, poolSize, poolMax: this.config.poolMax },
            'Pool saturation warning: requests waiting for connections'
          );
        }

        return {
          status: waitingRequests > 10 ? 'degraded' : 'healthy',
          totalCandidates: total,
          poolSize,
          idleConnections,
          waitingRequests,
          poolUtilization: Math.round(poolUtilization * 100) / 100,
          poolMax: this.config.poolMax,
          poolMin: this.config.poolMin
        } satisfies PgVectorHealth;
      } catch (error) {
        this.logger.error({ error }, 'pgvector health check failed.');
        return {
          status: 'unhealthy',
          totalCandidates: 0,
          poolSize: this.pool.totalCount,
          idleConnections: this.pool.idleCount ?? 0,
          waitingRequests: this.pool.waitingCount ?? 0,
          poolUtilization: 0,
          poolMax: this.config.poolMax,
          poolMin: this.config.poolMin,
          message: error instanceof Error ? error.message : 'Unknown error'
        } satisfies PgVectorHealth;
      }
    }
    ```

    3. Add pool metrics to hybrid search logging for observability:
    ```typescript
    // At the start of hybridSearch(), after initialization
    const poolMetrics = {
      poolSize: this.pool.totalCount,
      idle: this.pool.idleCount ?? 0,
      waiting: this.pool.waitingCount ?? 0
    };

    // Include in RRF summary log
    this.logger.info({
      // ... existing fields
      poolMetrics
    }, 'RRF hybrid search summary');
    ```
  </action>
  <verify>
    Run: `npm test --prefix services/hh-search-svc -- --grep "health"`
    Run: `npm run build --prefix services/hh-search-svc`
    Expected: Health check tests pass, build succeeds
  </verify>
  <done>Health check reports pool utilization metrics and warns on saturation</done>
</task>

<task type="auto">
  <name>Task 3: Optimize pool warmup during startup</name>
  <files>services/hh-search-svc/src/pgvector-client.ts</files>
  <action>
    Improve the warmupPool() method to be more robust:

    1. Update warmupPool() to warm up to poolMin connections:
    ```typescript
    private async warmupPool(): Promise<void> {
      // Warm up to poolMin to ensure connections are ready
      const warmupTarget = Math.min(this.config.poolMin, this.config.poolMax);
      if (warmupTarget <= 0) {
        this.logger.debug('Pool warmup skipped - poolMin is 0');
        return;
      }

      const started = Date.now();
      const connections: PoolClient[] = [];

      try {
        // Acquire connections in parallel for faster warmup
        const warmupPromises = Array.from({ length: warmupTarget }, async () => {
          try {
            return await this.pool.connect();
          } catch (error) {
            this.logger.warn({ error }, 'Failed to acquire warmup connection.');
            return null;
          }
        });

        const results = await Promise.all(warmupPromises);
        results.forEach(client => {
          if (client) connections.push(client);
        });
      } finally {
        // Release all connections back to pool
        connections.forEach(client => client.release());
      }

      this.logger.info(
        {
          warmedConnections: connections.length,
          targetConnections: warmupTarget,
          durationMs: Date.now() - started
        },
        'pgvector pool warmup completed.'
      );
    }
    ```

    Note: Need to import PoolClient type if not already imported.
  </action>
  <verify>
    Run: `npm run build --prefix services/hh-search-svc`
    Run: `npm test --prefix services/hh-search-svc`
    Expected: Build succeeds, existing tests pass
  </verify>
  <done>Pool warmup is parallelized and warms up to poolMin connections</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Existing tests continue to pass
3. Health check returns new pool metrics fields
4. Pool warmup logs show parallel connection acquisition
5. Configuration defaults are updated
</verification>

<success_criteria>
- Pool defaults updated: poolMax=20, poolMin=5, connectionTimeout=3s
- Health check reports: poolUtilization, poolMax, poolMin
- Warning logged when waitingRequests > 5
- Pool warmup is parallelized and targets poolMin
</success_criteria>

<output>
After completion, create `.planning/phases/11-performance-foundation/11-02-SUMMARY.md`
</output>
