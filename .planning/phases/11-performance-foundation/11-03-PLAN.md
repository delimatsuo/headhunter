---
phase: 11-performance-foundation
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - services/hh-search-svc/src/search-service.ts
  - services/hh-search-svc/src/parallel-search.ts
  - services/hh-search-svc/src/types.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Embedding lookup and specialty lookup execute in parallel"
    - "Vector search and text search can execute in parallel (separate queries)"
    - "Parallel execution saves at least 20% latency vs sequential"
    - "Promise.allSettled handles partial failures gracefully"
  artifacts:
    - path: "services/hh-search-svc/src/parallel-search.ts"
      provides: "Parallel search execution utilities"
      exports: ["executeParallelSearch", "ParallelSearchResult"]
    - path: "services/hh-search-svc/src/search-service.ts"
      provides: "Updated search flow with parallel execution"
      contains: "Promise.all"
  key_links:
    - from: "services/hh-search-svc/src/search-service.ts"
      to: "services/hh-search-svc/src/parallel-search.ts"
      via: "import and call"
      pattern: "executeParallelSearch"
---

<objective>
Implement parallel query execution for independent search operations using Promise.all.

Purpose: Running independent operations in parallel (embedding + specialty lookup, vector + text search) saves 20%+ latency compared to sequential execution.
Output: Parallel search utilities and refactored search service using Promise.all patterns.
</objective>

<execution_context>
@/Users/delimatsuo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/delimatsuo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-performance-foundation/11-RESEARCH.md
@services/hh-search-svc/src/search-service.ts
@services/hh-search-svc/src/pgvector-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parallel search utilities module</name>
  <files>services/hh-search-svc/src/parallel-search.ts</files>
  <action>
    Create a new module for parallel search execution utilities:

    ```typescript
    import type { Logger } from 'pino';

    export interface ParallelTimings {
      embeddingMs?: number;
      specialtyMs?: number;
      vectorSearchMs?: number;
      textSearchMs?: number;
      parallelSavingsMs: number;
    }

    export interface EmbeddingResult {
      embedding: number[];
      fromCache: boolean;
    }

    export interface SpecialtyResult {
      specialtyMatch: string | null;
      fromCache: boolean;
    }

    /**
     * Execute embedding generation and specialty lookup in parallel.
     * Both operations are independent and can run concurrently.
     */
    export async function executeParallelPreSearch<E, S>(
      embeddingFetcher: () => Promise<E>,
      specialtyFetcher: () => Promise<S>,
      logger: Logger
    ): Promise<{
      embedding: E | null;
      specialty: S | null;
      timings: { embeddingMs: number; specialtyMs: number; totalMs: number };
    }> {
      const start = Date.now();
      const embeddingStart = start;
      const specialtyStart = start;

      const results = await Promise.allSettled([
        embeddingFetcher(),
        specialtyFetcher()
      ]);

      const embeddingResult = results[0];
      const specialtyResult = results[1];

      const embedding = embeddingResult.status === 'fulfilled' ? embeddingResult.value : null;
      const specialty = specialtyResult.status === 'fulfilled' ? specialtyResult.value : null;

      // Log any failures for debugging
      if (embeddingResult.status === 'rejected') {
        logger.warn({ error: embeddingResult.reason }, 'Parallel embedding fetch failed');
      }
      if (specialtyResult.status === 'rejected') {
        logger.warn({ error: specialtyResult.reason }, 'Parallel specialty fetch failed');
      }

      const totalMs = Date.now() - start;
      const embeddingMs = embeddingResult.status === 'fulfilled' ? totalMs : 0;
      const specialtyMs = specialtyResult.status === 'fulfilled' ? totalMs : 0;

      return {
        embedding,
        specialty,
        timings: {
          embeddingMs,
          specialtyMs,
          totalMs
        }
      };
    }

    /**
     * Request coalescing to prevent duplicate concurrent requests.
     * If a request with the same key is already in-flight, return the existing promise.
     */
    export class RequestCoalescer<T> {
      private pendingRequests = new Map<string, Promise<T>>();

      async getOrFetch(key: string, fetcher: () => Promise<T>): Promise<T> {
        // Check if request already in-flight
        const existing = this.pendingRequests.get(key);
        if (existing) {
          return existing;
        }

        // Create new request and track it
        const promise = fetcher().finally(() => {
          this.pendingRequests.delete(key);
        });

        this.pendingRequests.set(key, promise);
        return promise;
      }

      clear(): void {
        this.pendingRequests.clear();
      }
    }

    /**
     * Calculate parallel execution savings compared to sequential.
     */
    export function calculateParallelSavings(
      parallelMs: number,
      operation1Ms: number,
      operation2Ms: number
    ): number {
      const sequentialMs = operation1Ms + operation2Ms;
      return Math.max(0, sequentialMs - parallelMs);
    }
    ```
  </action>
  <verify>
    Run: `npm run build --prefix services/hh-search-svc`
    Expected: New module compiles without errors
  </verify>
  <done>Parallel search utilities module exists with Promise.allSettled pattern</done>
</task>

<task type="auto">
  <name>Task 2: Refactor search service to use parallel pre-search</name>
  <files>services/hh-search-svc/src/search-service.ts</files>
  <action>
    Update hybridSearch() to execute embedding and specialty lookups in parallel:

    1. Import the parallel utilities:
    ```typescript
    import { executeParallelPreSearch, RequestCoalescer, calculateParallelSavings } from './parallel-search';
    ```

    2. Add a request coalescer as a class property for embedding requests:
    ```typescript
    private readonly embeddingCoalescer = new RequestCoalescer<number[]>();
    ```

    3. Replace the sequential embedding + specialty lookup with parallel execution.

    Current flow (sequential):
    ```typescript
    // Check embedding cache, then generate if needed
    const embedding = await this.embedClient.generateEmbedding(...);
    // Specialty lookup happens during hydration
    ```

    New flow (parallel):
    ```typescript
    // Execute embedding generation and any pre-search operations in parallel
    const preSearchStart = Date.now();

    const embeddingPromise = async (): Promise<number[]> => {
      // Check cache first
      if (embeddingCacheKey && this.redisClient && !this.redisClient.isDisabled()) {
        const cached = await this.redisClient.get<number[]>(embeddingCacheKey);
        if (Array.isArray(cached) && cached.length > 0) {
          return cached;
        }
      }

      // Generate embedding with coalescing to prevent duplicate requests
      const embeddingText = sanitizedQuery || request.jobDescription || request.query || ' ';
      return this.embeddingCoalescer.getOrFetch(embeddingCacheKey ?? embeddingText, async () => {
        const result = await this.embedClient.generateEmbedding({
          tenantId: context.tenant.id,
          requestId: context.requestId,
          query: embeddingText,
          metadata: { source: 'hh-search-svc', requestId: context.requestId }
        });

        // Cache the result
        if (embeddingCacheKey && this.redisClient && !this.redisClient.isDisabled() && result.embedding.length > 0) {
          await this.redisClient.set(embeddingCacheKey, result.embedding);
        }

        return result.embedding;
      });
    };

    // For now, specialty lookup is inline in hydration
    // Future optimization: pre-fetch specialties for filter
    const specialtyPromise = async (): Promise<string | null> => {
      // Placeholder - specialty is computed during hydration
      return null;
    };

    const { embedding: parallelEmbedding, timings: preSearchTimings } = await executeParallelPreSearch(
      embeddingPromise,
      specialtyPromise,
      this.logger
    );

    if (!parallelEmbedding || parallelEmbedding.length === 0) {
      throw badRequestError('Failed to generate embedding for search query.');
    }

    embedding = parallelEmbedding;
    timings.embeddingMs = preSearchTimings.embeddingMs;

    // Track parallel savings
    const preSearchMs = Date.now() - preSearchStart;
    this.logger.debug({ preSearchMs, parallelSavings: preSearchTimings.totalMs }, 'Pre-search parallel execution complete');
    ```

    4. Add parallel execution metrics to the response timings:
    ```typescript
    // In timings interface, add:
    parallelSavingsMs?: number;
    ```

    5. Log parallel execution statistics in the pipeline summary.
  </action>
  <verify>
    Run: `npm run build --prefix services/hh-search-svc`
    Run: `npm test --prefix services/hh-search-svc`
    Expected: Build succeeds, tests pass
  </verify>
  <done>Search service uses Promise.allSettled for parallel pre-search operations</done>
</task>

<task type="auto">
  <name>Task 3: Add parallel execution feature flag and metrics</name>
  <files>services/hh-search-svc/src/config.ts, services/hh-search-svc/src/types.ts</files>
  <action>
    1. Add feature flag to config.ts in SearchRuntimeConfig:
    ```typescript
    /** Enable parallel pre-search execution (embedding + specialty) */
    enableParallelPreSearch: boolean;
    ```

    Parse it:
    ```typescript
    enableParallelPreSearch: parseBoolean(process.env.ENABLE_PARALLEL_PRE_SEARCH, true),
    ```

    2. Update HybridSearchResponse timings type in types.ts:
    ```typescript
    export interface HybridSearchTimings {
      totalMs: number;
      embeddingMs?: number;
      retrievalMs?: number;
      rankingMs?: number;
      rerankMs?: number;
      // New parallel execution metrics
      preSearchMs?: number;
      parallelSavingsMs?: number;
    }
    ```

    3. In search-service.ts, wrap parallel execution with feature flag:
    ```typescript
    if (this.config.search.enableParallelPreSearch) {
      // Use parallel execution
      const { embedding: parallelEmbedding, timings: preSearchTimings } = await executeParallelPreSearch(...);
      // ...
    } else {
      // Fallback to sequential (existing code)
      // ...
    }
    ```

    4. Include parallel savings in debug output:
    ```typescript
    if (request.includeDebug) {
      response.debug = {
        // ... existing fields
        parallelExecution: {
          enabled: this.config.search.enableParallelPreSearch,
          preSearchMs: timings.preSearchMs,
          parallelSavingsMs: timings.parallelSavingsMs
        }
      };
    }
    ```
  </action>
  <verify>
    Run: `npm run build --prefix services/hh-search-svc`
    Expected: Build succeeds with feature flag
  </verify>
  <done>Parallel execution is feature flagged and metrics are tracked</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Existing tests continue to pass
3. Feature flag ENABLE_PARALLEL_PRE_SEARCH defaults to true
4. Debug output includes parallel execution metrics
5. Request coalescing prevents duplicate concurrent embedding requests
</verification>

<success_criteria>
- Parallel search utilities module created with Promise.allSettled
- Embedding generation and specialty lookup run in parallel
- Request coalescing prevents duplicate concurrent requests
- Feature flag allows rollback to sequential execution
- Parallel savings metrics tracked in response
</success_criteria>

<output>
After completion, create `.planning/phases/11-performance-foundation/11-03-SUMMARY.md`
</output>
