---
phase: 08-career-trajectory
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - services/hh-search-svc/src/trajectory-calculators.ts
  - services/hh-search-svc/src/trajectory-calculators.test.ts
autonomous: true

must_haves:
  truths:
    - "Velocity is computed as fast (<2yr), normal (2-4yr), or slow (>4yr)"
    - "Together AI promotion_velocity field is used as fallback"
    - "Type is classified as technical_growth, leadership_track, lateral_move, or career_pivot"
    - "Track changes (IC -> Manager) are detected as pivots"
  artifacts:
    - path: "services/hh-search-svc/src/trajectory-calculators.ts"
      provides: "Velocity and type classifiers"
      exports: ["calculateTrajectoryVelocity", "classifyTrajectoryType", "TrajectoryVelocity", "TrajectoryType"]
    - path: "services/hh-search-svc/src/trajectory-calculators.test.ts"
      provides: "Unit tests for velocity and type"
      contains: "describe.*calculateTrajectoryVelocity"
  key_links:
    - from: "services/hh-search-svc/src/trajectory-calculators.ts"
      to: "calculateTrajectoryVelocity"
      via: "Function export"
      pattern: "export function calculateTrajectoryVelocity"
---

<objective>
Add trajectory velocity and type classifiers to analyze career progression speed and track.

Purpose: TRAJ-02 (velocity) and TRAJ-04 (type) require analyzing promotion timing and career track patterns.

Output: Extended `trajectory-calculators.ts` with velocity and type classifiers, plus tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-career-trajectory/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add velocity classifier</name>
  <files>services/hh-search-svc/src/trajectory-calculators.ts</files>
  <action>
Add the following to `trajectory-calculators.ts`:

**Types:**
```typescript
/**
 * Career velocity indicating speed of progression.
 * - fast: Average <2 years between promotions
 * - normal: Average 2-4 years between promotions
 * - slow: Average >4 years between promotions
 */
export type TrajectoryVelocity = 'fast' | 'normal' | 'slow';

/**
 * Experience entry for velocity calculation.
 */
export interface ExperienceEntry {
  title: string;
  startDate?: string | Date;
  endDate?: string | Date | null;
  isCurrent?: boolean;
}

/**
 * Together AI career trajectory analysis structure.
 */
export interface TogetherAITrajectory {
  current_level?: string;
  years_experience?: number;
  promotion_velocity?: string;
  career_progression?: string;
  performance_indicator?: string;
}
```

**Velocity Calculator:**
```typescript
/**
 * Calculates career velocity from experience entries.
 *
 * Algorithm:
 * 1. Identify level changes between consecutive roles
 * 2. Calculate years between level changes
 * 3. Average the time-to-promotion
 * 4. Classify: fast (<2yr), normal (2-4yr), slow (>4yr)
 *
 * Falls back to Together AI promotion_velocity field when dates are unavailable.
 *
 * @param experience - Array of experience entries in chronological order
 * @param togetherAI - Optional Together AI trajectory data for fallback
 * @returns Velocity classification
 */
export function calculateTrajectoryVelocity(
  experience: ExperienceEntry[],
  togetherAI?: TogetherAITrajectory
): TrajectoryVelocity {
  if (!experience || experience.length < 2) {
    // Fallback to Together AI field
    if (togetherAI?.promotion_velocity) {
      const normalized = togetherAI.promotion_velocity.toLowerCase().trim();
      if (normalized.includes('fast') || normalized.includes('rapid')) return 'fast';
      if (normalized.includes('slow') || normalized.includes('gradual')) return 'slow';
      return 'normal';
    }
    return 'normal'; // Neutral default
  }

  // Map each experience to level
  const entries = experience.map((exp, idx) => ({
    level: mapTitleToLevel(exp.title),
    startDate: parseDate(exp.startDate),
    endDate: parseDate(exp.endDate),
    index: idx
  }));

  // Filter to valid entries (known level + valid dates)
  const validEntries = entries.filter(e => e.level !== -1 && e.startDate !== null);

  if (validEntries.length < 2) {
    // Fallback to Together AI
    if (togetherAI?.promotion_velocity) {
      const normalized = togetherAI.promotion_velocity.toLowerCase().trim();
      if (normalized.includes('fast') || normalized.includes('rapid')) return 'fast';
      if (normalized.includes('slow') || normalized.includes('gradual')) return 'slow';
    }
    return 'normal';
  }

  // Find level changes and calculate time between them
  const promotionTimes: number[] = [];
  for (let i = 1; i < validEntries.length; i++) {
    const current = validEntries[i];
    const previous = validEntries[i - 1];

    // Check for level increase (promotion)
    if (current.level > previous.level) {
      // Calculate years between roles
      const startCurrent = current.startDate!;
      const endPrevious = previous.endDate || startCurrent;

      const years = (startCurrent.getTime() - (previous.startDate?.getTime() || startCurrent.getTime()))
        / (365.25 * 24 * 60 * 60 * 1000);

      if (years > 0 && years < 20) { // Sanity check
        promotionTimes.push(years);
      }
    }
  }

  if (promotionTimes.length === 0) {
    // No clear promotions detected, use tenure heuristic
    const firstDate = validEntries[0].startDate;
    const lastEntry = validEntries[validEntries.length - 1];
    const lastDate = lastEntry.endDate || new Date();

    if (firstDate && lastDate) {
      const totalYears = (lastDate.getTime() - firstDate.getTime())
        / (365.25 * 24 * 60 * 60 * 1000);
      const levelSpan = validEntries[validEntries.length - 1].level - validEntries[0].level;

      if (levelSpan > 0) {
        const avgYearsPerLevel = totalYears / levelSpan;
        if (avgYearsPerLevel < 2) return 'fast';
        if (avgYearsPerLevel > 4) return 'slow';
        return 'normal';
      }
    }

    // Fallback to Together AI
    if (togetherAI?.promotion_velocity) {
      const normalized = togetherAI.promotion_velocity.toLowerCase().trim();
      if (normalized.includes('fast') || normalized.includes('rapid')) return 'fast';
      if (normalized.includes('slow') || normalized.includes('gradual')) return 'slow';
    }
    return 'normal';
  }

  const avgPromoTime = promotionTimes.reduce((a, b) => a + b, 0) / promotionTimes.length;

  if (avgPromoTime < 2) return 'fast';
  if (avgPromoTime > 4) return 'slow';
  return 'normal';
}

/**
 * Helper to parse date strings into Date objects.
 */
function parseDate(date: string | Date | null | undefined): Date | null {
  if (!date) return null;
  if (date instanceof Date) return isNaN(date.getTime()) ? null : date;

  const parsed = new Date(date);
  return isNaN(parsed.getTime()) ? null : parsed;
}
```
  </action>
  <verify>
Run TypeScript compilation:
```bash
cd /Volumes/Extreme\ Pro/myprojects/headhunter/services/hh-search-svc && npx tsc --noEmit
```
  </verify>
  <done>
calculateTrajectoryVelocity function added with Together AI fallback. TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add type classifier</name>
  <files>services/hh-search-svc/src/trajectory-calculators.ts</files>
  <action>
Add the trajectory type classifier to `trajectory-calculators.ts`:

**Type Definition:**
```typescript
/**
 * Trajectory type indicating career track pattern.
 * - technical_growth: IC track with increasing seniority
 * - leadership_track: Management track progression
 * - lateral_move: Same-level moves across functions/companies
 * - career_pivot: Track change (IC -> Manager or vice versa) or function change
 */
export type TrajectoryType = 'technical_growth' | 'leadership_track' | 'lateral_move' | 'career_pivot';
```

**Type Classifier:**
```typescript
/**
 * Title patterns indicating technical track.
 */
const TECHNICAL_PATTERNS = [
  /\b(staff|principal|distinguished|fellow)\b/i,
  /\bsenior\s+(engineer|developer|architect)\b/i,
  /\b(tech|technical)\s+lead\b/i,
  /\barchitect\b/i
];

/**
 * Title patterns indicating leadership track.
 */
const LEADERSHIP_PATTERNS = [
  /\b(manager|director|vp|vice president)\b/i,
  /\bhead\s+of\b/i,
  /\b(c[a-z]o|chief)\b/i,
  /\bengineering\s+manager\b/i
];

/**
 * Title patterns indicating function change (career pivot).
 */
const FUNCTION_PATTERNS = [
  { pattern: /\b(engineer|developer|architect|programmer)\b/i, function: 'engineering' },
  { pattern: /\b(product\s+manager|pm)\b/i, function: 'product' },
  { pattern: /\b(designer|ux|ui)\b/i, function: 'design' },
  { pattern: /\b(data\s+scientist|ml\s+engineer|machine\s+learning)\b/i, function: 'data' },
  { pattern: /\b(sales|account|business\s+development)\b/i, function: 'sales' },
  { pattern: /\b(marketing|growth)\b/i, function: 'marketing' }
];

/**
 * Detects the function from a job title.
 */
function detectFunction(title: string): string | null {
  if (!title) return null;
  const lower = title.toLowerCase();
  for (const { pattern, function: func } of FUNCTION_PATTERNS) {
    if (pattern.test(lower)) return func;
  }
  return null;
}

/**
 * Classifies trajectory type from a sequence of job titles.
 *
 * Classification rules:
 * 1. Technical Growth: Most titles are IC technical track, level increasing
 * 2. Leadership Track: Most titles are management track
 * 3. Career Pivot: Track change (IC -> Manager) or function change
 * 4. Lateral Move: Same level, different companies/functions
 *
 * @param titleSequence - Array of job titles in chronological order
 * @returns Trajectory type classification
 */
export function classifyTrajectoryType(titleSequence: string[]): TrajectoryType {
  if (!titleSequence || titleSequence.length === 0) {
    return 'lateral_move'; // Neutral default
  }

  // Analyze each title for track and function
  const analysis = titleSequence.map(title => ({
    title,
    level: mapTitleToLevel(title),
    isTechnical: TECHNICAL_PATTERNS.some(p => p.test(title)),
    isLeadership: LEADERSHIP_PATTERNS.some(p => p.test(title)),
    function: detectFunction(title)
  }));

  // Count technical vs leadership titles
  const technicalCount = analysis.filter(a => a.isTechnical && !a.isLeadership).length;
  const leadershipCount = analysis.filter(a => a.isLeadership).length;

  // Check for function changes (career pivot)
  const functions = analysis.map(a => a.function).filter(f => f !== null);
  const uniqueFunctions = new Set(functions);
  if (uniqueFunctions.size > 1) {
    return 'career_pivot';
  }

  // Check for track changes (IC -> Manager or Manager -> IC)
  const hasTechnical = technicalCount > 0 || analysis.some(a => a.level >= 0 && a.level <= TECHNICAL_MAX_INDEX);
  const hasLeadership = leadershipCount > 0 || analysis.some(a => a.level >= MANAGEMENT_MIN_INDEX);

  // If both tracks present across career, it's a pivot
  const levelsInTech = analysis.filter(a => a.level >= 0 && a.level <= TECHNICAL_MAX_INDEX).length;
  const levelsInMgmt = analysis.filter(a => a.level >= MANAGEMENT_MIN_INDEX).length;

  if (levelsInTech > 0 && levelsInMgmt > 0) {
    return 'career_pivot';
  }

  // Check for level changes to determine growth vs lateral
  const levels = analysis.map(a => a.level).filter(l => l !== -1);
  if (levels.length >= 2) {
    const levelGain = levels[levels.length - 1] - levels[0];

    if (levelGain > 0) {
      // Growth detected - determine track
      if (leadershipCount > technicalCount) {
        return 'leadership_track';
      }
      return 'technical_growth';
    }

    if (levelGain === 0) {
      return 'lateral_move';
    }
  }

  // Final classification based on majority track
  if (leadershipCount > technicalCount && leadershipCount > 0) {
    return 'leadership_track';
  }
  if (technicalCount > leadershipCount && technicalCount > 0) {
    return 'technical_growth';
  }

  return 'lateral_move';
}
```

Note: The constants TECHNICAL_MAX_INDEX and MANAGEMENT_MIN_INDEX should already be defined from Task 1 (Plan 01). If not, add them:
```typescript
const TECHNICAL_MAX_INDEX = 6;
const MANAGEMENT_MIN_INDEX = 7;
```
  </action>
  <verify>
Run TypeScript compilation:
```bash
cd /Volumes/Extreme\ Pro/myprojects/headhunter/services/hh-search-svc && npx tsc --noEmit
```
  </verify>
  <done>
classifyTrajectoryType function added with track and function detection. TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for velocity and type classifiers</name>
  <files>services/hh-search-svc/src/trajectory-calculators.test.ts</files>
  <action>
Add the following test cases to `trajectory-calculators.test.ts`:

```typescript
import {
  calculateTrajectoryVelocity,
  classifyTrajectoryType,
  type ExperienceEntry,
  type TogetherAITrajectory
} from './trajectory-calculators';

describe('calculateTrajectoryVelocity', () => {
  describe('fast velocity', () => {
    it('detects fast velocity with <2yr promotions', () => {
      const experience: ExperienceEntry[] = [
        { title: 'Junior Engineer', startDate: '2020-01-01', endDate: '2021-06-01' },
        { title: 'Senior Engineer', startDate: '2021-07-01', endDate: '2023-01-01' },
        { title: 'Staff Engineer', startDate: '2023-02-01', isCurrent: true }
      ];
      expect(calculateTrajectoryVelocity(experience)).toBe('fast');
    });
  });

  describe('normal velocity', () => {
    it('detects normal velocity with 2-4yr promotions', () => {
      const experience: ExperienceEntry[] = [
        { title: 'Junior Engineer', startDate: '2016-01-01', endDate: '2019-01-01' },
        { title: 'Senior Engineer', startDate: '2019-02-01', endDate: '2022-01-01' },
        { title: 'Staff Engineer', startDate: '2022-02-01', isCurrent: true }
      ];
      expect(calculateTrajectoryVelocity(experience)).toBe('normal');
    });
  });

  describe('slow velocity', () => {
    it('detects slow velocity with >4yr promotions', () => {
      const experience: ExperienceEntry[] = [
        { title: 'Junior Engineer', startDate: '2010-01-01', endDate: '2016-01-01' },
        { title: 'Senior Engineer', startDate: '2016-02-01', endDate: '2022-01-01' },
        { title: 'Staff Engineer', startDate: '2022-02-01', isCurrent: true }
      ];
      expect(calculateTrajectoryVelocity(experience)).toBe('slow');
    });
  });

  describe('Together AI fallback', () => {
    it('uses Together AI fast velocity when dates missing', () => {
      const experience: ExperienceEntry[] = [
        { title: 'Senior Engineer' }
      ];
      const togetherAI: TogetherAITrajectory = { promotion_velocity: 'Fast progression' };
      expect(calculateTrajectoryVelocity(experience, togetherAI)).toBe('fast');
    });

    it('uses Together AI slow velocity when dates missing', () => {
      const experience: ExperienceEntry[] = [];
      const togetherAI: TogetherAITrajectory = { promotion_velocity: 'Slow, gradual growth' };
      expect(calculateTrajectoryVelocity(experience, togetherAI)).toBe('slow');
    });

    it('defaults to normal when no data', () => {
      expect(calculateTrajectoryVelocity([])).toBe('normal');
    });
  });
});

describe('classifyTrajectoryType', () => {
  describe('technical_growth', () => {
    it('detects technical growth from IC progression', () => {
      const sequence = ['Junior Engineer', 'Senior Engineer', 'Staff Engineer', 'Principal Engineer'];
      expect(classifyTrajectoryType(sequence)).toBe('technical_growth');
    });

    it('detects technical growth with architect titles', () => {
      const sequence = ['Senior Developer', 'Lead Architect', 'Principal Architect'];
      expect(classifyTrajectoryType(sequence)).toBe('technical_growth');
    });
  });

  describe('leadership_track', () => {
    it('detects leadership track from management progression', () => {
      const sequence = ['Engineering Manager', 'Senior Manager', 'Director', 'VP of Engineering'];
      expect(classifyTrajectoryType(sequence)).toBe('leadership_track');
    });

    it('detects leadership track with head of title', () => {
      const sequence = ['Manager', 'Director', 'Head of Engineering'];
      expect(classifyTrajectoryType(sequence)).toBe('leadership_track');
    });
  });

  describe('career_pivot', () => {
    it('detects career pivot from IC to Manager', () => {
      const sequence = ['Senior Engineer', 'Staff Engineer', 'Engineering Manager'];
      expect(classifyTrajectoryType(sequence)).toBe('career_pivot');
    });

    it('detects career pivot from Manager to IC', () => {
      const sequence = ['Engineering Manager', 'Senior Engineer'];
      expect(classifyTrajectoryType(sequence)).toBe('career_pivot');
    });

    it('detects career pivot from function change', () => {
      const sequence = ['Senior Engineer', 'Product Manager'];
      expect(classifyTrajectoryType(sequence)).toBe('career_pivot');
    });
  });

  describe('lateral_move', () => {
    it('detects lateral move from same-level changes', () => {
      const sequence = ['Senior Engineer', 'Senior Developer', 'Senior Architect'];
      expect(classifyTrajectoryType(sequence)).toBe('lateral_move');
    });

    it('returns lateral_move for empty sequence', () => {
      expect(classifyTrajectoryType([])).toBe('lateral_move');
    });

    it('returns lateral_move for single title', () => {
      expect(classifyTrajectoryType(['Senior Engineer'])).toBe('lateral_move');
    });
  });
});
```
  </action>
  <verify>
Run all tests:
```bash
cd /Volumes/Extreme\ Pro/myprojects/headhunter/services/hh-search-svc && npm test -- trajectory-calculators.test.ts
```
All tests should pass.
  </verify>
  <done>
Unit tests for velocity and type classifiers pass. TRAJ-02 and TRAJ-04 foundations complete.
  </done>
</task>

</tasks>

<verification>
1. `calculateTrajectoryVelocity` returns 'fast', 'normal', or 'slow'
2. Together AI fallback works when dates are missing
3. `classifyTrajectoryType` returns one of four trajectory types
4. Career pivots (track changes, function changes) are detected
5. All unit tests pass
</verification>

<success_criteria>
- TRAJ-02: Velocity computed as fast (<2yr), normal (2-4yr), slow (>4yr)
- TRAJ-04: Type classified as technical_growth, leadership_track, lateral_move, or career_pivot
- Together AI promotion_velocity used as fallback when date parsing fails
- Edge cases (missing dates, single role) return sensible defaults
</success_criteria>

<output>
After completion, create `.planning/phases/08-career-trajectory/08-02-SUMMARY.md`
</output>
