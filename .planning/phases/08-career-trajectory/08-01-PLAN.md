---
phase: 08-career-trajectory
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/hh-search-svc/src/trajectory-calculators.ts
  - services/hh-search-svc/src/trajectory-calculators.test.ts
autonomous: true

must_haves:
  truths:
    - "Title sequences are analyzed to determine career direction"
    - "Direction is classified as upward, lateral, or downward"
    - "Level mapping handles common title variations"
    - "Missing/unknown titles return neutral classification"
  artifacts:
    - path: "services/hh-search-svc/src/trajectory-calculators.ts"
      provides: "Trajectory direction classifier"
      exports: ["calculateTrajectoryDirection", "mapTitleToLevel", "LEVEL_ORDER_EXTENDED"]
    - path: "services/hh-search-svc/src/trajectory-calculators.test.ts"
      provides: "Unit tests for trajectory direction"
      contains: "describe.*calculateTrajectoryDirection"
  key_links:
    - from: "services/hh-search-svc/src/trajectory-calculators.ts"
      to: "LEVEL_ORDER_EXTENDED constant"
      via: "Internal constant definition"
      pattern: "const LEVEL_ORDER_EXTENDED"
---

<objective>
Create the trajectory direction classifier that analyzes title sequences to determine career direction (upward, lateral, downward).

Purpose: TRAJ-01 requires career direction computed from title sequence analysis. This is the foundation for trajectory scoring.

Output: `trajectory-calculators.ts` with direction classifier and unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-career-trajectory/08-RESEARCH.md
@services/hh-search-svc/src/signal-calculators.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trajectory-calculators.ts with direction classifier</name>
  <files>services/hh-search-svc/src/trajectory-calculators.ts</files>
  <action>
Create a new file `services/hh-search-svc/src/trajectory-calculators.ts` with:

**Constants:**
```typescript
/**
 * Extended level ordering that separates technical and management tracks.
 * Technical track: intern -> junior -> mid -> senior -> staff -> principal -> distinguished
 * Management track: manager -> senior_manager -> director -> senior_director -> vp -> svp -> c-level
 */
export const LEVEL_ORDER_EXTENDED = [
  'intern', 'junior', 'mid', 'senior', 'staff', 'principal', 'distinguished',
  'manager', 'senior_manager', 'director', 'senior_director', 'vp', 'svp', 'c-level'
];

/**
 * Level index mapping for quick lookups.
 * Technical levels: 0-6, Management levels: 7-13
 */
const LEVEL_INDEX: Record<string, number> = {
  // Technical track
  'intern': 0, 'junior': 1, 'entry': 1, 'associate': 1,
  'mid': 2, 'intermediate': 2,
  'senior': 3, 'sr': 3,
  'staff': 4, 'lead': 4,
  'principal': 5,
  'distinguished': 6, 'fellow': 6,
  // Management track (offset by 7 to indicate different track)
  'manager': 7, 'engineering manager': 7, 'em': 7,
  'senior_manager': 8, 'senior manager': 8,
  'director': 9,
  'senior_director': 10, 'senior director': 10,
  'vp': 11, 'vice president': 11,
  'svp': 12, 'senior vice president': 12,
  'c-level': 13, 'cto': 13, 'ceo': 13, 'coo': 13, 'cfo': 13
};

const TECHNICAL_MAX_INDEX = 6;
const MANAGEMENT_MIN_INDEX = 7;
```

**Title-to-Level Mapping Function:**
```typescript
/**
 * Maps a job title to a normalized level index.
 * Returns -1 if the title cannot be mapped.
 *
 * @param title - Job title to map
 * @returns Level index (0-13) or -1 if unknown
 */
export function mapTitleToLevel(title: string): number {
  if (!title || typeof title !== 'string') return -1;

  const normalized = title.toLowerCase().trim();

  // Direct lookup
  if (LEVEL_INDEX[normalized] !== undefined) {
    return LEVEL_INDEX[normalized];
  }

  // Pattern matching for common variations
  const patterns: [RegExp, number][] = [
    [/\b(intern|internship)\b/i, 0],
    [/\b(junior|jr|entry|associate)\b/i, 1],
    [/\b(mid[-\s]?level|intermediate)\b/i, 2],
    [/\b(senior|sr)\s+(engineer|developer|architect)/i, 3],
    [/\b(staff|lead)\s+(engineer|developer)/i, 4],
    [/\b(principal|lead)\s+architect/i, 5],
    [/\b(distinguished|fellow)\b/i, 6],
    [/\bengineering\s+manager\b/i, 7],
    [/\bmanager\b/i, 7],
    [/\bsenior\s+manager\b/i, 8],
    [/\bdirector\b/i, 9],
    [/\bsenior\s+director\b/i, 10],
    [/\b(vp|vice\s+president)\b/i, 11],
    [/\b(svp|senior\s+vice\s+president)\b/i, 12],
    [/\b(cto|ceo|coo|cfo|chief)\b/i, 13]
  ];

  for (const [pattern, index] of patterns) {
    if (pattern.test(normalized)) {
      return index;
    }
  }

  // Fallback: check if title contains level keywords
  if (/senior/i.test(normalized)) return 3;
  if (/junior/i.test(normalized) || /jr\b/i.test(normalized)) return 1;

  return -1; // Unknown level
}
```

**Direction Classifier:**
```typescript
/**
 * Trajectory direction indicating career movement over time.
 */
export type TrajectoryDirection = 'upward' | 'lateral' | 'downward';

/**
 * Calculates career direction from a sequence of job titles.
 *
 * Rules:
 * - Upward: Average delta > 0.5 (mostly promotions)
 * - Lateral: Average delta between -0.5 and 0.5 (same-level moves)
 * - Downward: Average delta < -0.5 (mostly demotions/resets)
 *
 * @param titleSequence - Array of job titles in chronological order (oldest first)
 * @returns Direction classification
 */
export function calculateTrajectoryDirection(
  titleSequence: string[]
): TrajectoryDirection {
  if (!titleSequence || titleSequence.length < 2) {
    return 'lateral'; // Neutral when insufficient data
  }

  // Map titles to level indices
  const levels = titleSequence.map(mapTitleToLevel);

  // Filter out unknown levels (-1)
  const validLevels = levels.filter(l => l !== -1);
  if (validLevels.length < 2) {
    return 'lateral'; // Neutral when insufficient valid levels
  }

  // Calculate deltas between consecutive valid levels
  // Note: We consider track changes (tech -> mgmt) as lateral unless there's clear level change
  const deltas: number[] = [];
  for (let i = 1; i < validLevels.length; i++) {
    const current = validLevels[i];
    const previous = validLevels[i - 1];

    // Handle track changes (tech -> mgmt or mgmt -> tech)
    const prevIsTech = previous <= TECHNICAL_MAX_INDEX;
    const currIsTech = current <= TECHNICAL_MAX_INDEX;

    if (prevIsTech !== currIsTech) {
      // Track change: compare relative positions within each track
      // Tech senior (3) -> Manager (7) is roughly lateral (both are mid-career)
      // Map to relative position: tech 0-6 maps to mgmt 7-13
      const prevRelative = prevIsTech ? previous : previous - MANAGEMENT_MIN_INDEX;
      const currRelative = currIsTech ? current : current - MANAGEMENT_MIN_INDEX;
      deltas.push(currRelative - prevRelative);
    } else {
      deltas.push(current - previous);
    }
  }

  if (deltas.length === 0) {
    return 'lateral';
  }

  const averageDelta = deltas.reduce((sum, d) => sum + d, 0) / deltas.length;

  if (averageDelta > 0.5) return 'upward';
  if (averageDelta < -0.5) return 'downward';
  return 'lateral';
}
```

Include JSDoc comments for all exports.
  </action>
  <verify>
Run TypeScript compilation:
```bash
cd /Volumes/Extreme\ Pro/myprojects/headhunter/services/hh-search-svc && npx tsc --noEmit
```
No errors should appear.
  </verify>
  <done>
trajectory-calculators.ts exists with calculateTrajectoryDirection, mapTitleToLevel, and LEVEL_ORDER_EXTENDED exports. TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for direction classifier</name>
  <files>services/hh-search-svc/src/trajectory-calculators.test.ts</files>
  <action>
Create `services/hh-search-svc/src/trajectory-calculators.test.ts` with unit tests:

```typescript
import { describe, it, expect } from 'vitest';
import {
  calculateTrajectoryDirection,
  mapTitleToLevel,
  LEVEL_ORDER_EXTENDED
} from './trajectory-calculators';

describe('mapTitleToLevel', () => {
  it('maps standard technical titles correctly', () => {
    expect(mapTitleToLevel('Junior Engineer')).toBe(1);
    expect(mapTitleToLevel('Senior Developer')).toBe(3);
    expect(mapTitleToLevel('Staff Engineer')).toBe(4);
    expect(mapTitleToLevel('Principal Architect')).toBe(5);
  });

  it('maps standard management titles correctly', () => {
    expect(mapTitleToLevel('Engineering Manager')).toBe(7);
    expect(mapTitleToLevel('Director')).toBe(9);
    expect(mapTitleToLevel('VP of Engineering')).toBe(11);
    expect(mapTitleToLevel('CTO')).toBe(13);
  });

  it('handles title variations', () => {
    expect(mapTitleToLevel('Sr. Software Engineer')).toBe(3);
    expect(mapTitleToLevel('Lead Developer')).toBe(4);
    expect(mapTitleToLevel('EM')).toBe(7);
    expect(mapTitleToLevel('Vice President')).toBe(11);
  });

  it('returns -1 for unknown titles', () => {
    expect(mapTitleToLevel('Product Manager')).toBe(-1);
    expect(mapTitleToLevel('Data Analyst')).toBe(-1);
    expect(mapTitleToLevel('')).toBe(-1);
    expect(mapTitleToLevel(null as unknown as string)).toBe(-1);
  });
});

describe('calculateTrajectoryDirection', () => {
  describe('upward trajectory', () => {
    it('detects upward trajectory from Junior -> Senior -> Staff', () => {
      const sequence = ['Junior Engineer', 'Senior Engineer', 'Staff Engineer'];
      expect(calculateTrajectoryDirection(sequence)).toBe('upward');
    });

    it('detects upward trajectory from Intern -> Mid -> Senior', () => {
      const sequence = ['Intern', 'Mid-Level Developer', 'Senior Developer'];
      expect(calculateTrajectoryDirection(sequence)).toBe('upward');
    });

    it('detects upward trajectory in management track', () => {
      const sequence = ['Engineering Manager', 'Director', 'VP'];
      expect(calculateTrajectoryDirection(sequence)).toBe('upward');
    });
  });

  describe('lateral trajectory', () => {
    it('detects lateral trajectory from same-level moves', () => {
      const sequence = ['Senior Engineer', 'Senior Developer', 'Senior Architect'];
      expect(calculateTrajectoryDirection(sequence)).toBe('lateral');
    });

    it('detects lateral trajectory with mixed small changes', () => {
      const sequence = ['Senior Engineer', 'Staff Engineer', 'Senior Engineer'];
      expect(calculateTrajectoryDirection(sequence)).toBe('lateral');
    });

    it('treats tech -> management at similar level as lateral', () => {
      const sequence = ['Senior Engineer', 'Engineering Manager'];
      expect(calculateTrajectoryDirection(sequence)).toBe('lateral');
    });
  });

  describe('downward trajectory', () => {
    it('detects downward trajectory from role reset', () => {
      const sequence = ['Director', 'Senior Engineer'];
      expect(calculateTrajectoryDirection(sequence)).toBe('downward');
    });

    it('detects downward trajectory from multiple demotions', () => {
      const sequence = ['Staff Engineer', 'Senior Engineer', 'Junior Engineer'];
      expect(calculateTrajectoryDirection(sequence)).toBe('downward');
    });
  });

  describe('edge cases', () => {
    it('returns lateral for single title', () => {
      expect(calculateTrajectoryDirection(['Senior Engineer'])).toBe('lateral');
    });

    it('returns lateral for empty array', () => {
      expect(calculateTrajectoryDirection([])).toBe('lateral');
    });

    it('returns lateral when all titles are unknown', () => {
      const sequence = ['Product Manager', 'Data Analyst', 'Designer'];
      expect(calculateTrajectoryDirection(sequence)).toBe('lateral');
    });

    it('handles mixed known/unknown titles', () => {
      const sequence = ['Junior Engineer', 'Product Manager', 'Senior Engineer'];
      expect(calculateTrajectoryDirection(sequence)).toBe('upward');
    });
  });
});
```
  </action>
  <verify>
Run the tests:
```bash
cd /Volumes/Extreme\ Pro/myprojects/headhunter/services/hh-search-svc && npm test -- trajectory-calculators.test.ts
```
All tests should pass.
  </verify>
  <done>
Unit tests exist and pass for mapTitleToLevel and calculateTrajectoryDirection covering upward, lateral, downward, and edge cases.
  </done>
</task>

</tasks>

<verification>
1. File exists: `services/hh-search-svc/src/trajectory-calculators.ts`
2. File exists: `services/hh-search-svc/src/trajectory-calculators.test.ts`
3. TypeScript compilation passes with no errors
4. All unit tests pass
5. Exports available: `calculateTrajectoryDirection`, `mapTitleToLevel`, `LEVEL_ORDER_EXTENDED`
</verification>

<success_criteria>
- calculateTrajectoryDirection returns 'upward', 'lateral', or 'downward' based on title sequence
- mapTitleToLevel correctly maps common engineering and management titles
- Edge cases (empty, unknown, single title) return 'lateral' (neutral)
- TRAJ-01 foundation complete: direction computed from title sequence analysis
</success_criteria>

<output>
After completion, create `.planning/phases/08-career-trajectory/08-01-SUMMARY.md`
</output>
