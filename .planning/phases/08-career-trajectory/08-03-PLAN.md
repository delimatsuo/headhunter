---
phase: 08-career-trajectory
plan: 03
type: execute
wave: 2
depends_on: [08-01, 08-02]
files_modified:
  - services/hh-search-svc/src/trajectory-calculators.ts
  - services/hh-search-svc/src/trajectory-calculators.test.ts
  - services/hh-search-svc/src/scoring.ts
  - services/hh-search-svc/src/types.ts
autonomous: true

must_haves:
  truths:
    - "Trajectory fit score (0-1) computed for each candidate"
    - "Fit scoring considers direction, velocity, type, and role requirements"
    - "trajectoryFit signal integrated into extractSignalScores"
    - "SignalScores.trajectoryFit populated with computed value"
  artifacts:
    - path: "services/hh-search-svc/src/trajectory-calculators.ts"
      provides: "Trajectory fit scorer"
      exports: ["calculateTrajectoryFit", "TrajectoryContext"]
    - path: "services/hh-search-svc/src/scoring.ts"
      provides: "Integration with Phase 7 signals"
      contains: "calculateTrajectoryFit"
  key_links:
    - from: "services/hh-search-svc/src/scoring.ts"
      to: "services/hh-search-svc/src/trajectory-calculators.ts"
      via: "import"
      pattern: "import.*calculateTrajectoryFit.*from.*trajectory-calculators"
---

<objective>
Create the trajectory fit scorer and integrate all trajectory signals into the scoring pipeline.

Purpose: TRAJ-03 requires trajectory fit score for role alignment. This plan completes the trajectory scoring and integrates it with Phase 7 signals.

Output: `calculateTrajectoryFit` function and integration into `scoring.ts`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-career-trajectory/08-RESEARCH.md
@services/hh-search-svc/src/scoring.ts
@services/hh-search-svc/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add trajectory fit scorer</name>
  <files>services/hh-search-svc/src/trajectory-calculators.ts</files>
  <action>
Add the trajectory fit scoring function to `trajectory-calculators.ts`:

**Context Interface:**
```typescript
/**
 * Context for trajectory fit scoring.
 */
export interface TrajectoryContext {
  /** Target level for the role (e.g., 'senior', 'manager', 'director') */
  targetLevel?: string;
  /** Target track for the role */
  targetTrack?: 'technical' | 'management' | 'any';
  /** Company growth stage */
  roleGrowthType?: 'high_growth' | 'stable' | 'pivot_friendly';
  /** Whether role is open to career changers */
  allowPivot?: boolean;
}

/**
 * Computed trajectory metrics for a candidate.
 */
export interface TrajectoryMetrics {
  direction: TrajectoryDirection;
  velocity: TrajectoryVelocity;
  type: TrajectoryType;
}
```

**Fit Scoring Matrix:**
```typescript
/**
 * Base scores for direction-velocity combinations.
 * Higher scores for upward/fast in growth contexts.
 */
const DIRECTION_VELOCITY_SCORES: Record<TrajectoryDirection, Record<TrajectoryVelocity, number>> = {
  upward: { fast: 1.0, normal: 0.85, slow: 0.7 },
  lateral: { fast: 0.7, normal: 0.65, slow: 0.55 },
  downward: { fast: 0.4, normal: 0.35, slow: 0.3 }
};

/**
 * Track alignment scores.
 * Perfect match = 1.0, Mismatch = penalty.
 */
const TRACK_ALIGNMENT_SCORES: Record<TrajectoryType, Record<'technical' | 'management' | 'any', number>> = {
  technical_growth: { technical: 1.0, management: 0.6, any: 0.85 },
  leadership_track: { technical: 0.6, management: 1.0, any: 0.85 },
  lateral_move: { technical: 0.7, management: 0.7, any: 0.75 },
  career_pivot: { technical: 0.55, management: 0.55, any: 0.7 }
};

/**
 * Growth type modifiers.
 */
const GROWTH_TYPE_MODIFIERS: Record<string, Record<TrajectoryVelocity, number>> = {
  high_growth: { fast: 1.1, normal: 1.0, slow: 0.85 },
  stable: { fast: 0.95, normal: 1.05, slow: 1.0 },
  pivot_friendly: { fast: 1.0, normal: 1.0, slow: 1.0 }
};
```

**Fit Scorer:**
```typescript
/**
 * Calculates trajectory fit score (0-1) based on candidate trajectory and role requirements.
 *
 * Scoring formula:
 * 1. Base score from direction + velocity combination
 * 2. Track alignment adjustment (technical_growth for IC roles, leadership_track for manager roles)
 * 3. Growth type modifier (high_growth rewards fast velocity)
 * 4. Pivot handling (bonus if role is pivot-friendly and candidate is pivoting)
 *
 * @param metrics - Computed trajectory metrics (direction, velocity, type)
 * @param context - Role requirements for fit scoring
 * @returns Normalized score 0-1, 0.5 if insufficient data
 */
export function calculateTrajectoryFit(
  metrics: TrajectoryMetrics | null | undefined,
  context: TrajectoryContext
): number {
  // Return neutral if no metrics
  if (!metrics) {
    return 0.5;
  }

  const { direction, velocity, type } = metrics;
  const { targetTrack = 'any', roleGrowthType = 'stable', allowPivot = true } = context;

  // 1. Base score from direction + velocity
  let score = DIRECTION_VELOCITY_SCORES[direction]?.[velocity] ?? 0.5;

  // 2. Track alignment adjustment
  const trackScore = TRACK_ALIGNMENT_SCORES[type]?.[targetTrack] ?? 0.7;
  score = score * 0.6 + trackScore * 0.4; // Weighted combination

  // 3. Growth type modifier
  const growthModifier = GROWTH_TYPE_MODIFIERS[roleGrowthType]?.[velocity] ?? 1.0;
  score *= growthModifier;

  // 4. Pivot handling
  if (type === 'career_pivot') {
    if (allowPivot) {
      // Small bonus for pivot-friendly roles
      score = Math.min(1.0, score + 0.1);
    } else {
      // Penalty for non-pivot roles
      score = Math.max(0.2, score - 0.15);
    }
  }

  // 5. Downward trajectory handling
  if (direction === 'downward') {
    if (allowPivot) {
      // Downward can be acceptable for pivots (intentional level reset)
      score = Math.max(0.4, score);
    } else {
      // Penalty for non-pivot contexts
      score = Math.max(0.2, score - 0.1);
    }
  }

  // 6. Upward bonus for any context
  if (direction === 'upward') {
    score = Math.min(1.0, score + 0.05);
  }

  // Clamp to 0-1 range
  return Math.max(0, Math.min(1, score));
}
```

**Convenience Function:**
```typescript
/**
 * Computes complete trajectory metrics from experience data.
 *
 * @param experience - Experience entries with titles and dates
 * @param togetherAI - Optional Together AI trajectory data
 * @returns Computed trajectory metrics
 */
export function computeTrajectoryMetrics(
  experience: ExperienceEntry[],
  togetherAI?: TogetherAITrajectory
): TrajectoryMetrics {
  const titles = experience.map(e => e.title);

  return {
    direction: calculateTrajectoryDirection(titles),
    velocity: calculateTrajectoryVelocity(experience, togetherAI),
    type: classifyTrajectoryType(titles)
  };
}
```
  </action>
  <verify>
Run TypeScript compilation:
```bash
cd /Volumes/Extreme\ Pro/myprojects/headhunter/services/hh-search-svc && npx tsc --noEmit
```
  </verify>
  <done>
calculateTrajectoryFit and computeTrajectoryMetrics functions added. TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate trajectory scoring into scoring.ts</name>
  <files>services/hh-search-svc/src/scoring.ts</files>
  <action>
Update `scoring.ts` to use the new trajectory calculators:

**Add import:**
```typescript
import {
  calculateTrajectoryFit,
  computeTrajectoryMetrics,
  type ExperienceEntry,
  type TogetherAITrajectory,
  type TrajectoryContext
} from './trajectory-calculators';
```

**Extend SignalComputationContext:**
Add these fields to the existing `SignalComputationContext` interface:
```typescript
export interface SignalComputationContext {
  // ... existing fields ...

  /** Target track for trajectory scoring */
  targetTrack?: 'technical' | 'management' | 'any';
  /** Role growth type for trajectory scoring */
  roleGrowthType?: 'high_growth' | 'stable' | 'pivot_friendly';
  /** Whether role allows career pivots */
  allowPivot?: boolean;
}
```

**Update extractSignalScores to compute Phase 8 trajectory signal:**

In the `extractSignalScores` function, after the Phase 7 signals computation, add:

```typescript
// Phase 8: Trajectory fit signal
if (signalContext) {
  // Extract experience data for trajectory analysis
  const candidateExperience = extractCandidateExperience(row);

  // Extract Together AI trajectory data if available
  const togetherAITrajectory = extractTogetherAITrajectory(row);

  // Compute trajectory metrics
  const trajectoryMetrics = computeTrajectoryMetrics(candidateExperience, togetherAITrajectory);

  // Build trajectory context from search context
  const trajectoryContext: TrajectoryContext = {
    targetLevel: signalContext.targetLevel,
    targetTrack: signalContext.targetTrack || inferTargetTrack(signalContext.roleType),
    roleGrowthType: signalContext.roleGrowthType || 'stable',
    allowPivot: signalContext.allowPivot ?? true
  };

  // Compute trajectory fit score (overrides the default _trajectory_score from metadata)
  scores.trajectoryFit = calculateTrajectoryFit(trajectoryMetrics, trajectoryContext);
}
```

**Add helper functions:**

```typescript
/**
 * Extract Together AI trajectory data from row metadata.
 */
function extractTogetherAITrajectory(row: PgHybridSearchRow): TogetherAITrajectory | undefined {
  const metadata = row.metadata as Record<string, unknown> | null;

  if (metadata?.intelligent_analysis) {
    const analysis = metadata.intelligent_analysis as Record<string, unknown>;
    if (analysis.career_trajectory_analysis) {
      return analysis.career_trajectory_analysis as TogetherAITrajectory;
    }
  }

  if (metadata?.career_trajectory_analysis) {
    return metadata.career_trajectory_analysis as TogetherAITrajectory;
  }

  return undefined;
}

/**
 * Infer target track from role type.
 */
function inferTargetTrack(roleType?: string): 'technical' | 'management' | 'any' {
  if (!roleType) return 'any';

  switch (roleType) {
    case 'executive':
    case 'manager':
      return 'management';
    case 'ic':
      return 'technical';
    default:
      return 'any';
  }
}
```
  </action>
  <verify>
Run TypeScript compilation:
```bash
cd /Volumes/Extreme\ Pro/myprojects/headhunter/services/hh-search-svc && npx tsc --noEmit
```
  </verify>
  <done>
Trajectory fit scoring integrated into extractSignalScores. TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for trajectory fit scorer</name>
  <files>services/hh-search-svc/src/trajectory-calculators.test.ts</files>
  <action>
Add the following test cases to `trajectory-calculators.test.ts`:

```typescript
import {
  calculateTrajectoryFit,
  computeTrajectoryMetrics,
  type TrajectoryMetrics,
  type TrajectoryContext
} from './trajectory-calculators';

describe('calculateTrajectoryFit', () => {
  describe('high fit scores', () => {
    it('scores 0.9+ for upward+fast candidate in high-growth role', () => {
      const metrics: TrajectoryMetrics = {
        direction: 'upward',
        velocity: 'fast',
        type: 'technical_growth'
      };
      const context: TrajectoryContext = {
        targetTrack: 'technical',
        roleGrowthType: 'high_growth'
      };
      expect(calculateTrajectoryFit(metrics, context)).toBeGreaterThanOrEqual(0.9);
    });

    it('scores 0.85+ for leadership track in management role', () => {
      const metrics: TrajectoryMetrics = {
        direction: 'upward',
        velocity: 'normal',
        type: 'leadership_track'
      };
      const context: TrajectoryContext = {
        targetTrack: 'management',
        roleGrowthType: 'stable'
      };
      expect(calculateTrajectoryFit(metrics, context)).toBeGreaterThanOrEqual(0.85);
    });
  });

  describe('track mismatch penalties', () => {
    it('penalizes technical candidate for management role', () => {
      const metrics: TrajectoryMetrics = {
        direction: 'upward',
        velocity: 'normal',
        type: 'technical_growth'
      };

      const technicalScore = calculateTrajectoryFit(metrics, { targetTrack: 'technical' });
      const managementScore = calculateTrajectoryFit(metrics, { targetTrack: 'management' });

      expect(managementScore).toBeLessThan(technicalScore);
    });

    it('penalizes leadership candidate for technical role', () => {
      const metrics: TrajectoryMetrics = {
        direction: 'upward',
        velocity: 'normal',
        type: 'leadership_track'
      };

      const technicalScore = calculateTrajectoryFit(metrics, { targetTrack: 'technical' });
      const managementScore = calculateTrajectoryFit(metrics, { targetTrack: 'management' });

      expect(technicalScore).toBeLessThan(managementScore);
    });
  });

  describe('pivot handling', () => {
    it('allows pivots in pivot-friendly roles', () => {
      const metrics: TrajectoryMetrics = {
        direction: 'lateral',
        velocity: 'normal',
        type: 'career_pivot'
      };

      const pivotFriendly = calculateTrajectoryFit(metrics, { allowPivot: true });
      const noPivot = calculateTrajectoryFit(metrics, { allowPivot: false });

      expect(pivotFriendly).toBeGreaterThan(noPivot);
    });
  });

  describe('downward trajectory', () => {
    it('scores lower for downward trajectory', () => {
      const upward: TrajectoryMetrics = { direction: 'upward', velocity: 'normal', type: 'technical_growth' };
      const downward: TrajectoryMetrics = { direction: 'downward', velocity: 'normal', type: 'technical_growth' };
      const context: TrajectoryContext = { targetTrack: 'technical' };

      expect(calculateTrajectoryFit(downward, context)).toBeLessThan(
        calculateTrajectoryFit(upward, context)
      );
    });

    it('allows downward in pivot-friendly context', () => {
      const metrics: TrajectoryMetrics = {
        direction: 'downward',
        velocity: 'normal',
        type: 'career_pivot'
      };

      const score = calculateTrajectoryFit(metrics, { allowPivot: true });
      expect(score).toBeGreaterThanOrEqual(0.4);
    });
  });

  describe('neutral cases', () => {
    it('returns 0.5 when metrics are null', () => {
      expect(calculateTrajectoryFit(null, {})).toBe(0.5);
    });

    it('returns 0.5 when metrics are undefined', () => {
      expect(calculateTrajectoryFit(undefined, {})).toBe(0.5);
    });
  });
});

describe('computeTrajectoryMetrics', () => {
  it('computes all three metrics from experience', () => {
    const experience: ExperienceEntry[] = [
      { title: 'Junior Engineer', startDate: '2018-01-01', endDate: '2020-01-01' },
      { title: 'Senior Engineer', startDate: '2020-02-01', endDate: '2022-01-01' },
      { title: 'Staff Engineer', startDate: '2022-02-01', isCurrent: true }
    ];

    const metrics = computeTrajectoryMetrics(experience);

    expect(metrics.direction).toBe('upward');
    expect(metrics.type).toBe('technical_growth');
    expect(['fast', 'normal', 'slow']).toContain(metrics.velocity);
  });
});
```
  </action>
  <verify>
Run all tests:
```bash
cd /Volumes/Extreme\ Pro/myprojects/headhunter/services/hh-search-svc && npm test -- trajectory-calculators.test.ts
```
All tests should pass.
  </verify>
  <done>
Unit tests for trajectory fit scorer pass. TRAJ-03 implementation complete.
  </done>
</task>

</tasks>

<verification>
1. `calculateTrajectoryFit` returns 0-1 score based on trajectory/role alignment
2. Track mismatch (technical candidate for management role) reduces score
3. Pivot handling respects `allowPivot` context flag
4. Integration with `scoring.ts` uses computed trajectory rather than metadata fallback
5. All unit tests pass
6. TypeScript compilation passes
</verification>

<success_criteria>
- TRAJ-03: Trajectory fit score (0-1) computed for role alignment
- Fit scoring considers direction, velocity, type, and role requirements
- High-growth roles reward fast velocity
- Management roles reward leadership track
- Career pivots handled with context-aware scoring
- Integration into Phase 7 scoring pipeline complete
</success_criteria>

<output>
After completion, create `.planning/phases/08-career-trajectory/08-03-SUMMARY.md`
</output>
