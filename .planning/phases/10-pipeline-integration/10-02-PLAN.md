---
phase: 10-pipeline-integration
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - services/hh-search-svc/src/search-service.ts
autonomous: true

must_haves:
  truths:
    - "Retrieval stage logs candidate count after hybrid search"
    - "Scoring stage applies cutoff to top N candidates (configurable, default 100)"
    - "Reranking stage produces final top N results (configurable, default 50)"
    - "Each stage transition is logged with count and latency"
  artifacts:
    - path: "services/hh-search-svc/src/search-service.ts"
      provides: "3-stage pipeline with stage handoffs"
      contains: "STAGE 1: RETRIEVAL"
  key_links:
    - from: "services/hh-search-svc/src/search-service.ts"
      to: "config.search.pipelineScoringLimit"
      via: "slice() after ranking"
      pattern: "slice.*pipelineScoringLimit"
---

<objective>
Implement explicit 3-stage pipeline with stage handoffs and logging.

Purpose: Transform the current implicit pipeline into explicit stages with clear cutoffs and logging to meet PIPE-01 through PIPE-04 requirements.

Output: Search service implements retrieval (500+) -> scoring (top 100) -> reranking (top 50) with logged transitions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@services/hh-search-svc/src/search-service.ts
@services/hh-search-svc/src/config.ts
@services/hh-search-svc/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Stage 1 (Retrieval) Logging</name>
  <files>services/hh-search-svc/src/search-service.ts</files>
  <action>
After the `hybridSearch()` call returns rows, add explicit retrieval stage logging:

```typescript
// === STAGE 1: RETRIEVAL (recall-focused) ===
const retrievalStart = Date.now();
const rows = await this.pgClient.hybridSearch({
  // ... existing params
});
const retrievalMs = Date.now() - retrievalStart;

// Stage 1 logging
if (this.config.search.pipelineLogStages) {
  this.logger.info({
    stage: 'STAGE 1: RETRIEVAL',
    requestId: context.requestId,
    count: rows.length,
    target: this.config.search.pipelineRetrievalLimit,
    latencyMs: retrievalMs
  }, 'Pipeline Stage 1 complete - retrieval focused on recall');
}
```

The retrieval limit is already controlled by `perMethodLimit` config (which should be >= pipelineRetrievalLimit / 2 to account for RRF fusion).
  </action>
  <verify>
Grep for "STAGE 1: RETRIEVAL" in search-service.ts.
  </verify>
  <done>
Stage 1 logging appears after hybrid search with count, target, and latency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Stage 2 (Scoring) Cutoff and Logging</name>
  <files>services/hh-search-svc/src/search-service.ts</files>
  <action>
After rankCandidates() returns, add explicit scoring stage cutoff:

```typescript
// === STAGE 2: SCORING (precision-focused) ===
const scoringStart = Date.now();
let candidates = rows.map((row) => this.hydrateResult(row, request, resolvedWeights, roleType));

// ... existing Firestore fallback logic if needed ...

const rankingStart = Date.now();
let ranked = this.rankCandidates(candidates, request);
const rankingMs = Date.now() - rankingStart;

// Apply scoring stage cutoff - keep only top N for reranking
const preScoringCount = ranked.length;
const scoringLimit = this.config.search.pipelineScoringLimit;
ranked = ranked.slice(0, scoringLimit);
const scoringMs = Date.now() - scoringStart;

// Stage 2 logging
if (this.config.search.pipelineLogStages) {
  this.logger.info({
    stage: 'STAGE 2: SCORING',
    requestId: context.requestId,
    inputCount: preScoringCount,
    outputCount: ranked.length,
    cutoff: scoringLimit,
    latencyMs: scoringMs
  }, 'Pipeline Stage 2 complete - scoring focused on precision');
}
```

This ensures only the top 100 (by default) candidates proceed to LLM reranking.
  </action>
  <verify>
Grep for "STAGE 2: SCORING" in search-service.ts.
Grep for "pipelineScoringLimit" in search-service.ts.
  </verify>
  <done>
Stage 2 applies slice() cutoff to limit candidates before reranking.
Stage 2 logging shows input count, output count, cutoff, and latency.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Stage 3 (Reranking) Cutoff and Logging</name>
  <files>services/hh-search-svc/src/search-service.ts</files>
  <action>
After reranking completes (or passthrough if disabled), add final stage logging:

```typescript
// === STAGE 3: RERANKING (nuance via LLM) ===
const rerankStart = Date.now();
const rerankOutcome = await this.applyRerankIfEnabled(context, request, ranked, scoringLimit);

if (rerankOutcome) {
  ranked = rerankOutcome.results;
  if (rerankOutcome.timingsMs !== undefined) {
    timings.rerankMs = rerankOutcome.timingsMs;
  }
}

// Apply final rerank cutoff
const preRerankCount = ranked.length;
const rerankLimit = this.config.search.pipelineRerankLimit;
ranked = ranked.slice(0, rerankLimit);
const rerankMs = Date.now() - rerankStart;

// Stage 3 logging
if (this.config.search.pipelineLogStages) {
  this.logger.info({
    stage: 'STAGE 3: RERANKING',
    requestId: context.requestId,
    inputCount: preRerankCount,
    outputCount: ranked.length,
    cutoff: rerankLimit,
    rerankApplied: Boolean(rerankOutcome && !rerankOutcome.metadata?.usedFallback),
    llmProvider: rerankOutcome?.metadata?.llmProvider ?? 'none',
    latencyMs: rerankMs
  }, 'Pipeline Stage 3 complete - LLM reranking for nuance');
}
```

Update the limit passed to applyRerankIfEnabled to use scoringLimit (the candidates going into rerank), and final cutoff uses pipelineRerankLimit.
  </action>
  <verify>
Grep for "STAGE 3: RERANKING" in search-service.ts.
Grep for "pipelineRerankLimit" in search-service.ts.
  </verify>
  <done>
Stage 3 applies final slice() cutoff after reranking.
Stage 3 logging shows input count, output count, rerank status, LLM provider, and latency.
  </done>
</task>

</tasks>

<verification>
1. `npm run build --prefix services/hh-search-svc` compiles without errors
2. `grep -n "STAGE 1: RETRIEVAL" services/hh-search-svc/src/search-service.ts` returns line(s)
3. `grep -n "STAGE 2: SCORING" services/hh-search-svc/src/search-service.ts` returns line(s)
4. `grep -n "STAGE 3: RERANKING" services/hh-search-svc/src/search-service.ts` returns line(s)
5. `grep -n "pipelineScoringLimit\|pipelineRerankLimit" services/hh-search-svc/src/search-service.ts` shows both limits used
</verification>

<success_criteria>
1. Stage 1 logs retrieval count and latency after hybrid search
2. Stage 2 applies cutoff to top 100 (configurable) before reranking
3. Stage 3 applies final cutoff to top 50 (configurable) after reranking
4. All three stages log transitions with counts and latency
5. Logs include stage name, request ID, input/output counts, and timing
6. TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/10-pipeline-integration/10-02-SUMMARY.md`
</output>
