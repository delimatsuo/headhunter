---
phase: 07-signal-scoring
plan: 04
type: execute
wave: 3
depends_on: ["07-01", "07-02", "07-03"]
files_modified:
  - services/hh-search-svc/src/scoring.ts
  - services/hh-search-svc/src/search-service.ts
autonomous: true

must_haves:
  truths:
    - "extractSignalScores computes Phase 7 signals from row data and search context"
    - "computeWeightedScore includes Phase 7 signals in weighted sum"
    - "Search results include Phase 7 signal scores when context is provided"
    - "Candidates with high skills match rank higher than those with low match"
    - "Candidates with recent skill usage rank higher than those with old usage"
  artifacts:
    - path: "services/hh-search-svc/src/scoring.ts"
      provides: "Updated extractSignalScores with Phase 7 signal computation"
      contains: "calculateSkillsExactMatch"
    - path: "services/hh-search-svc/src/search-service.ts"
      provides: "Search context passed to extractSignalScores"
      contains: "searchContext"
  key_links:
    - from: "scoring.ts"
      to: "signal-calculators.ts"
      via: "import calculators"
      pattern: "import.*from.*signal-calculators"
    - from: "search-service.ts"
      to: "scoring.ts"
      via: "extractSignalScores call with context"
      pattern: "extractSignalScores\\(row,.*searchContext"
---

<objective>
Integrate Phase 7 signal calculators into the scoring system and search service.

Purpose: Wire up the new signal functions so they contribute to candidate ranking.

Output: Updated scoring.ts and search-service.ts that compute and use Phase 7 signals.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-signal-scoring/07-RESEARCH.md
@.planning/phases/07-signal-scoring/07-01-SUMMARY.md (if exists)
@.planning/phases/07-signal-scoring/07-02-SUMMARY.md (if exists)
@.planning/phases/07-signal-scoring/07-03-SUMMARY.md (if exists)

Key existing files:
@services/hh-search-svc/src/scoring.ts - extractSignalScores, computeWeightedScore
@services/hh-search-svc/src/search-service.ts - hydrateResult, hybridSearch
@services/hh-search-svc/src/signal-calculators.ts - Phase 7 calculators
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update scoring.ts with Phase 7 signal computation</name>
  <files>services/hh-search-svc/src/scoring.ts</files>
  <action>
Modify scoring.ts to:
1. Import Phase 7 calculators
2. Add SearchContext interface
3. Update extractSignalScores to accept optional search context
4. Update computeWeightedScore to include Phase 7 signals

Add imports at top:
```typescript
import {
  calculateSkillsExactMatch,
  calculateSkillsInferred,
  calculateSeniorityAlignment,
  calculateRecencyBoost,
  calculateCompanyRelevance,
  detectCompanyTier,
  type SkillMatchContext,
  type SeniorityContext,
  type CompanyContext,
  type CandidateExperience
} from './signal-calculators';
```

Add SearchContext interface:
```typescript
/**
 * Search context for Phase 7 signal computation.
 * Provides the query-side data needed to compute match scores.
 */
export interface SearchContext {
  requiredSkills?: string[];
  preferredSkills?: string[];
  targetLevel?: string;
  targetCompanies?: string[];
  targetIndustries?: string[];
  roleType?: 'executive' | 'manager' | 'ic' | 'default';
}
```

Update extractSignalScores signature:
```typescript
/**
 * Extracts signal scores from a PgHybridSearchRow.
 * When searchContext is provided, also computes Phase 7 signals.
 *
 * @param row - Database row with scores
 * @param searchContext - Optional search context for Phase 7 signals
 * @returns SignalScores with all signals extracted and normalized
 */
export function extractSignalScores(
  row: PgHybridSearchRow,
  searchContext?: SearchContext
): SignalScores {
  // Existing Phase 4 signal extraction
  const rawVector = Number(row.vector_score ?? 0);
  const vectorSimilarity = rawVector > 1 ? rawVector / 100 : rawVector;
  const metadata = row.metadata as Record<string, unknown> | null;

  const scores: SignalScores = {
    vectorSimilarity,
    levelMatch: extractScore(metadata, '_level_score'),
    specialtyMatch: extractScore(metadata, '_specialty_score'),
    techStackMatch: extractScore(metadata, '_tech_stack_score'),
    functionMatch: extractScore(metadata, '_function_title_score'),
    trajectoryFit: extractScore(metadata, '_trajectory_score'),
    companyPedigree: extractScore(metadata, '_company_score')
  };

  // Phase 7 signals (only compute if context provided)
  if (searchContext) {
    const candidateSkills = extractCandidateSkills(row);
    const candidateExperience = extractCandidateExperience(row);
    const candidateCompanies = extractCandidateCompanies(row);
    const candidateIndustries = (row.industries || []) as string[];
    const candidateLevel = extractCandidateLevel(row);
    const companyTier = detectCompanyTier(candidateCompanies);

    // SCOR-02: Skills exact match
    scores.skillsExactMatch = calculateSkillsExactMatch(candidateSkills, {
      requiredSkills: searchContext.requiredSkills || [],
      preferredSkills: searchContext.preferredSkills || []
    });

    // SCOR-03: Skills inferred
    scores.skillsInferred = calculateSkillsInferred(candidateSkills, {
      requiredSkills: searchContext.requiredSkills || [],
      preferredSkills: searchContext.preferredSkills || []
    });

    // SCOR-04: Seniority alignment
    scores.seniorityAlignment = calculateSeniorityAlignment(
      candidateLevel,
      companyTier,
      {
        targetLevel: searchContext.targetLevel || 'mid',
        roleType: searchContext.roleType || 'default'
      }
    );

    // SCOR-05: Recency boost
    scores.recencyBoost = calculateRecencyBoost(
      candidateExperience,
      searchContext.requiredSkills || []
    );

    // SCOR-06: Company relevance
    scores.companyRelevance = calculateCompanyRelevance(
      candidateCompanies,
      candidateIndustries,
      companyTier,
      {
        targetCompanies: searchContext.targetCompanies,
        targetIndustries: searchContext.targetIndustries
      }
    );
  }

  return scores;
}
```

Add helper functions for data extraction:
```typescript
/**
 * Extract candidate skills from row data
 */
function extractCandidateSkills(row: PgHybridSearchRow): string[] {
  const skills: string[] = [];

  // From skills array
  if (row.skills) {
    skills.push(...row.skills);
  }

  // From metadata intelligent_analysis
  const metadata = row.metadata as Record<string, unknown> | null;
  if (metadata?.intelligent_analysis) {
    const analysis = metadata.intelligent_analysis as Record<string, unknown>;

    // Explicit skills
    if (analysis.explicit_skills) {
      const explicit = analysis.explicit_skills as Record<string, unknown>;
      if (Array.isArray(explicit.technical_skills)) {
        explicit.technical_skills.forEach((s: unknown) => {
          if (typeof s === 'string') skills.push(s);
          else if (s && typeof s === 'object' && 'skill' in s) skills.push(String((s as {skill: string}).skill));
        });
      }
    }
  }

  return [...new Set(skills)];
}

/**
 * Extract candidate level from row data
 */
function extractCandidateLevel(row: PgHybridSearchRow): string | null {
  const metadata = row.metadata as Record<string, unknown> | null;

  if (metadata?.intelligent_analysis) {
    const analysis = metadata.intelligent_analysis as Record<string, unknown>;
    if (analysis.career_trajectory_analysis) {
      const trajectory = analysis.career_trajectory_analysis as Record<string, unknown>;
      if (trajectory.current_level) return String(trajectory.current_level);
    }
  }

  if (metadata?.current_level) return String(metadata.current_level);
  return null;
}

/**
 * Extract candidate companies from row data
 */
function extractCandidateCompanies(row: PgHybridSearchRow): string[] {
  const companies: string[] = [];
  const metadata = row.metadata as Record<string, unknown> | null;

  if (metadata?.intelligent_analysis) {
    const analysis = metadata.intelligent_analysis as Record<string, unknown>;
    if (Array.isArray(analysis.experience)) {
      (analysis.experience as Array<{company?: string}>).forEach(exp => {
        if (exp.company) companies.push(exp.company);
      });
    }
  }

  return [...new Set(companies)];
}

/**
 * Extract candidate experience for recency calculation
 */
function extractCandidateExperience(row: PgHybridSearchRow): CandidateExperience[] {
  const experience: CandidateExperience[] = [];
  const metadata = row.metadata as Record<string, unknown> | null;

  if (metadata?.intelligent_analysis) {
    const analysis = metadata.intelligent_analysis as Record<string, unknown>;
    if (Array.isArray(analysis.experience)) {
      (analysis.experience as Array<Record<string, unknown>>).forEach(exp => {
        experience.push({
          title: String(exp.title || ''),
          skills: Array.isArray(exp.skills) ? exp.skills.map(String) : [],
          startDate: exp.start_date as string | undefined,
          endDate: exp.end_date as string | null | undefined,
          isCurrent: Boolean(exp.is_current)
        });
      });
    }
  }

  return experience;
}
```

Update computeWeightedScore to include Phase 7 signals:
```typescript
export function computeWeightedScore(
  signals: Partial<SignalScores>,
  weights: SignalWeightConfig
): number {
  // Core signals (default to 0.5 if missing)
  const vs = signals.vectorSimilarity ?? 0.5;
  const lm = signals.levelMatch ?? 0.5;
  const sm = signals.specialtyMatch ?? 0.5;
  const ts = signals.techStackMatch ?? 0.5;
  const fm = signals.functionMatch ?? 0.5;
  const tf = signals.trajectoryFit ?? 0.5;
  const cp = signals.companyPedigree ?? 0.5;

  let score = 0;
  score += vs * weights.vectorSimilarity;
  score += lm * weights.levelMatch;
  score += sm * weights.specialtyMatch;
  score += ts * weights.techStackMatch;
  score += fm * weights.functionMatch;
  score += tf * weights.trajectoryFit;
  score += cp * weights.companyPedigree;

  // Optional skillsMatch (existing)
  if (signals.skillsMatch !== undefined && weights.skillsMatch) {
    score += signals.skillsMatch * weights.skillsMatch;
  }

  // Phase 7 signals (only add if both signal and weight exist)
  if (signals.skillsExactMatch !== undefined && weights.skillsExactMatch) {
    score += signals.skillsExactMatch * weights.skillsExactMatch;
  }
  if (signals.skillsInferred !== undefined && weights.skillsInferred) {
    score += signals.skillsInferred * weights.skillsInferred;
  }
  if (signals.seniorityAlignment !== undefined && weights.seniorityAlignment) {
    score += signals.seniorityAlignment * weights.seniorityAlignment;
  }
  if (signals.recencyBoost !== undefined && weights.recencyBoost) {
    score += signals.recencyBoost * weights.recencyBoost;
  }
  if (signals.companyRelevance !== undefined && weights.companyRelevance) {
    score += signals.companyRelevance * weights.companyRelevance;
  }

  return score;
}
```
  </action>
  <verify>
TypeScript compiles: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
Verify imports from signal-calculators work
Verify extractSignalScores accepts optional searchContext parameter
  </verify>
  <done>scoring.ts updated with Phase 7 signal computation</done>
</task>

<task type="auto">
  <name>Task 2: Update search-service.ts to pass search context</name>
  <files>services/hh-search-svc/src/search-service.ts</files>
  <action>
Modify search-service.ts hydrateResult to build and pass search context.

Add import for SearchContext:
```typescript
import { computeWeightedScore, extractSignalScores, normalizeVectorScore, completeSignalScores, type SearchContext } from './scoring';
```

Update hydrateResult to build search context from request:
```typescript
private hydrateResult(
  row: PgHybridSearchRow,
  request: HybridSearchRequest,
  resolvedWeights: SignalWeightConfig,
  roleType: RoleType
): HybridSearchResultItem {
  const requestedSkills = request.filters?.skills ?? [];
  const { matches, normalizedMatches, coverage } = computeSkillMatches(row.skills ?? undefined, requestedSkills);

  const matchReasons: string[] = [];
  // ... existing match reasons logic ...

  const baseVector = Number(row.vector_score ?? 0);
  const baseText = Number(row.text_score ?? 0);

  // Build search context for Phase 7 signals
  const searchContext: SearchContext = {
    requiredSkills: request.filters?.skills,
    preferredSkills: [], // Could be extended in future
    targetLevel: this.detectTargetLevel(request),
    targetCompanies: this.extractTargetCompanies(request),
    targetIndustries: request.filters?.industries,
    roleType
  };

  // Extract signal scores WITH Phase 7 computation
  const signalScores = extractSignalScores(row, searchContext);

  // Override vectorSimilarity with normalized value
  signalScores.vectorSimilarity = normalizeVectorScore(row.vector_score);

  // Compute weighted score from all signals (including Phase 7)
  const weightedScore = computeWeightedScore(signalScores, resolvedWeights);

  // ... rest of existing code ...
}
```

Add helper methods for extracting search context:
```typescript
/**
 * Detect target seniority level from request
 */
private detectTargetLevel(request: HybridSearchRequest): string {
  // Check explicit seniority filter
  if (request.filters?.seniorityLevels?.length) {
    return request.filters.seniorityLevels[0];
  }

  // Try to detect from job description or query
  const text = (request.jobDescription || request.query || '').toLowerCase();

  if (text.includes('director') || text.includes('vp') || text.includes('vice president')) {
    return 'director';
  }
  if (text.includes('manager') || text.includes('lead')) {
    return 'manager';
  }
  if (text.includes('staff') || text.includes('principal')) {
    return 'staff';
  }
  if (text.includes('senior') || text.includes('sr.')) {
    return 'senior';
  }
  if (text.includes('junior') || text.includes('entry')) {
    return 'junior';
  }

  return 'mid'; // Default
}

/**
 * Extract target companies from request metadata
 */
private extractTargetCompanies(request: HybridSearchRequest): string[] | undefined {
  // Could be extended to parse from job description
  // For now, check if metadata has target companies
  if (request.filters?.metadata?.targetCompanies) {
    const companies = request.filters.metadata.targetCompanies;
    return Array.isArray(companies) ? companies.map(String) : undefined;
  }
  return undefined;
}
```
  </action>
  <verify>
TypeScript compiles: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
Verify SearchContext is imported from scoring.ts
Verify hydrateResult builds searchContext and passes to extractSignalScores
  </verify>
  <done>search-service.ts updated to pass search context for Phase 7 signals</done>
</task>

<task type="auto">
  <name>Task 3: Add Phase 7 signal logging for debugging</name>
  <files>services/hh-search-svc/src/search-service.ts</files>
  <action>
Add logging to track Phase 7 signal computation for debugging and monitoring.

In hybridSearch method, after ranking but before returning, add:
```typescript
// Log Phase 7 signal statistics for debugging
if (ranked.length > 0) {
  const phase7Stats = {
    avgSkillsExact: 0,
    avgSkillsInferred: 0,
    avgSeniority: 0,
    avgRecency: 0,
    avgCompanyRelevance: 0,
    candidatesWithPhase7: 0
  };

  for (const r of ranked.slice(0, 20)) { // Sample top 20
    if (r.signalScores?.skillsExactMatch !== undefined) {
      phase7Stats.avgSkillsExact += r.signalScores.skillsExactMatch;
      phase7Stats.avgSkillsInferred += r.signalScores.skillsInferred ?? 0;
      phase7Stats.avgSeniority += r.signalScores.seniorityAlignment ?? 0;
      phase7Stats.avgRecency += r.signalScores.recencyBoost ?? 0;
      phase7Stats.avgCompanyRelevance += r.signalScores.companyRelevance ?? 0;
      phase7Stats.candidatesWithPhase7++;
    }
  }

  if (phase7Stats.candidatesWithPhase7 > 0) {
    const n = phase7Stats.candidatesWithPhase7;
    this.logger.info(
      {
        requestId: context.requestId,
        phase7Signals: {
          sampleSize: n,
          avgSkillsExact: (phase7Stats.avgSkillsExact / n).toFixed(3),
          avgSkillsInferred: (phase7Stats.avgSkillsInferred / n).toFixed(3),
          avgSeniority: (phase7Stats.avgSeniority / n).toFixed(3),
          avgRecency: (phase7Stats.avgRecency / n).toFixed(3),
          avgCompanyRelevance: (phase7Stats.avgCompanyRelevance / n).toFixed(3)
        }
      },
      'Phase 7 signal statistics computed.'
    );
  }
}
```

Also update the debug output to include Phase 7 breakdown:
```typescript
if (request.includeDebug) {
  response.debug = {
    // ... existing fields ...
    phase7Breakdown: ranked.slice(0, 5).map(r => ({
      candidateId: r.candidateId,
      skillsExactMatch: r.signalScores?.skillsExactMatch,
      skillsInferred: r.signalScores?.skillsInferred,
      seniorityAlignment: r.signalScores?.seniorityAlignment,
      recencyBoost: r.signalScores?.recencyBoost,
      companyRelevance: r.signalScores?.companyRelevance
    }))
  };
}
```
  </action>
  <verify>
TypeScript compiles: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
Search with includeDebug=true returns phase7Breakdown in debug object
  </verify>
  <done>Phase 7 signal logging added for debugging and monitoring</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
2. extractSignalScores computes Phase 7 signals when context provided
3. computeWeightedScore includes Phase 7 signals in weighted sum
4. Search results include Phase 7 signal scores
5. Debug output includes phase7Breakdown
6. Logs show Phase 7 signal statistics
</verification>

<success_criteria>
1. scoring.ts updated with Phase 7 signal computation
2. search-service.ts passes search context to extractSignalScores
3. Phase 7 signals appear in search results signalScores object
4. Debug output includes phase7Breakdown for top candidates
5. Log output shows Phase 7 signal statistics
6. All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-signal-scoring/07-04-SUMMARY.md`
</output>
