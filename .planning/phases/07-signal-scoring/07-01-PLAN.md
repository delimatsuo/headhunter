---
phase: 07-signal-scoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/hh-search-svc/src/signal-calculators.ts
autonomous: true

must_haves:
  truths:
    - "calculateSkillsExactMatch returns 0-1 score based on required skill coverage"
    - "calculateSkillsInferred returns 0-1 score for related/transferable skill matches"
    - "calculateSeniorityAlignment returns 0-1 score adjusted by company tier"
    - "calculateRecencyBoost returns 0-1 score with decay for older skill usage"
    - "calculateCompanyRelevance returns 0-1 score combining tier, target, and industry"
    - "All functions return 0.5 (neutral) when data is missing"
  artifacts:
    - path: "services/hh-search-svc/src/signal-calculators.ts"
      provides: "Five pure scoring functions for Phase 7 signals"
      exports: ["calculateSkillsExactMatch", "calculateSkillsInferred", "calculateSeniorityAlignment", "calculateRecencyBoost", "calculateCompanyRelevance"]
  key_links:
    - from: "signal-calculators.ts"
      to: "functions/src/shared/skills-service.ts"
      via: "skillsMatch import"
      pattern: "import.*skillsMatch.*from"
    - from: "signal-calculators.ts"
      to: "functions/src/shared/skills-graph.ts"
      via: "getCachedSkillExpansion import"
      pattern: "getCachedSkillExpansion"
---

<objective>
Create the signal-calculators.ts module containing 5 pure scoring functions for Phase 7 signals.

Purpose: Implement SCOR-02 through SCOR-06 as pure functions that compute 0-1 normalized scores from candidate data and search context.

Output: New file services/hh-search-svc/src/signal-calculators.ts with 5 exported functions and helper types.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-signal-scoring/07-RESEARCH.md

Key existing files:
@functions/src/shared/skills-service.ts - normalizeSkillName(), skillsMatch(), getCachedSkillExpansion()
@functions/src/shared/skills-graph.ts - SkillExpansionResult type
@functions/src/shared/skills-inference.ts - findTransferableSkills()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create signal-calculators.ts with context interfaces</name>
  <files>services/hh-search-svc/src/signal-calculators.ts</files>
  <action>
Create a new file services/hh-search-svc/src/signal-calculators.ts with:

1. Module header documentation explaining the 5 signal calculators
2. Import dependencies:
   - skillsMatch from skills-service (use relative path to functions/src/shared or copy normalizeSkillName logic)
   - NOTE: The hh-search-svc cannot directly import from functions/ - implement skill matching inline or use the normalized comparison pattern

3. Define context interfaces:
```typescript
export interface SkillMatchContext {
  requiredSkills: string[];
  preferredSkills: string[];
}

export interface SeniorityContext {
  targetLevel: string;
  roleType: 'executive' | 'manager' | 'ic' | 'default';
}

export interface CompanyContext {
  targetCompanies?: string[];
  targetIndustries?: string[];
}

export interface CandidateExperience {
  title: string;
  skills: string[];
  startDate?: string | Date;
  endDate?: string | Date | null;
  isCurrent: boolean;
}
```

4. Define the LEVEL_ORDER constant for seniority alignment:
```typescript
const LEVEL_ORDER = [
  'intern', 'junior', 'mid', 'senior', 'staff', 'principal',
  'manager', 'director', 'vp', 'c-level'
];
```

5. Define TOP_COMPANIES constant for company tier detection (copy from existing codebase or research shows common list):
```typescript
const FAANG_COMPANIES = ['google', 'meta', 'facebook', 'amazon', 'microsoft', 'apple', 'netflix'];
const UNICORN_COMPANIES = ['nubank', 'ifood', 'mercado libre', 'stripe', 'uber', 'airbnb', 'spotify'];
```

The file structure should be clear with sections for types, constants, helper functions, and the 5 main calculator exports.
  </action>
  <verify>
File exists at services/hh-search-svc/src/signal-calculators.ts with:
- TypeScript compiles: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
- All 4 interfaces defined
- LEVEL_ORDER and company arrays defined
  </verify>
  <done>signal-calculators.ts created with type definitions and constants</done>
</task>

<task type="auto">
  <name>Task 2: Implement calculateSkillsExactMatch (SCOR-02)</name>
  <files>services/hh-search-svc/src/signal-calculators.ts</files>
  <action>
Add the calculateSkillsExactMatch function to signal-calculators.ts:

```typescript
/**
 * SCOR-02: Skills Exact Match Score (0-1)
 *
 * Measures how many required skills the candidate has.
 * Uses case-insensitive comparison with alias awareness.
 *
 * @param candidateSkills - Skills the candidate has
 * @param context - Required and preferred skills from search
 * @returns Score 0-1 where 1.0 = all required skills matched
 */
export function calculateSkillsExactMatch(
  candidateSkills: string[],
  context: SkillMatchContext
): number {
  // Return neutral if no required skills specified
  if (!context.requiredSkills || context.requiredSkills.length === 0) {
    return 0.5;
  }

  // Return 0 if candidate has no skills (not neutral - they should have skills)
  if (!candidateSkills || candidateSkills.length === 0) {
    return 0.0;
  }

  // Normalize candidate skills to lowercase for comparison
  const normalizedCandidateSkills = new Set(
    candidateSkills.map(s => s.toLowerCase().trim())
  );

  let matchCount = 0;
  for (const required of context.requiredSkills) {
    const normalizedRequired = required.toLowerCase().trim();

    // Check for exact or alias match
    if (normalizedCandidateSkills.has(normalizedRequired)) {
      matchCount++;
    } else {
      // Check common aliases (JS/JavaScript, K8s/Kubernetes, etc.)
      const aliases = getCommonAliases(normalizedRequired);
      if (aliases.some(alias => normalizedCandidateSkills.has(alias))) {
        matchCount++;
      }
    }
  }

  // Score = ratio of matched to required
  return matchCount / context.requiredSkills.length;
}

// Helper for common skill aliases (subset of full taxonomy for hot path)
function getCommonAliases(skill: string): string[] {
  const COMMON_ALIASES: Record<string, string[]> = {
    'javascript': ['js', 'ecmascript'],
    'typescript': ['ts'],
    'kubernetes': ['k8s'],
    'postgresql': ['postgres', 'psql'],
    'python': ['py'],
    'react': ['reactjs', 'react.js'],
    'node.js': ['node', 'nodejs'],
    'vue.js': ['vue', 'vuejs'],
    'c#': ['csharp', 'c-sharp'],
    'c++': ['cpp'],
  };

  // Bidirectional lookup
  for (const [canonical, aliases] of Object.entries(COMMON_ALIASES)) {
    if (skill === canonical || aliases.includes(skill)) {
      return [canonical, ...aliases];
    }
  }
  return [];
}
```
  </action>
  <verify>
TypeScript compiles: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
Manual verification:
- calculateSkillsExactMatch(['JavaScript', 'Python'], {requiredSkills: ['JS', 'Python'], preferredSkills: []}) returns 1.0
- calculateSkillsExactMatch(['JavaScript'], {requiredSkills: ['JS', 'Python'], preferredSkills: []}) returns 0.5
- calculateSkillsExactMatch([], {requiredSkills: ['JS'], preferredSkills: []}) returns 0.0
- calculateSkillsExactMatch(['JS'], {requiredSkills: [], preferredSkills: []}) returns 0.5
  </verify>
  <done>calculateSkillsExactMatch function implemented with alias support</done>
</task>

<task type="auto">
  <name>Task 3: Implement calculateSkillsInferred (SCOR-03)</name>
  <files>services/hh-search-svc/src/signal-calculators.ts</files>
  <action>
Add the calculateSkillsInferred function to signal-calculators.ts:

```typescript
/**
 * SCOR-03: Skills Inferred Score (0-1)
 *
 * Measures match through related/transferable skills.
 * A candidate with React who is searched for Angular gets partial credit
 * because React â†’ Angular is a transferable skill.
 *
 * @param candidateSkills - Skills the candidate has
 * @param context - Required skills from search
 * @returns Score 0-1 based on transferable skill matches
 */
export function calculateSkillsInferred(
  candidateSkills: string[],
  context: SkillMatchContext
): number {
  // Return neutral if no required skills specified
  if (!context.requiredSkills || context.requiredSkills.length === 0) {
    return 0.5;
  }

  // Return 0 if candidate has no skills
  if (!candidateSkills || candidateSkills.length === 0) {
    return 0.0;
  }

  const normalizedCandidateSkills = new Set(
    candidateSkills.map(s => s.toLowerCase().trim())
  );

  let totalTransferScore = 0;
  let inferredMatches = 0;

  for (const required of context.requiredSkills) {
    const normalizedRequired = required.toLowerCase().trim();

    // Skip if exact match exists (handled by SCOR-02)
    const aliases = [normalizedRequired, ...getCommonAliases(normalizedRequired)];
    if (aliases.some(a => normalizedCandidateSkills.has(a))) {
      continue;
    }

    // Check for transferable skill matches
    const transferRules = getTransferableSkillRules(normalizedRequired);
    for (const rule of transferRules) {
      const fromAliases = [rule.fromSkill, ...getCommonAliases(rule.fromSkill)];
      if (fromAliases.some(a => normalizedCandidateSkills.has(a))) {
        totalTransferScore += rule.transferabilityScore;
        inferredMatches++;
        break; // Only count first match per required skill
      }
    }
  }

  if (inferredMatches === 0) {
    return 0.0; // No inferred matches found
  }

  // Average transferability of inferred matches, scaled by coverage
  const avgTransferability = totalTransferScore / inferredMatches;
  const coverage = inferredMatches / context.requiredSkills.length;

  return avgTransferability * coverage;
}

// Transferable skill rules (subset for hot path)
interface TransferRule {
  fromSkill: string;
  transferabilityScore: number;
}

function getTransferableSkillRules(toSkill: string): TransferRule[] {
  const TRANSFER_RULES: Record<string, TransferRule[]> = {
    // Frontend frameworks
    'react': [
      { fromSkill: 'vue.js', transferabilityScore: 0.75 },
      { fromSkill: 'angular', transferabilityScore: 0.65 },
    ],
    'vue.js': [
      { fromSkill: 'react', transferabilityScore: 0.75 },
      { fromSkill: 'angular', transferabilityScore: 0.65 },
    ],
    'angular': [
      { fromSkill: 'react', transferabilityScore: 0.65 },
      { fromSkill: 'vue.js', transferabilityScore: 0.65 },
    ],
    // Language transfers
    'kotlin': [
      { fromSkill: 'java', transferabilityScore: 0.90 },
    ],
    'java': [
      { fromSkill: 'kotlin', transferabilityScore: 0.85 },
      { fromSkill: 'c#', transferabilityScore: 0.70 },
    ],
    'typescript': [
      { fromSkill: 'javascript', transferabilityScore: 0.95 },
    ],
    'go': [
      { fromSkill: 'python', transferabilityScore: 0.60 },
      { fromSkill: 'java', transferabilityScore: 0.65 },
    ],
    // Cloud platforms
    'aws': [
      { fromSkill: 'google cloud', transferabilityScore: 0.70 },
      { fromSkill: 'azure', transferabilityScore: 0.70 },
    ],
    'google cloud': [
      { fromSkill: 'aws', transferabilityScore: 0.70 },
      { fromSkill: 'azure', transferabilityScore: 0.70 },
    ],
    'azure': [
      { fromSkill: 'aws', transferabilityScore: 0.70 },
      { fromSkill: 'google cloud', transferabilityScore: 0.70 },
    ],
    // Databases
    'postgresql': [
      { fromSkill: 'mysql', transferabilityScore: 0.85 },
      { fromSkill: 'sql server', transferabilityScore: 0.80 },
    ],
    'mysql': [
      { fromSkill: 'postgresql', transferabilityScore: 0.85 },
      { fromSkill: 'sql server', transferabilityScore: 0.80 },
    ],
    // Python frameworks
    'django': [
      { fromSkill: 'flask', transferabilityScore: 0.85 },
      { fromSkill: 'fastapi', transferabilityScore: 0.80 },
    ],
    'flask': [
      { fromSkill: 'django', transferabilityScore: 0.75 },
      { fromSkill: 'fastapi', transferabilityScore: 0.85 },
    ],
  };

  return TRANSFER_RULES[toSkill] || [];
}
```
  </action>
  <verify>
TypeScript compiles: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
Manual verification:
- calculateSkillsInferred(['Java'], {requiredSkills: ['Kotlin'], preferredSkills: []}) returns ~0.90
- calculateSkillsInferred(['React'], {requiredSkills: ['Vue.js'], preferredSkills: []}) returns ~0.75
- calculateSkillsInferred(['Python'], {requiredSkills: ['Java'], preferredSkills: []}) returns 0.0
- calculateSkillsInferred([], {requiredSkills: ['React'], preferredSkills: []}) returns 0.0
  </verify>
  <done>calculateSkillsInferred function implemented with transferable skill rules</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
2. File structure is clean with clear sections for types, constants, helpers, and exports
3. Both functions handle edge cases (empty arrays, missing context)
4. Both functions return 0.5 for neutral cases (no required skills)
5. Both functions return 0.0 when candidate has no skills
</verification>

<success_criteria>
1. signal-calculators.ts exists with context interfaces defined
2. calculateSkillsExactMatch function exported and working with alias support
3. calculateSkillsInferred function exported and working with transfer rules
4. All code compiles without TypeScript errors
5. Functions use consistent 0-1 scoring with 0.5 neutral fallback pattern
</success_criteria>

<output>
After completion, create `.planning/phases/07-signal-scoring/07-01-SUMMARY.md`
</output>
