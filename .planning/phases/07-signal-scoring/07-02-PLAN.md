---
phase: 07-signal-scoring
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - services/hh-search-svc/src/signal-calculators.ts
autonomous: true

must_haves:
  truths:
    - "calculateSeniorityAlignment accounts for company tier (FAANG +1 level)"
    - "calculateRecencyBoost decays score from 1.0 (current) to 0.2 (5+ years ago)"
    - "calculateCompanyRelevance combines tier, target match, and industry signals"
    - "All three functions return 0.5 for missing/unknown data"
  artifacts:
    - path: "services/hh-search-svc/src/signal-calculators.ts"
      provides: "Remaining 3 signal calculator functions"
      exports: ["calculateSeniorityAlignment", "calculateRecencyBoost", "calculateCompanyRelevance"]
  key_links:
    - from: "calculateSeniorityAlignment"
      to: "LEVEL_ORDER constant"
      via: "array index lookup"
      pattern: "LEVEL_ORDER\\.indexOf"
    - from: "calculateRecencyBoost"
      to: "CandidateExperience interface"
      via: "experience array iteration"
      pattern: "candidateExperience\\.forEach\\|for.*of.*candidateExperience"
---

<objective>
Add the remaining 3 signal calculator functions: seniority alignment, recency boost, and company relevance.

Purpose: Complete SCOR-04, SCOR-05, and SCOR-06 implementations as pure functions.

Output: Extended signal-calculators.ts with all 5 signal calculator functions exported.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-signal-scoring/07-RESEARCH.md

Depends on Plan 07-01 completing signal-calculators.ts setup with:
- Context interfaces (SeniorityContext, CompanyContext, CandidateExperience)
- Constants (LEVEL_ORDER, FAANG_COMPANIES, UNICORN_COMPANIES)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement calculateSeniorityAlignment (SCOR-04)</name>
  <files>services/hh-search-svc/src/signal-calculators.ts</files>
  <action>
Add the calculateSeniorityAlignment function to signal-calculators.ts:

```typescript
/**
 * SCOR-04: Seniority Alignment Score (0-1)
 *
 * Measures how well candidate level aligns with target.
 * Accounts for company tier adjustments:
 * - FAANG mid-level ≈ Startup senior (tier boost)
 * - Startup principal ≈ FAANG senior (tier penalty)
 *
 * @param candidateLevel - Current level (e.g., 'senior', 'staff')
 * @param companyTier - 0=startup, 1=mid, 2=FAANG/enterprise
 * @param context - Target level and role type
 * @returns Score 0-1 where 1.0 = exact match (with tier adjustment)
 */
export function calculateSeniorityAlignment(
  candidateLevel: string | null | undefined,
  companyTier: number,
  context: SeniorityContext
): number {
  // Return neutral for unknown candidate level
  if (!candidateLevel || candidateLevel === 'unknown' || candidateLevel.trim() === '') {
    return 0.5;
  }

  const normalizedCandidate = candidateLevel.toLowerCase().trim();
  const normalizedTarget = context.targetLevel.toLowerCase().trim();

  // Map common variations to standard levels
  const levelMap: Record<string, string> = {
    'entry': 'junior',
    'associate': 'junior',
    'intermediate': 'mid',
    'middle': 'mid',
    'sr': 'senior',
    'lead': 'staff',
    'principal': 'principal',
    'distinguished': 'principal',
    'em': 'manager',
    'engineering manager': 'manager',
    'sr manager': 'director',
    'senior manager': 'director',
    'vice president': 'vp',
    'svp': 'vp',
    'cto': 'c-level',
    'ceo': 'c-level',
    'cio': 'c-level',
    'chief': 'c-level',
  };

  const candidateMapped = levelMap[normalizedCandidate] || normalizedCandidate;
  const targetMapped = levelMap[normalizedTarget] || normalizedTarget;

  const candidateIndex = LEVEL_ORDER.indexOf(candidateMapped);
  const targetIndex = LEVEL_ORDER.indexOf(targetMapped);

  // If either level is unknown, return neutral
  if (candidateIndex === -1 || targetIndex === -1) {
    return 0.5;
  }

  // Apply company tier adjustment
  // FAANG (tier 2) gets +1 effective level
  // Startup (tier 0) gets -1 effective level
  // Mid-market (tier 1) stays the same
  const tierAdjustment = companyTier - 1; // -1 for startup, 0 for mid, +1 for FAANG
  const effectiveIndex = Math.min(
    Math.max(0, candidateIndex + tierAdjustment),
    LEVEL_ORDER.length - 1
  );

  const distance = Math.abs(effectiveIndex - targetIndex);

  // Score based on distance from target
  if (distance === 0) return 1.0;   // Exact match
  if (distance === 1) return 0.8;   // One level off (acceptable)
  if (distance === 2) return 0.6;   // Two levels off
  if (distance === 3) return 0.4;   // Three levels off
  return 0.2;                        // More than three levels (poor match)
}
```
  </action>
  <verify>
TypeScript compiles: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
Manual verification:
- calculateSeniorityAlignment('senior', 1, {targetLevel: 'senior', roleType: 'ic'}) returns 1.0
- calculateSeniorityAlignment('mid', 2, {targetLevel: 'senior', roleType: 'ic'}) returns 1.0 (FAANG mid = senior)
- calculateSeniorityAlignment('staff', 0, {targetLevel: 'senior', roleType: 'ic'}) returns 1.0 (Startup staff = senior)
- calculateSeniorityAlignment('junior', 1, {targetLevel: 'senior', roleType: 'ic'}) returns 0.6
- calculateSeniorityAlignment(null, 1, {targetLevel: 'senior', roleType: 'ic'}) returns 0.5
  </verify>
  <done>calculateSeniorityAlignment function implemented with company tier adjustment</done>
</task>

<task type="auto">
  <name>Task 2: Implement calculateRecencyBoost (SCOR-05)</name>
  <files>services/hh-search-svc/src/signal-calculators.ts</files>
  <action>
Add the calculateRecencyBoost function to signal-calculators.ts:

```typescript
/**
 * SCOR-05: Recency Boost Score (0-1)
 *
 * Boosts candidates who used required skills recently.
 * Current position using skill = 1.0
 * 2 years ago = ~0.68
 * 5 years ago = ~0.2
 *
 * @param candidateExperience - Work history with skills per role
 * @param requiredSkills - Skills to check for recency
 * @returns Score 0-1 where 1.0 = all skills used in current role
 */
export function calculateRecencyBoost(
  candidateExperience: CandidateExperience[],
  requiredSkills: string[]
): number {
  // Return neutral if no required skills
  if (!requiredSkills || requiredSkills.length === 0) {
    return 0.5;
  }

  // Return neutral if no experience data
  if (!candidateExperience || candidateExperience.length === 0) {
    return 0.5;
  }

  const now = new Date();
  const normalizedRequired = requiredSkills.map(s => s.toLowerCase().trim());
  let totalRecencyScore = 0;
  let skillsWithData = 0;

  for (const requiredSkill of normalizedRequired) {
    const aliases = [requiredSkill, ...getCommonAliases(requiredSkill)];
    let bestRecency = 0;

    for (const exp of candidateExperience) {
      // Check if this experience used the skill
      const expSkills = (exp.skills || []).map(s => s.toLowerCase().trim());
      const hasSkill = aliases.some(alias =>
        expSkills.includes(alias) ||
        expSkills.some(es => es.includes(alias) || alias.includes(es))
      );

      if (!hasSkill) continue;

      // Calculate recency
      if (exp.isCurrent) {
        bestRecency = 1.0; // Current = maximum recency
        break; // Can't get better than current
      }

      if (exp.endDate) {
        const endDate = typeof exp.endDate === 'string'
          ? new Date(exp.endDate)
          : exp.endDate;

        if (!isNaN(endDate.getTime())) {
          const yearsSince = (now.getTime() - endDate.getTime()) / (365.25 * 24 * 60 * 60 * 1000);

          // Decay function: 1.0 at 0 years, ~0.68 at 2 years, ~0.2 at 5 years
          // Formula: max(0.2, 1.0 - 0.16 * years)
          const recency = Math.max(0.2, 1.0 - (yearsSince * 0.16));
          bestRecency = Math.max(bestRecency, recency);
        }
      }
    }

    // If we found any recency data for this skill
    if (bestRecency > 0) {
      totalRecencyScore += bestRecency;
      skillsWithData++;
    }
  }

  // If no skills had recency data, return low score (skills not in experience)
  if (skillsWithData === 0) {
    return 0.3;
  }

  // Average recency across all required skills with data
  return totalRecencyScore / normalizedRequired.length;
}
```
  </action>
  <verify>
TypeScript compiles: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
Manual verification:
- calculateRecencyBoost([{title: 'Dev', skills: ['Python'], isCurrent: true}], ['Python']) returns 1.0
- calculateRecencyBoost([{title: 'Dev', skills: ['Python'], endDate: '2024-01-01', isCurrent: false}], ['Python']) returns ~0.68
- calculateRecencyBoost([{title: 'Dev', skills: ['Java'], isCurrent: true}], ['Python']) returns 0.3
- calculateRecencyBoost([], ['Python']) returns 0.5
- calculateRecencyBoost([{title: 'Dev', skills: ['Python'], isCurrent: true}], []) returns 0.5
  </verify>
  <done>calculateRecencyBoost function implemented with decay formula</done>
</task>

<task type="auto">
  <name>Task 3: Implement calculateCompanyRelevance (SCOR-06)</name>
  <files>services/hh-search-svc/src/signal-calculators.ts</files>
  <action>
Add the calculateCompanyRelevance function to signal-calculators.ts:

```typescript
/**
 * SCOR-06: Company Relevance Score (0-1)
 *
 * Scores based on:
 * 1. Company tier (FAANG=1.0, Unicorn=0.7, Startup=0.3)
 * 2. Target company match (1.0 if worked at target company)
 * 3. Industry alignment (1.0 if same industry)
 *
 * @param candidateCompanies - Companies the candidate has worked at
 * @param candidateIndustries - Industries the candidate has worked in
 * @param companyTier - Detected company tier (0=startup, 1=mid, 2=FAANG)
 * @param context - Target companies and industries for the search
 * @returns Score 0-1 combining all company relevance signals
 */
export function calculateCompanyRelevance(
  candidateCompanies: string[],
  candidateIndustries: string[],
  companyTier: number,
  context: CompanyContext
): number {
  let score = 0;
  let signals = 0;

  // Signal 1: Target company match (highest value)
  if (context.targetCompanies && context.targetCompanies.length > 0) {
    const normalizedCandidateCompanies = (candidateCompanies || [])
      .map(c => c.toLowerCase().trim());

    const hasTargetCompany = context.targetCompanies.some(target => {
      const normalizedTarget = target.toLowerCase().trim();
      return normalizedCandidateCompanies.some(cc =>
        cc.includes(normalizedTarget) || normalizedTarget.includes(cc)
      );
    });

    score += hasTargetCompany ? 1.0 : 0.0;
    signals++;
  }

  // Signal 2: Company tier
  // FAANG/Enterprise (tier 2) = 1.0
  // Unicorn/Mid-market (tier 1) = 0.7
  // Startup (tier 0) = 0.4 (not 0.3 because startups aren't necessarily bad)
  const tierScore = companyTier >= 2 ? 1.0 : companyTier >= 1 ? 0.7 : 0.4;
  score += tierScore;
  signals++;

  // Signal 3: Industry alignment
  if (context.targetIndustries && context.targetIndustries.length > 0) {
    const normalizedCandidateIndustries = (candidateIndustries || [])
      .map(i => i.toLowerCase().trim());

    const hasMatchingIndustry = context.targetIndustries.some(target => {
      const normalizedTarget = target.toLowerCase().trim();
      return normalizedCandidateIndustries.some(ci =>
        ci.includes(normalizedTarget) ||
        normalizedTarget.includes(ci) ||
        areIndustriesRelated(ci, normalizedTarget)
      );
    });

    score += hasMatchingIndustry ? 1.0 : 0.3;
    signals++;
  }

  // Return average of all signals, or 0.5 if no signals computed
  return signals > 0 ? score / signals : 0.5;
}

/**
 * Helper to detect company tier from company names
 */
export function detectCompanyTier(companyNames: string[]): number {
  if (!companyNames || companyNames.length === 0) {
    return 0; // Default to startup tier
  }

  for (const company of companyNames) {
    const lower = company.toLowerCase().trim();

    // Check FAANG/Big Tech
    if (FAANG_COMPANIES.some(f => lower.includes(f) || f.includes(lower))) {
      return 2;
    }

    // Check Unicorns
    if (UNICORN_COMPANIES.some(u => lower.includes(u) || u.includes(lower))) {
      return 1;
    }
  }

  return 0; // Startup/unknown
}

// Helper for industry relationship checking
function areIndustriesRelated(industry1: string, industry2: string): boolean {
  const RELATED_INDUSTRIES: Record<string, string[]> = {
    'fintech': ['financial services', 'banking', 'payments', 'finance'],
    'financial services': ['fintech', 'banking', 'payments', 'finance'],
    'banking': ['fintech', 'financial services', 'finance'],
    'e-commerce': ['retail', 'marketplace', 'shopping'],
    'retail': ['e-commerce', 'marketplace', 'shopping'],
    'healthtech': ['healthcare', 'medical', 'health'],
    'healthcare': ['healthtech', 'medical', 'health'],
    'edtech': ['education', 'learning', 'training'],
    'education': ['edtech', 'learning', 'training'],
    'saas': ['software', 'enterprise software', 'b2b'],
    'software': ['saas', 'enterprise software', 'b2b'],
  };

  const related1 = RELATED_INDUSTRIES[industry1] || [];
  const related2 = RELATED_INDUSTRIES[industry2] || [];

  return related1.includes(industry2) || related2.includes(industry1);
}
```
  </action>
  <verify>
TypeScript compiles: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
Manual verification:
- calculateCompanyRelevance(['Google'], ['Technology'], 2, {targetCompanies: ['Google'], targetIndustries: ['Technology']}) returns 1.0
- calculateCompanyRelevance(['Startup Inc'], ['Fintech'], 0, {targetCompanies: [], targetIndustries: ['Financial Services']}) returns ~0.7 (tier 0.4 + related industry 1.0)
- calculateCompanyRelevance([], [], 0, {}) returns 0.5 (neutral - no context)
- detectCompanyTier(['Google']) returns 2
- detectCompanyTier(['Nubank']) returns 1
- detectCompanyTier(['Unknown Startup']) returns 0
  </verify>
  <done>calculateCompanyRelevance function implemented with tier and industry matching</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
2. All 5 calculator functions are exported from signal-calculators.ts
3. All functions handle edge cases (null, undefined, empty arrays)
4. All functions return 0.5 for neutral/missing data cases
5. Seniority alignment properly applies company tier adjustment
6. Recency boost uses decay formula with 0.2 floor
7. Company relevance combines tier, target match, and industry signals
</verification>

<success_criteria>
1. calculateSeniorityAlignment exported with company tier adjustment
2. calculateRecencyBoost exported with decay formula
3. calculateCompanyRelevance exported with tier/target/industry combination
4. detectCompanyTier helper exported for external use
5. All code compiles without TypeScript errors
6. Functions follow consistent 0-1 scoring pattern
</success_criteria>

<output>
After completion, create `.planning/phases/07-signal-scoring/07-02-SUMMARY.md`
</output>
