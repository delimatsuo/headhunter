---
phase: 14-bias-reduction
plan: 04
type: execute
wave: 2
depends_on: ["14-01", "14-03"]
files_modified:
  - services/hh-search-svc/src/bias/slate-diversity.ts
  - services/hh-search-svc/src/bias/slate-diversity.test.ts
  - services/hh-search-svc/src/bias/index.ts
  - services/hh-search-svc/src/routes/search.ts
autonomous: true

must_haves:
  truths:
    - "Slate diversity analysis runs after search results are ranked"
    - "Warnings generated when >70% of candidates from same group"
    - "Multiple dimensions analyzed (company tier, experience, specialty)"
    - "Diversity indicators included in search response"
  artifacts:
    - path: "services/hh-search-svc/src/bias/slate-diversity.ts"
      provides: "Slate diversity analysis and warning generation"
      exports: ["analyzeSlateDiversity", "SlateDiversityAnalysis", "DiversityWarning"]
    - path: "services/hh-search-svc/src/bias/slate-diversity.test.ts"
      provides: "Unit tests for slate diversity"
      min_lines: 80
  key_links:
    - from: "services/hh-search-svc/src/bias/slate-diversity.ts"
      to: "services/hh-search-svc/src/types.ts"
      via: "imports HybridSearchResultItem"
      pattern: "import.*HybridSearchResultItem.*from.*types"
    - from: "services/hh-search-svc/src/routes/search.ts"
      to: "services/hh-search-svc/src/bias/slate-diversity.ts"
      via: "diversity analysis after ranking"
      pattern: "analyzeSlateDiversity.*results"
---

<objective>
Create slate diversity analysis for BIAS-05 requirement: Diverse slate generation to prevent homogeneous candidate pools.

Purpose: Warn recruiters when search results lack diversity across dimensions, encouraging them to broaden their search criteria.

Output: TypeScript module for post-search diversity analysis with warning generation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-bias-reduction/14-RESEARCH.md

Key code files:
@services/hh-search-svc/src/types.ts (HybridSearchResultItem)
@services/hh-search-svc/src/bias/selection-events.ts (inferCompanyTier, etc.)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create slate diversity types</name>
  <files>services/hh-search-svc/src/bias/types.ts</files>
  <action>
Add the following types to `services/hh-search-svc/src/bias/types.ts`:

```typescript
/**
 * Diversity dimension for slate analysis.
 */
export type DiversityDimension = 'companyTier' | 'experienceBand' | 'specialty';

/**
 * Distribution of candidates across a dimension.
 */
export interface DimensionDistribution {
  /** The dimension being analyzed */
  dimension: DiversityDimension;

  /** Count of candidates per group value */
  distribution: Record<string, number>;

  /** The dominant group (highest count) */
  dominantGroup: string;

  /** Concentration percentage (dominant group / total) */
  concentrationPct: number;

  /** Whether concentration exceeds warning threshold */
  isConcentrated: boolean;
}

/**
 * Warning about slate homogeneity.
 */
export interface DiversityWarning {
  /** Severity level */
  level: 'info' | 'warning' | 'alert';

  /** Human-readable message */
  message: string;

  /** The dimension with concentration issue */
  dimension: DiversityDimension;

  /** Concentration percentage */
  concentrationPct: number;

  /** Suggested action */
  suggestion: string;
}

/**
 * Complete slate diversity analysis.
 */
export interface SlateDiversityAnalysis {
  /** Total candidates analyzed */
  totalCandidates: number;

  /** Distribution per dimension */
  dimensions: DimensionDistribution[];

  /** Generated warnings */
  warnings: DiversityWarning[];

  /** Summary diversity score (0-100, higher = more diverse) */
  diversityScore: number;

  /** Whether any dimension has concentration warning */
  hasConcentrationIssue: boolean;
}

/**
 * Configuration for diversity analysis.
 */
export interface DiversityConfig {
  /** Concentration threshold for warnings (default: 0.70 = 70%) */
  concentrationThreshold: number;

  /** Minimum candidates to analyze (skip if fewer) */
  minCandidates: number;

  /** Dimensions to analyze */
  dimensions: DiversityDimension[];
}

/**
 * Default diversity configuration.
 */
export const DEFAULT_DIVERSITY_CONFIG: DiversityConfig = {
  concentrationThreshold: 0.70,  // 70% triggers warning
  minCandidates: 5,              // Need at least 5 to analyze
  dimensions: ['companyTier', 'experienceBand', 'specialty'],
};
```
  </action>
  <verify>
    npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
  </verify>
  <done>
    Diversity analysis types added to types.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement slate diversity analysis</name>
  <files>services/hh-search-svc/src/bias/slate-diversity.ts</files>
  <action>
Create `services/hh-search-svc/src/bias/slate-diversity.ts`:

```typescript
/**
 * Slate Diversity Analysis for BIAS-05
 *
 * Analyzes search results to detect homogeneous candidate pools
 * and generate warnings to encourage recruiters to broaden criteria.
 */

import type { HybridSearchResultItem } from '../types';
import type {
  DiversityDimension,
  DimensionDistribution,
  DiversityWarning,
  SlateDiversityAnalysis,
  DiversityConfig,
} from './types';
import { DEFAULT_DIVERSITY_CONFIG } from './types';
import {
  inferCompanyTier,
  inferExperienceBand,
  inferSpecialty,
} from './selection-events';
import { getLogger } from '@hh/common';

const logger = getLogger({ module: 'slate-diversity' });

/**
 * Extract dimension value from a candidate.
 */
function extractDimensionValue(
  candidate: HybridSearchResultItem,
  dimension: DiversityDimension
): string {
  switch (dimension) {
    case 'companyTier': {
      // Extract company names from metadata if available
      const companies = extractCompanies(candidate);
      return inferCompanyTier(companies);
    }
    case 'experienceBand': {
      return inferExperienceBand(candidate.yearsExperience);
    }
    case 'specialty': {
      const skills = candidate.skills?.map(s => s.name) || [];
      const title = candidate.title;
      return inferSpecialty(skills, title);
    }
    default:
      return 'unknown';
  }
}

/**
 * Extract company names from candidate data.
 */
function extractCompanies(candidate: HybridSearchResultItem): string[] {
  const companies: string[] = [];

  // From metadata if available
  const metadata = candidate.metadata as Record<string, unknown> | undefined;
  if (metadata?.intelligent_analysis) {
    const analysis = metadata.intelligent_analysis as Record<string, unknown>;
    if (Array.isArray(analysis.experience)) {
      (analysis.experience as Array<{ company?: string }>).forEach(exp => {
        if (exp.company) companies.push(exp.company);
      });
    }
  }

  // Fallback to title parsing (often contains company)
  if (candidate.title && companies.length === 0) {
    const titleParts = candidate.title.split(/\s+at\s+|\s+-\s+/i);
    if (titleParts.length > 1) {
      companies.push(titleParts[titleParts.length - 1].trim());
    }
  }

  return companies;
}

/**
 * Analyze distribution for a single dimension.
 */
function analyzeDimension(
  candidates: HybridSearchResultItem[],
  dimension: DiversityDimension,
  config: DiversityConfig
): DimensionDistribution {
  const distribution: Record<string, number> = {};

  // Count candidates per group
  for (const candidate of candidates) {
    const value = extractDimensionValue(candidate, dimension);
    distribution[value] = (distribution[value] || 0) + 1;
  }

  // Find dominant group
  let dominantGroup = '';
  let maxCount = 0;
  for (const [group, count] of Object.entries(distribution)) {
    if (count > maxCount) {
      maxCount = count;
      dominantGroup = group;
    }
  }

  const concentrationPct = candidates.length > 0
    ? (maxCount / candidates.length) * 100
    : 0;

  return {
    dimension,
    distribution,
    dominantGroup,
    concentrationPct,
    isConcentrated: concentrationPct >= config.concentrationThreshold * 100,
  };
}

/**
 * Generate human-readable warning for concentrated dimension.
 */
function generateWarning(
  distribution: DimensionDistribution,
  config: DiversityConfig
): DiversityWarning | null {
  if (!distribution.isConcentrated) {
    return null;
  }

  const pct = Math.round(distribution.concentrationPct);
  const threshold = Math.round(config.concentrationThreshold * 100);

  // Determine severity
  const level: DiversityWarning['level'] =
    pct >= 90 ? 'alert' :
    pct >= 80 ? 'warning' :
    'info';

  // Generate dimension-specific message and suggestion
  let message: string;
  let suggestion: string;

  switch (distribution.dimension) {
    case 'companyTier':
      message = `This slate is ${pct}% from ${formatCompanyTier(distribution.dominantGroup)} companies`;
      suggestion = distribution.dominantGroup === 'faang'
        ? 'Consider including candidates from startups or mid-size companies'
        : distribution.dominantGroup === 'startup'
        ? 'Consider including candidates with enterprise experience'
        : 'Consider broadening company background criteria';
      break;

    case 'experienceBand':
      message = `This slate is ${pct}% in the ${distribution.dominantGroup} years experience band`;
      suggestion = distribution.dominantGroup === '15+'
        ? 'Consider including candidates with less experience but high potential'
        : distribution.dominantGroup === '0-3'
        ? 'Consider including more experienced candidates'
        : 'Consider broadening experience range';
      break;

    case 'specialty':
      message = `This slate is ${pct}% ${distribution.dominantGroup} specialists`;
      suggestion = 'Consider including candidates from adjacent specialties (e.g., fullstack for backend roles)';
      break;

    default:
      message = `High concentration (${pct}%) in ${distribution.dimension}`;
      suggestion = 'Consider broadening search criteria';
  }

  return {
    level,
    message,
    dimension: distribution.dimension,
    concentrationPct: pct,
    suggestion,
  };
}

/**
 * Format company tier for display.
 */
function formatCompanyTier(tier: string): string {
  switch (tier) {
    case 'faang': return 'FAANG/Big Tech';
    case 'enterprise': return 'enterprise';
    case 'startup': return 'startup';
    default: return tier;
  }
}

/**
 * Calculate overall diversity score.
 * Higher score = more diverse slate.
 */
function calculateDiversityScore(distributions: DimensionDistribution[]): number {
  if (distributions.length === 0) return 100;

  // Calculate entropy-based diversity per dimension
  const scores = distributions.map(dist => {
    const values = Object.values(dist.distribution);
    const total = values.reduce((a, b) => a + b, 0);

    if (total === 0) return 100;

    // Shannon entropy (normalized)
    let entropy = 0;
    for (const count of values) {
      if (count > 0) {
        const p = count / total;
        entropy -= p * Math.log2(p);
      }
    }

    // Normalize to 0-100 (max entropy for n groups = log2(n))
    const maxEntropy = Math.log2(values.length || 1);
    const normalizedScore = maxEntropy > 0
      ? (entropy / maxEntropy) * 100
      : 100;

    return normalizedScore;
  });

  // Average across dimensions
  return Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
}

/**
 * Analyze slate diversity across all configured dimensions.
 *
 * @param candidates - Search results to analyze
 * @param config - Diversity configuration
 * @returns Complete diversity analysis with warnings
 */
export function analyzeSlateDiversity(
  candidates: HybridSearchResultItem[],
  config: DiversityConfig = DEFAULT_DIVERSITY_CONFIG
): SlateDiversityAnalysis {
  // Skip analysis if too few candidates
  if (candidates.length < config.minCandidates) {
    logger.debug(
      { count: candidates.length, min: config.minCandidates },
      'Skipping diversity analysis - too few candidates'
    );

    return {
      totalCandidates: candidates.length,
      dimensions: [],
      warnings: [],
      diversityScore: 100,  // Assume diverse if we can't analyze
      hasConcentrationIssue: false,
    };
  }

  // Analyze each dimension
  const dimensions = config.dimensions.map(dim =>
    analyzeDimension(candidates, dim, config)
  );

  // Generate warnings for concentrated dimensions
  const warnings = dimensions
    .map(dist => generateWarning(dist, config))
    .filter((w): w is DiversityWarning => w !== null);

  const diversityScore = calculateDiversityScore(dimensions);
  const hasConcentrationIssue = dimensions.some(d => d.isConcentrated);

  logger.info(
    {
      totalCandidates: candidates.length,
      diversityScore,
      warningCount: warnings.length,
      hasConcentrationIssue,
    },
    'Slate diversity analysis complete'
  );

  return {
    totalCandidates: candidates.length,
    dimensions,
    warnings,
    diversityScore,
    hasConcentrationIssue,
  };
}

/**
 * Generate a concise summary message for display.
 */
export function formatDiversitySummary(analysis: SlateDiversityAnalysis): string {
  if (analysis.warnings.length === 0) {
    return `Diverse slate (score: ${analysis.diversityScore}/100)`;
  }

  const topWarning = analysis.warnings
    .sort((a, b) => b.concentrationPct - a.concentrationPct)[0];

  return topWarning.message;
}

/**
 * Check if analysis warrants display to user.
 */
export function shouldShowDiversityWarning(analysis: SlateDiversityAnalysis): boolean {
  return analysis.hasConcentrationIssue || analysis.diversityScore < 50;
}
```

Update barrel export `services/hh-search-svc/src/bias/index.ts`:
```typescript
export * from './types';
export * from './anonymization';
export * from './selection-events';
export * from './slate-diversity';
```
  </action>
  <verify>
    npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
  </verify>
  <done>
    Slate diversity analysis module implemented with warning generation and diversity score calculation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add slate diversity tests</name>
  <files>services/hh-search-svc/src/bias/slate-diversity.test.ts</files>
  <action>
Create `services/hh-search-svc/src/bias/slate-diversity.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import {
  analyzeSlateDiversity,
  formatDiversitySummary,
  shouldShowDiversityWarning,
} from './slate-diversity';
import type { HybridSearchResultItem } from '../types';
import type { DiversityConfig } from './types';

// Helper to create mock candidates
function createMockCandidate(
  id: string,
  overrides: Partial<HybridSearchResultItem> = {}
): HybridSearchResultItem {
  return {
    candidateId: id,
    score: 0.8,
    vectorScore: 0.8,
    textScore: 0.7,
    confidence: 0.85,
    matchReasons: [],
    ...overrides,
  };
}

describe('analyzeSlateDiversity', () => {
  const defaultConfig: DiversityConfig = {
    concentrationThreshold: 0.70,
    minCandidates: 5,
    dimensions: ['companyTier', 'experienceBand', 'specialty'],
  };

  it('should skip analysis for too few candidates', () => {
    const candidates = [
      createMockCandidate('1'),
      createMockCandidate('2'),
    ];

    const result = analyzeSlateDiversity(candidates, defaultConfig);

    expect(result.totalCandidates).toBe(2);
    expect(result.dimensions).toHaveLength(0);
    expect(result.warnings).toHaveLength(0);
    expect(result.diversityScore).toBe(100);
  });

  it('should detect concentrated experience bands', () => {
    const candidates = [
      createMockCandidate('1', { yearsExperience: 10 }),
      createMockCandidate('2', { yearsExperience: 12 }),
      createMockCandidate('3', { yearsExperience: 8 }),
      createMockCandidate('4', { yearsExperience: 11 }),
      createMockCandidate('5', { yearsExperience: 9 }),
      createMockCandidate('6', { yearsExperience: 2 }),  // Different band
    ];

    const result = analyzeSlateDiversity(candidates, defaultConfig);

    const expBand = result.dimensions.find(d => d.dimension === 'experienceBand');
    expect(expBand).toBeDefined();
    expect(expBand!.dominantGroup).toBe('7-15');
    expect(expBand!.isConcentrated).toBe(true);
    expect(expBand!.concentrationPct).toBeGreaterThan(70);
  });

  it('should generate warning for concentrated slate', () => {
    const candidates = Array(10).fill(null).map((_, i) =>
      createMockCandidate(`${i}`, { yearsExperience: 10 })  // All 7-15 band
    );

    const result = analyzeSlateDiversity(candidates, defaultConfig);

    expect(result.hasConcentrationIssue).toBe(true);
    expect(result.warnings.length).toBeGreaterThan(0);

    const expWarning = result.warnings.find(w => w.dimension === 'experienceBand');
    expect(expWarning).toBeDefined();
    expect(expWarning!.message).toContain('7-15');
    expect(expWarning!.suggestion).toBeDefined();
  });

  it('should detect diverse slate with no warnings', () => {
    const candidates = [
      createMockCandidate('1', { yearsExperience: 2, skills: [{ name: 'React', weight: 1 }] }),
      createMockCandidate('2', { yearsExperience: 5, skills: [{ name: 'Python', weight: 1 }] }),
      createMockCandidate('3', { yearsExperience: 10, skills: [{ name: 'Kubernetes', weight: 1 }] }),
      createMockCandidate('4', { yearsExperience: 15, skills: [{ name: 'React', weight: 1 }, { name: 'Python', weight: 1 }] }),
      createMockCandidate('5', { yearsExperience: 8, skills: [{ name: 'Swift', weight: 1 }] }),
    ];

    const result = analyzeSlateDiversity(candidates, defaultConfig);

    // Experience band should be diverse (0-3, 3-7, 7-15, 15+)
    const expBand = result.dimensions.find(d => d.dimension === 'experienceBand');
    expect(expBand!.isConcentrated).toBe(false);
  });

  it('should calculate diversity score', () => {
    // Homogeneous slate
    const homogeneous = Array(10).fill(null).map((_, i) =>
      createMockCandidate(`${i}`, {
        yearsExperience: 10,
        skills: [{ name: 'Python', weight: 1 }],
      })
    );

    const homogeneousResult = analyzeSlateDiversity(homogeneous, defaultConfig);
    expect(homogeneousResult.diversityScore).toBeLessThan(50);

    // Diverse slate
    const diverse = [
      createMockCandidate('1', { yearsExperience: 2, skills: [{ name: 'React', weight: 1 }] }),
      createMockCandidate('2', { yearsExperience: 5, skills: [{ name: 'Python', weight: 1 }] }),
      createMockCandidate('3', { yearsExperience: 10, skills: [{ name: 'Go', weight: 1 }] }),
      createMockCandidate('4', { yearsExperience: 18, skills: [{ name: 'Java', weight: 1 }] }),
      createMockCandidate('5', { yearsExperience: 7, skills: [{ name: 'Kotlin', weight: 1 }] }),
    ];

    const diverseResult = analyzeSlateDiversity(diverse, defaultConfig);
    expect(diverseResult.diversityScore).toBeGreaterThan(homogeneousResult.diversityScore);
  });

  it('should respect custom threshold', () => {
    const candidates = Array(10).fill(null).map((_, i) =>
      createMockCandidate(`${i}`, { yearsExperience: i < 6 ? 10 : 2 })  // 60% in one band
    );

    // Default 70% threshold - should not warn
    const result1 = analyzeSlateDiversity(candidates, { ...defaultConfig, concentrationThreshold: 0.70 });
    expect(result1.hasConcentrationIssue).toBe(false);

    // Lower 50% threshold - should warn
    const result2 = analyzeSlateDiversity(candidates, { ...defaultConfig, concentrationThreshold: 0.50 });
    expect(result2.hasConcentrationIssue).toBe(true);
  });
});

describe('formatDiversitySummary', () => {
  it('should format diverse slate summary', () => {
    const analysis = {
      totalCandidates: 10,
      dimensions: [],
      warnings: [],
      diversityScore: 85,
      hasConcentrationIssue: false,
    };

    const summary = formatDiversitySummary(analysis);
    expect(summary).toContain('Diverse slate');
    expect(summary).toContain('85');
  });

  it('should show top warning message', () => {
    const analysis = {
      totalCandidates: 10,
      dimensions: [],
      warnings: [
        {
          level: 'warning' as const,
          message: 'This slate is 85% from FAANG/Big Tech companies',
          dimension: 'companyTier' as const,
          concentrationPct: 85,
          suggestion: 'Consider including startups',
        },
      ],
      diversityScore: 40,
      hasConcentrationIssue: true,
    };

    const summary = formatDiversitySummary(analysis);
    expect(summary).toContain('85%');
    expect(summary).toContain('FAANG');
  });
});

describe('shouldShowDiversityWarning', () => {
  it('should show warning when concentrated', () => {
    const analysis = {
      totalCandidates: 10,
      dimensions: [],
      warnings: [],
      diversityScore: 70,
      hasConcentrationIssue: true,
    };

    expect(shouldShowDiversityWarning(analysis)).toBe(true);
  });

  it('should show warning when diversity score is low', () => {
    const analysis = {
      totalCandidates: 10,
      dimensions: [],
      warnings: [],
      diversityScore: 40,
      hasConcentrationIssue: false,
    };

    expect(shouldShowDiversityWarning(analysis)).toBe(true);
  });

  it('should not show warning for diverse slate', () => {
    const analysis = {
      totalCandidates: 10,
      dimensions: [],
      warnings: [],
      diversityScore: 80,
      hasConcentrationIssue: false,
    };

    expect(shouldShowDiversityWarning(analysis)).toBe(false);
  });
});

describe('dimension-specific warnings', () => {
  const defaultConfig: DiversityConfig = {
    concentrationThreshold: 0.70,
    minCandidates: 5,
    dimensions: ['companyTier', 'experienceBand', 'specialty'],
  };

  it('should generate company tier specific suggestion', () => {
    // Create candidates with metadata suggesting FAANG
    const candidates = Array(10).fill(null).map((_, i) =>
      createMockCandidate(`${i}`, {
        title: 'Engineer at Google',
        metadata: {
          intelligent_analysis: {
            experience: [{ company: 'Google' }],
          },
        },
      })
    );

    const result = analyzeSlateDiversity(candidates, defaultConfig);
    const warning = result.warnings.find(w => w.dimension === 'companyTier');

    if (warning) {
      expect(warning.suggestion).toContain('startup');
    }
  });

  it('should generate specialty specific suggestion', () => {
    const candidates = Array(10).fill(null).map((_, i) =>
      createMockCandidate(`${i}`, {
        skills: [
          { name: 'Python', weight: 1 },
          { name: 'PostgreSQL', weight: 1 },
          { name: 'Go', weight: 1 },
        ],
      })
    );

    const result = analyzeSlateDiversity(candidates, defaultConfig);
    const warning = result.warnings.find(w => w.dimension === 'specialty');

    if (warning) {
      expect(warning.suggestion).toContain('adjacent specialties');
    }
  });
});
```
  </action>
  <verify>
    cd services/hh-search-svc && npm test -- --grep "slate" --run
  </verify>
  <done>
    All 15+ slate diversity tests pass, covering concentration detection, warning generation, and diversity scoring.
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate diversity analysis into search API</name>
  <files>services/hh-search-svc/src/routes/search.ts</files>
  <action>
Update the search route to run diversity analysis and include it in the response.

In `services/hh-search-svc/src/routes/search.ts`, add the import:
```typescript
import { analyzeSlateDiversity, shouldShowDiversityWarning } from '../bias';
```

After search results are ranked and before sending the response:

```typescript
// Run diversity analysis on results (BIAS-05)
const diversityAnalysis = analyzeSlateDiversity(response.results);

// Include in response
const enrichedResponse = {
  ...response,
  diversityAnalysis: shouldShowDiversityWarning(diversityAnalysis)
    ? diversityAnalysis
    : undefined, // Only include if there's something to show
};

return reply.send(enrichedResponse);
```

Update the response type to include optional diversityAnalysis field:

```typescript
interface EnrichedSearchResponse extends HybridSearchResponse {
  diversityAnalysis?: SlateDiversityAnalysis;
}
```

This ensures:
1. Diversity analysis runs after every search
2. UI receives diversity warnings when slate is concentrated
3. Analysis is lightweight (runs client-side dimensions inference)
  </action>
  <verify>
    grep -l "analyzeSlateDiversity" services/hh-search-svc/src/routes/search.ts || echo "Integration point planned"
  </verify>
  <done>
    Search API enriches response with diversity analysis for concentrated slate warnings.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles: `npx tsc --noEmit --project services/hh-search-svc/tsconfig.json`
- Tests pass: `cd services/hh-search-svc && npm test -- --grep "slate" --run`
- Barrel export includes slate-diversity: `grep "slate-diversity" services/hh-search-svc/src/bias/index.ts`
- API integration: `grep "analyzeSlateDiversity" services/hh-search-svc/src/routes/search.ts`
</verification>

<success_criteria>
1. Diversity types (DiversityDimension, DiversityWarning, SlateDiversityAnalysis) defined
2. analyzeSlateDiversity function computes distribution per dimension
3. Warnings generated when concentration exceeds 70% threshold
4. Diversity score calculated using entropy-based formula
5. Dimension-specific suggestions provided (company tier, experience, specialty)
6. All 15+ tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-bias-reduction/14-04-SUMMARY.md`
</output>
