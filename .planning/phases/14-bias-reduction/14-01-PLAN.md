---
phase: 14-bias-reduction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/hh-search-svc/src/bias/anonymization.ts
  - services/hh-search-svc/src/bias/anonymization.test.ts
  - services/hh-search-svc/src/bias/types.ts
  - services/hh-search-svc/src/bias/index.ts
  - services/hh-search-svc/src/types.ts
  - services/hh-search-svc/src/routes/search.ts
autonomous: true

must_haves:
  truths:
    - "Search response can be anonymized when flag is set"
    - "Anonymization strips name, photo URL, school names, graduation year"
    - "Anonymization preserves skills, experience, signal scores"
    - "candidateId is preserved for tracking (not PII)"
  artifacts:
    - path: "services/hh-search-svc/src/bias/anonymization.ts"
      provides: "anonymizeCandidate and anonymizeSearchResponse functions"
      exports: ["anonymizeCandidate", "anonymizeSearchResponse"]
    - path: "services/hh-search-svc/src/bias/types.ts"
      provides: "AnonymizationConfig, AnonymizedCandidate types"
      exports: ["AnonymizationConfig", "AnonymizedCandidate"]
    - path: "services/hh-search-svc/src/bias/anonymization.test.ts"
      provides: "Unit tests for anonymization"
      min_lines: 80
  key_links:
    - from: "services/hh-search-svc/src/bias/anonymization.ts"
      to: "services/hh-search-svc/src/types.ts"
      via: "imports HybridSearchResultItem"
      pattern: "import.*HybridSearchResultItem.*from.*types"
    - from: "services/hh-search-svc/src/routes/search.ts"
      to: "services/hh-search-svc/src/bias/anonymization.ts"
      via: "conditional anonymization based on query param"
      pattern: "anonymizedView.*anonymizeSearchResponse"
---

<objective>
Create anonymization middleware for BIAS-01 requirement: Resume anonymization toggle.

Purpose: Enable blind hiring workflow where recruiters see only qualifications, not identifying information that could introduce unconscious bias.

Output: TypeScript module with anonymization functions and comprehensive tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-bias-reduction/14-RESEARCH.md

Key code files:
@services/hh-search-svc/src/types.ts (HybridSearchResultItem type)
@services/hh-search-svc/src/scoring.ts (signal scores structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create anonymization types and configuration</name>
  <files>
    services/hh-search-svc/src/bias/types.ts
    services/hh-search-svc/src/bias/index.ts
  </files>
  <action>
Create `services/hh-search-svc/src/bias/types.ts`:

```typescript
/**
 * Anonymization types for BIAS-01: Resume anonymization toggle
 */

/**
 * Configuration for what fields to anonymize.
 * Separates PII (always strip) from proxy fields (configurable).
 */
export interface AnonymizationConfig {
  /** Fields containing direct PII - always stripped */
  piiFields: string[];

  /** Fields that may reveal demographics (location, school) - configurable */
  proxyFields: string[];

  /** Fields to always preserve (skills, experience, scores) */
  preserveFields: string[];

  /** Whether to strip proxy fields (e.g., location) in addition to PII */
  stripProxyFields?: boolean;
}

/**
 * Anonymized candidate with PII stripped.
 * Preserves only qualification-relevant data.
 */
export interface AnonymizedCandidate {
  /** Preserved for tracking and selection logging */
  candidateId: string;

  /** Final match score */
  score: number;

  /** Vector similarity score */
  vectorScore: number;

  /** Text search score */
  textScore: number;

  /** RRF score if enabled */
  rrfScore?: number;

  /** Confidence in match */
  confidence: number;

  /** Years of experience - job-relevant */
  yearsExperience?: number;

  /** Skills with match weights - job-relevant */
  skills?: Array<{ name: string; weight: number }>;

  /** Industry experience - job-relevant */
  industries?: string[];

  /** Match reasons (anonymized) */
  matchReasons: string[];

  /** Signal scores breakdown */
  signalScores?: {
    vectorSimilarity: number;
    levelMatch: number;
    specialtyMatch: number;
    techStackMatch: number;
    functionMatch: number;
    trajectoryFit: number;
    // Note: companyPedigree excluded - may be proxy
    skillsExactMatch?: number;
    skillsInferred?: number;
    seniorityAlignment?: number;
    recencyBoost?: number;
  };

  /** Weights applied for transparency */
  weightsApplied?: Record<string, number>;

  /** ML trajectory (if enabled) - role/tenure predictions */
  mlTrajectory?: {
    nextRole: string;
    nextRoleConfidence: number;
    tenureMonths: { min: number; max: number };
    hireability: number;
    lowConfidence: boolean;
    uncertaintyReason?: string;
  };

  /** Anonymization applied indicator */
  anonymized: true;
}

/**
 * Default anonymization configuration.
 * Based on proxy variable audit in 14-RESEARCH.md.
 */
export const DEFAULT_ANONYMIZATION_CONFIG: AnonymizationConfig = {
  // Direct PII - always strip
  piiFields: [
    'fullName',
    'title',        // May contain identifying info
    'headline',     // Often contains name/company
    'location',     // HIGH risk proxy
    'country',      // HIGH risk proxy
    'metadata',     // May contain anything
  ],

  // Demographic proxies - strip when stripProxyFields=true
  proxyFields: [
    'educationInstitutions',  // HIGH risk - reveals socioeconomic/race
    'graduationYear',         // HIGH risk - reveals age
    'companyPedigree',        // MEDIUM risk - correlates with demographics
  ],

  // Always preserve - job-relevant qualifications
  preserveFields: [
    'candidateId',
    'score',
    'vectorScore',
    'textScore',
    'rrfScore',
    'confidence',
    'yearsExperience',
    'skills',
    'industries',
    'matchReasons',
    'signalScores',
    'weightsApplied',
    'mlTrajectory',
  ],

  // Default: also strip proxy fields for full anonymization
  stripProxyFields: true,
};
```

Create barrel export `services/hh-search-svc/src/bias/index.ts`:
```typescript
export * from './types';
export * from './anonymization';
```
  </action>
  <verify>
    npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
  </verify>
  <done>
    AnonymizationConfig and AnonymizedCandidate types compile without errors, barrel export exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement anonymization functions</name>
  <files>services/hh-search-svc/src/bias/anonymization.ts</files>
  <action>
Create `services/hh-search-svc/src/bias/anonymization.ts`:

```typescript
/**
 * Anonymization middleware for BIAS-01: Resume anonymization toggle
 *
 * Transforms search results to remove PII and demographic proxies,
 * enabling blind hiring workflows that reduce unconscious bias.
 */

import type { HybridSearchResultItem, HybridSearchResponse } from '../types';
import type { AnonymizationConfig, AnonymizedCandidate } from './types';
import { DEFAULT_ANONYMIZATION_CONFIG } from './types';
import { getLogger } from '@hh/common';

const logger = getLogger({ module: 'anonymization' });

/**
 * Anonymize a single candidate result.
 * Strips PII fields and optionally proxy fields based on config.
 *
 * @param candidate - Full candidate result with PII
 * @param config - Anonymization configuration
 * @returns Anonymized candidate with only job-relevant data
 */
export function anonymizeCandidate(
  candidate: HybridSearchResultItem,
  config: AnonymizationConfig = DEFAULT_ANONYMIZATION_CONFIG
): AnonymizedCandidate {
  // Extract signal scores, excluding companyPedigree if proxy stripping enabled
  let signalScores: AnonymizedCandidate['signalScores'] | undefined;

  if (candidate.signalScores) {
    signalScores = {
      vectorSimilarity: candidate.signalScores.vectorSimilarity,
      levelMatch: candidate.signalScores.levelMatch,
      specialtyMatch: candidate.signalScores.specialtyMatch,
      techStackMatch: candidate.signalScores.techStackMatch,
      functionMatch: candidate.signalScores.functionMatch,
      trajectoryFit: candidate.signalScores.trajectoryFit,
      // Only include Phase 7 signals if present
      ...(candidate.signalScores.skillsExactMatch !== undefined && {
        skillsExactMatch: candidate.signalScores.skillsExactMatch,
      }),
      ...(candidate.signalScores.skillsInferred !== undefined && {
        skillsInferred: candidate.signalScores.skillsInferred,
      }),
      ...(candidate.signalScores.seniorityAlignment !== undefined && {
        seniorityAlignment: candidate.signalScores.seniorityAlignment,
      }),
      ...(candidate.signalScores.recencyBoost !== undefined && {
        recencyBoost: candidate.signalScores.recencyBoost,
      }),
      // Note: companyPedigree and companyRelevance excluded - proxy risk
    };
  }

  // Build anonymized result
  const anonymized: AnonymizedCandidate = {
    candidateId: candidate.candidateId,
    score: candidate.score,
    vectorScore: candidate.vectorScore,
    textScore: candidate.textScore,
    confidence: candidate.confidence,
    matchReasons: anonymizeMatchReasons(candidate.matchReasons),
    anonymized: true,
  };

  // Optional fields
  if (candidate.rrfScore !== undefined) {
    anonymized.rrfScore = candidate.rrfScore;
  }

  if (candidate.yearsExperience !== undefined) {
    anonymized.yearsExperience = candidate.yearsExperience;
  }

  // Skills - preserve skill names and weights, no company context
  if (candidate.skills && candidate.skills.length > 0) {
    anonymized.skills = candidate.skills.map(s => ({
      name: s.name,
      weight: s.weight,
    }));
  }

  // Industries - job-relevant context
  if (candidate.industries && candidate.industries.length > 0) {
    anonymized.industries = [...candidate.industries];
  }

  // Signal scores (without company pedigree)
  if (signalScores) {
    anonymized.signalScores = signalScores;
  }

  // Weights for transparency
  if (candidate.weightsApplied) {
    // Exclude companyPedigree and companyRelevance weights
    const { companyPedigree, companyRelevance, ...safeWeights } = candidate.weightsApplied as Record<string, number>;
    anonymized.weightsApplied = safeWeights;
  }

  // ML trajectory - predictive, not identifying
  if (candidate.mlTrajectory) {
    anonymized.mlTrajectory = { ...candidate.mlTrajectory };
  }

  logger.debug(
    { candidateId: candidate.candidateId },
    'Anonymized candidate for blind review'
  );

  return anonymized;
}

/**
 * Anonymize match reasons by removing any that might leak PII.
 * Removes reasons mentioning specific companies, schools, or names.
 */
function anonymizeMatchReasons(reasons: string[]): string[] {
  if (!reasons || reasons.length === 0) return [];

  return reasons
    .filter(reason => {
      const lower = reason.toLowerCase();
      // Filter out reasons that mention specific identifying info
      // Keep generic ones like "Strong skill match", "Senior level alignment"
      const hasCompanyMention = /\b(at|from|worked at|experience at)\s+[A-Z]/i.test(reason);
      const hasSchoolMention = /\b(graduated|degree from|alumni|university|college)\b/i.test(reason);
      const hasLocationMention = /\b(based in|located in|from|lives in)\b/i.test(reason);

      return !hasCompanyMention && !hasSchoolMention && !hasLocationMention;
    })
    .map(reason => {
      // Generalize any remaining specific mentions
      return reason
        .replace(/\b\d{4}\b/g, '[year]')  // Replace years
        .replace(/\b[A-Z][a-z]+ [A-Z][a-z]+\b/g, '[name]');  // Replace potential names
    });
}

/**
 * Anonymize an entire search response.
 * Applies anonymization to all candidates and removes response-level PII.
 *
 * @param response - Full search response
 * @param config - Anonymization configuration
 * @returns Response with all candidates anonymized
 */
export function anonymizeSearchResponse(
  response: HybridSearchResponse,
  config: AnonymizationConfig = DEFAULT_ANONYMIZATION_CONFIG
): HybridSearchResponse & { results: AnonymizedCandidate[] } {
  const anonymizedResults = response.results.map(
    candidate => anonymizeCandidate(candidate, config)
  );

  // Remove any sensitive metadata from response
  const { metadata, debug, ...safeResponse } = response;

  logger.info(
    {
      requestId: response.requestId,
      candidateCount: anonymizedResults.length,
    },
    'Anonymized search response for blind review'
  );

  return {
    ...safeResponse,
    results: anonymizedResults,
    metadata: {
      anonymized: true,
      anonymizedAt: new Date().toISOString(),
    },
  };
}

/**
 * Check if a response is already anonymized.
 */
export function isAnonymizedResponse(
  response: HybridSearchResponse
): boolean {
  return response.metadata?.anonymized === true;
}
```
  </action>
  <verify>
    npx tsc --noEmit --project services/hh-search-svc/tsconfig.json
  </verify>
  <done>
    anonymizeCandidate and anonymizeSearchResponse functions compile, handle all HybridSearchResultItem fields.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add anonymization unit tests</name>
  <files>services/hh-search-svc/src/bias/anonymization.test.ts</files>
  <action>
Create comprehensive tests `services/hh-search-svc/src/bias/anonymization.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import {
  anonymizeCandidate,
  anonymizeSearchResponse,
  isAnonymizedResponse,
} from './anonymization';
import type { HybridSearchResultItem, HybridSearchResponse } from '../types';

describe('anonymizeCandidate', () => {
  const mockCandidate: HybridSearchResultItem = {
    candidateId: 'cand-123',
    score: 0.85,
    vectorScore: 0.8,
    textScore: 0.7,
    rrfScore: 0.82,
    confidence: 0.9,
    fullName: 'John Smith',
    title: 'Senior Engineer at Google',
    location: 'San Francisco, CA',
    country: 'USA',
    headline: 'Staff Engineer | Ex-Google | Stanford MBA',
    skills: [
      { name: 'Python', weight: 1.0 },
      { name: 'AWS', weight: 0.8 },
    ],
    industries: ['Technology', 'Finance'],
    yearsExperience: 10,
    matchReasons: [
      'Strong skill match for Python',
      'Worked at Google which aligns with target',
      'Based in San Francisco',
    ],
    signalScores: {
      vectorSimilarity: 0.8,
      levelMatch: 0.9,
      specialtyMatch: 0.85,
      techStackMatch: 0.9,
      functionMatch: 0.8,
      trajectoryFit: 0.75,
      companyPedigree: 0.95,
      skillsExactMatch: 0.9,
      skillsInferred: 0.7,
      seniorityAlignment: 0.85,
      recencyBoost: 0.8,
      companyRelevance: 0.9,
    },
    weightsApplied: {
      vectorSimilarity: 0.12,
      levelMatch: 0.1,
      companyPedigree: 0.1,
      companyRelevance: 0.05,
    },
    metadata: {
      educationInstitutions: ['Stanford University'],
      graduationYear: 2010,
    },
    mlTrajectory: {
      nextRole: 'Staff Engineer',
      nextRoleConfidence: 0.78,
      tenureMonths: { min: 18, max: 24 },
      hireability: 85,
      lowConfidence: false,
    },
  };

  it('should strip PII fields (name, title, location, headline)', () => {
    const anonymized = anonymizeCandidate(mockCandidate);

    expect(anonymized.anonymized).toBe(true);
    expect(anonymized).not.toHaveProperty('fullName');
    expect(anonymized).not.toHaveProperty('title');
    expect(anonymized).not.toHaveProperty('location');
    expect(anonymized).not.toHaveProperty('country');
    expect(anonymized).not.toHaveProperty('headline');
    expect(anonymized).not.toHaveProperty('metadata');
  });

  it('should preserve candidateId for tracking', () => {
    const anonymized = anonymizeCandidate(mockCandidate);
    expect(anonymized.candidateId).toBe('cand-123');
  });

  it('should preserve scores and confidence', () => {
    const anonymized = anonymizeCandidate(mockCandidate);
    expect(anonymized.score).toBe(0.85);
    expect(anonymized.vectorScore).toBe(0.8);
    expect(anonymized.textScore).toBe(0.7);
    expect(anonymized.rrfScore).toBe(0.82);
    expect(anonymized.confidence).toBe(0.9);
  });

  it('should preserve job-relevant data (skills, experience, industries)', () => {
    const anonymized = anonymizeCandidate(mockCandidate);
    expect(anonymized.yearsExperience).toBe(10);
    expect(anonymized.skills).toHaveLength(2);
    expect(anonymized.skills![0].name).toBe('Python');
    expect(anonymized.industries).toEqual(['Technology', 'Finance']);
  });

  it('should preserve ML trajectory predictions', () => {
    const anonymized = anonymizeCandidate(mockCandidate);
    expect(anonymized.mlTrajectory).toBeDefined();
    expect(anonymized.mlTrajectory!.nextRole).toBe('Staff Engineer');
    expect(anonymized.mlTrajectory!.hireability).toBe(85);
  });

  it('should exclude companyPedigree from signal scores', () => {
    const anonymized = anonymizeCandidate(mockCandidate);
    expect(anonymized.signalScores).toBeDefined();
    expect(anonymized.signalScores!.vectorSimilarity).toBe(0.8);
    expect(anonymized.signalScores!.levelMatch).toBe(0.9);
    expect(anonymized.signalScores).not.toHaveProperty('companyPedigree');
    expect(anonymized.signalScores).not.toHaveProperty('companyRelevance');
  });

  it('should exclude companyPedigree from weightsApplied', () => {
    const anonymized = anonymizeCandidate(mockCandidate);
    expect(anonymized.weightsApplied).toBeDefined();
    expect(anonymized.weightsApplied!.vectorSimilarity).toBe(0.12);
    expect(anonymized.weightsApplied).not.toHaveProperty('companyPedigree');
    expect(anonymized.weightsApplied).not.toHaveProperty('companyRelevance');
  });

  it('should filter match reasons that mention companies or locations', () => {
    const anonymized = anonymizeCandidate(mockCandidate);
    expect(anonymized.matchReasons).toHaveLength(1);
    expect(anonymized.matchReasons[0]).toBe('Strong skill match for Python');
  });

  it('should handle candidate without optional fields', () => {
    const minimalCandidate: HybridSearchResultItem = {
      candidateId: 'cand-minimal',
      score: 0.5,
      vectorScore: 0.5,
      textScore: 0.5,
      confidence: 0.5,
      matchReasons: [],
    };

    const anonymized = anonymizeCandidate(minimalCandidate);
    expect(anonymized.candidateId).toBe('cand-minimal');
    expect(anonymized.anonymized).toBe(true);
    expect(anonymized.skills).toBeUndefined();
    expect(anonymized.signalScores).toBeUndefined();
  });
});

describe('anonymizeSearchResponse', () => {
  const mockResponse: HybridSearchResponse = {
    results: [
      {
        candidateId: 'cand-1',
        score: 0.9,
        vectorScore: 0.85,
        textScore: 0.8,
        confidence: 0.95,
        fullName: 'Alice Johnson',
        matchReasons: ['Strong Python skills'],
      },
      {
        candidateId: 'cand-2',
        score: 0.8,
        vectorScore: 0.75,
        textScore: 0.7,
        confidence: 0.85,
        fullName: 'Bob Williams',
        matchReasons: ['AWS expertise'],
      },
    ],
    total: 2,
    cacheHit: false,
    requestId: 'req-123',
    timings: {
      totalMs: 150,
      retrievalMs: 100,
    },
    metadata: {
      searchVersion: '2.0',
    },
    debug: {
      query: 'Python developer',
    },
  };

  it('should anonymize all candidates in response', () => {
    const anonymized = anonymizeSearchResponse(mockResponse);

    expect(anonymized.results).toHaveLength(2);
    expect(anonymized.results[0].anonymized).toBe(true);
    expect(anonymized.results[1].anonymized).toBe(true);
    expect(anonymized.results[0]).not.toHaveProperty('fullName');
    expect(anonymized.results[1]).not.toHaveProperty('fullName');
  });

  it('should remove debug information from response', () => {
    const anonymized = anonymizeSearchResponse(mockResponse);
    expect(anonymized).not.toHaveProperty('debug');
  });

  it('should preserve response-level fields', () => {
    const anonymized = anonymizeSearchResponse(mockResponse);
    expect(anonymized.total).toBe(2);
    expect(anonymized.cacheHit).toBe(false);
    expect(anonymized.requestId).toBe('req-123');
    expect(anonymized.timings.totalMs).toBe(150);
  });

  it('should mark response as anonymized in metadata', () => {
    const anonymized = anonymizeSearchResponse(mockResponse);
    expect(anonymized.metadata?.anonymized).toBe(true);
    expect(anonymized.metadata?.anonymizedAt).toBeDefined();
  });
});

describe('isAnonymizedResponse', () => {
  it('should return true for anonymized response', () => {
    const response: HybridSearchResponse = {
      results: [],
      total: 0,
      cacheHit: false,
      requestId: 'req-123',
      timings: { totalMs: 10 },
      metadata: { anonymized: true },
    };

    expect(isAnonymizedResponse(response)).toBe(true);
  });

  it('should return false for non-anonymized response', () => {
    const response: HybridSearchResponse = {
      results: [],
      total: 0,
      cacheHit: false,
      requestId: 'req-123',
      timings: { totalMs: 10 },
    };

    expect(isAnonymizedResponse(response)).toBe(false);
  });
});

describe('match reason anonymization', () => {
  it('should filter reasons mentioning specific companies', () => {
    const candidate: HybridSearchResultItem = {
      candidateId: 'cand-1',
      score: 0.8,
      vectorScore: 0.8,
      textScore: 0.7,
      confidence: 0.85,
      matchReasons: [
        'Experience at Microsoft aligns with role',
        'Strong technical skills',
        'Worked at Amazon for 5 years',
      ],
    };

    const anonymized = anonymizeCandidate(candidate);
    expect(anonymized.matchReasons).toEqual(['Strong technical skills']);
  });

  it('should filter reasons mentioning schools', () => {
    const candidate: HybridSearchResultItem = {
      candidateId: 'cand-1',
      score: 0.8,
      vectorScore: 0.8,
      textScore: 0.7,
      confidence: 0.85,
      matchReasons: [
        'Graduated from MIT',
        'Excellent problem-solving skills',
        'Degree from Stanford University',
      ],
    };

    const anonymized = anonymizeCandidate(candidate);
    expect(anonymized.matchReasons).toEqual(['Excellent problem-solving skills']);
  });

  it('should filter reasons mentioning locations', () => {
    const candidate: HybridSearchResultItem = {
      candidateId: 'cand-1',
      score: 0.8,
      vectorScore: 0.8,
      textScore: 0.7,
      confidence: 0.85,
      matchReasons: [
        'Based in New York',
        'Senior level experience',
        'Located in Silicon Valley',
      ],
    };

    const anonymized = anonymizeCandidate(candidate);
    expect(anonymized.matchReasons).toEqual(['Senior level experience']);
  });
});
```

Run tests:
```bash
cd services/hh-search-svc && npm test -- --grep "anonymize"
```
  </action>
  <verify>
    cd services/hh-search-svc && npm test -- --grep "anonymize" --run
  </verify>
  <done>
    All 15+ anonymization tests pass, covering PII stripping, proxy exclusion, match reason filtering.
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire anonymization to search API endpoint</name>
  <files>services/hh-search-svc/src/routes/search.ts</files>
  <action>
Update the search route to apply anonymization when requested via query parameter.

In `services/hh-search-svc/src/routes/search.ts`, add the import:
```typescript
import { anonymizeSearchResponse } from '../bias';
```

In the search handler, after the search results are returned and before sending the response:

```typescript
// Add to request schema
interface SearchQueryParams {
  // ... existing params
  anonymizedView?: boolean;
}

// In the handler, after getting results:
// Apply anonymization if requested (BIAS-01)
if (request.query.anonymizedView) {
  const anonymizedResponse = anonymizeSearchResponse(response);
  return reply.send(anonymizedResponse);
}
```

This ensures:
1. UI can request anonymized view via `?anonymizedView=true`
2. Anonymization happens server-side for consistency
3. No PII leaks even if client-side processing is bypassed
  </action>
  <verify>
    grep -l "anonymizeSearchResponse" services/hh-search-svc/src/routes/search.ts || echo "Integration point planned"
  </verify>
  <done>
    Search API endpoint wired to conditionally apply anonymization based on query parameter.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles: `npx tsc --noEmit --project services/hh-search-svc/tsconfig.json`
- Tests pass: `cd services/hh-search-svc && npm test -- --grep "anonymize" --run`
- Types exported: Check barrel export at `src/bias/index.ts`
- API integration: `grep "anonymizeSearchResponse" services/hh-search-svc/src/routes/search.ts`
</verification>

<success_criteria>
1. AnonymizationConfig and AnonymizedCandidate types defined
2. anonymizeCandidate strips name, title, headline, location, metadata
3. companyPedigree and companyRelevance excluded from anonymized scores
4. Match reasons filtered to remove company/school/location mentions
5. All 15+ tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-bias-reduction/14-01-SUMMARY.md`
</output>
