#!/usr/bin/env bash
set -euo pipefail


SCRIPT_DIR=${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}
# Guard against running from deprecated repository clones.
REPO_ROOT=${REPO_ROOT:-$(cd "${SCRIPT_DIR}/.." && pwd)}
# shellcheck source=./utils/repo_guard.sh
source "${SCRIPT_DIR}/utils/repo_guard.sh"

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "${ROOT_DIR}"

COMPOSE_FILE="${ROOT_DIR}/docker-compose.local.yml"

usage() {
  cat <<'USAGE'
Usage: scripts/optimize-build-context.sh [--service NAME] [--write]

Analyze Docker build contexts for hh-* services and suggest dockerignore optimizations.
  --service NAME   Limit analysis to a single service (e.g. hh-enrich-svc)
  --write          Generate per-service dockerignore recommendation files when missing
USAGE
}

SERVICE_FILTER=""
WRITE_MODE=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --service)
      SERVICE_FILTER="$2"
      shift 2
      ;;
    --write)
      WRITE_MODE=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown option: $1" >&2
      usage
      exit 1
      ;;
  esac
done

if [[ ! -f "${COMPOSE_FILE}" ]]; then
  echo "docker-compose.local.yml not found at ${COMPOSE_FILE}" >&2
  exit 1
fi

PYTHON_OUTPUT=""
if ! PYTHON_OUTPUT="$(python3 - <<'PY'
import sys
from pathlib import Path

try:
    import yaml
except ImportError:
    sys.stderr.write("PyYAML is required. Install it with 'pip install PyYAML'.\n")
    sys.exit(2)

compose = yaml.safe_load(Path("docker-compose.local.yml").read_text()) or {}

for name, svc in (compose.get("services") or {}).items():
    build = svc.get("build")
    if not build:
        continue
    if not (name.startswith("hh-") and name.endswith("-svc")):
        continue
    if isinstance(build, str):
        context = build
        dockerfile = "Dockerfile"
    else:
        context = build.get("context", ".")
        dockerfile = build.get("dockerfile") or "Dockerfile"
    print(f"{name}|{context}|{dockerfile}")
PY
)"; then
  status=$?
  exit "${status}"
fi

mapfile -t SERVICES_RAW <<<"${PYTHON_OUTPUT//$'\r'/}"

declare -a SERVICES
declare -A SERVICE_CONTEXTS

for entry in "${SERVICES_RAW[@]}"; do
  [[ -z "${entry}" ]] && continue
  IFS='|' read -r service context _ <<<"${entry}"
  if [[ -n "${SERVICE_FILTER}" && "${service}" != "${SERVICE_FILTER}" ]]; then
    continue
  fi
  SERVICES+=("${service}")
  SERVICE_CONTEXTS["${service}"]="${context:-.}"
done

if [[ ${#SERVICES[@]} -eq 0 ]]; then
  echo "No services matched the filter." >&2
  exit 1
fi

resolve_context_path() {
  local ctx="$1"
  if [[ -z "${ctx}" || "${ctx}" == "." ]]; then
    printf '%s\n' "${ROOT_DIR}"
  elif [[ "${ctx}" == /* ]]; then
    printf '%s\n' "${ctx}"
  else
    ctx="${ctx#./}"
    printf '%s\n' "${ROOT_DIR}/${ctx}"
  fi
}

print_top_consumers() {
  local path="$1"
  if [[ ! -d "${path}" ]]; then
    echo "   context path missing: ${path}"
    return
  fi
  echo "   largest entries:"
  du -sh "${path}"/* 2>/dev/null | sort -hr | head -n 8 | sed 's/^/     - /'
}

list_missing_patterns() {
  local ignore_file="$1"
  shift
  local suggested=()
  local have_ignore=0
  if [[ -f "${ignore_file}" ]]; then
    have_ignore=1
  fi
  local pattern
  for pattern in "$@"; do
    if [[ ${have_ignore} -eq 1 ]] && grep -Fxq "${pattern}" "${ignore_file}" 2>/dev/null; then
      continue
    fi
    suggested+=("${pattern}")
  done
  printf '%s\n' "${suggested[@]}"
}

create_recommendation_file() {
  local service="$1"
  local target_dir="$2"
  local rec_path="${target_dir}/.dockerignore.recommendations"
  shift 2
  local patterns=("$@")
  if [[ ${#patterns[@]} -eq 0 ]]; then
    return
  fi
  {
    echo "# Generated by scripts/optimize-build-context.sh"
    echo "# Review and merge into .dockerignore as needed"
    for p in "${patterns[@]}"; do
      echo "${p}"
    done
  } > "${rec_path}"
  echo "   wrote recommendations to ${rec_path}"
}

for service in "${SERVICES[@]}"; do
  ctx="${SERVICE_CONTEXTS[${service}]}"
  path="$(resolve_context_path "${ctx}")"
  echo "\n=== ${service} ==="
  echo "   context: ${ctx} (${path})"
  if [[ -d "${path}" ]]; then
    size=$(du -sh "${path}" 2>/dev/null | awk '{print $1}')
    echo "   approx size: ${size:-unknown}"
  else
    echo "   context missing on disk"
  fi

  print_top_consumers "${path}"

  ignore_file="${path%/}/.dockerignore"
  baseline_patterns=(
    "node_modules"
    "**/node_modules"
    "**/dist"
    "**/build"
    "**/coverage"
    "**/tests"
    "**/*.test.ts"
    "**/*.spec.ts"
    "**/docs"
    "**/*.log"
  )
  # shellcheck disable=SC2207
  missing_patterns=($(list_missing_patterns "${ignore_file}" "${baseline_patterns[@]}"))
  if [[ ${#missing_patterns[@]} -gt 0 ]]; then
    echo "   recommended exclusions:"
    for pattern in "${missing_patterns[@]}"; do
      echo "     - ${pattern}"
    done
    if [[ ${WRITE_MODE} -eq 1 ]]; then
      create_recommendation_file "${service}" "${path}" "${missing_patterns[@]}"
    fi
  else
    echo "   dockerignore already covers baseline patterns"
  fi

  if [[ -f "${ignore_file}" ]]; then
    echo "   dockerignore: ${ignore_file}"
  else
    echo "   dockerignore: none (consider creating one)"
    if [[ ${WRITE_MODE} -eq 1 ]]; then
      create_recommendation_file "${service}" "${path}" "${baseline_patterns[@]}"
    fi
  fi

done

cat <<'SUMMARY'

=== Summary ===
- Baseline recommendations flag directories that frequently inflate build contexts (node_modules, dist, tests, docs, coverage).
- Review .dockerignore.recommendations files (if generated) and merge relevant patterns.
- After updates, rerun scripts/test-docker-builds.sh to validate BuildKit and legacy builders.
- Consider committing service-specific .dockerignore files when context remains >50MB.
SUMMARY
